3d5e396e1bedda0b7c07b52d21765f069cbc3eec
Author: Neekon Saadat <neekonsu@gmail.com>
Date: Tue Jul 29 11:33:32 2025
Subject: removed items from remarks pertaining to BBStr after investigating and determining safe

diff --git a/Documentation/REMARKS.md b/Documentation/REMARKS.md
index 3260cd32..f88cbff2 100644
--- a/Documentation/REMARKS.md
+++ b/Documentation/REMARKS.md
@@ -5,7 +5,7 @@
 # common/
 
 ## bbstr
-```
+<!-- ```
 BBStr *bbstr_new(char *s, int len) {
     // Create a new bbstr from an existing string or allocate empty.
     // If len < 0 (BBSTR_COPY) then it will use strlen.
@@ -44,7 +44,7 @@ BBStr *bbstr_ref(BBStr *bbstr) {
     return bbstr;
 }
 ```
-purpose? 
+purpose?  -->
 
 ```
 char *bbstr_malloc_copy(BBStr *bstr) {

c54a71e7c7ddddc5b923373355da29e34d699369
Author: Neekon Saadat <neekonsu@gmail.com>
Date: Thu Jul 24 19:35:22 2025
Subject: 1/2 way manual code review common/, pending handle/ and cms/

diff --git a/Documentation/REMARKS.md b/Documentation/REMARKS.md
index 68def20d..3260cd32 100644
--- a/Documentation/REMARKS.md
+++ b/Documentation/REMARKS.md
@@ -274,6 +274,1246 @@ typedef struct _BBStrNode {
 ```
 All that in bbstr.c just for ref_count? Let's review.
 
+
+```
+
+// **************************************************************************************
+// THEORY
+// (Why is does this module exist?)
+// (Why was some simpler option avoided?)
+// (What non-obvious vocabulary is used?)
+// (What naming conventions are used?)
+// **************************************************************************************
+```
+Let's establish a documentation standard (informal, non qms) that we all use; these templates were rarely filled out but should be somewhere.
+
+```
+int cli_split_args(char *command, char **out_args, int max_args) {
+    // Split a string by whitespace; eg: "foo bar 123" -> out_args: ["foo", "bar", "123"]
+    // Writes up to max_args into out_args and returns number of split args
+    bool seaching_for_non_whitespace = false;
+    int arg_i = 0;
+    char *last_start = command;
+    char *curr = last_start;
+    char *end = &command[strlen(command)];
+    while (curr <= end) {
+        bool is_whitespace = (*curr == ' ' || *curr == '\t' || *curr == '\r' || *curr == '\n');
+        if (seaching_for_non_whitespace) {
+            if (! is_whitespace) {
+                last_start = curr;
+                seaching_for_non_whitespace = 0;
+            }
+        }
+        else {
+            if (is_whitespace || *curr == 0) {
+                *curr = 0;
+                out_args[arg_i] = last_start;
+                arg_i++;
+                seaching_for_non_whitespace = 1;
+            }
+        }
+        if (arg_i >= max_args) {
+            break;
+        }
+        curr++;
+    }
+    return arg_i;
+}
+```
+Redundant, verbatim repeat of string checking logic from BBStr API, breaks abstraction or warrants removal of API. Is this the best way to process arguments? We can set a strict input format to simplify checks.
+
+```
+Err cli_parse_gpio_pin_string(char *arg, GPIO_TypeDef **block, uint16_t *pin) {
+    // Convert a string like "A5" to the correct GPIO block
+    // and pin number. Return 0 on success.
+    char blockLetter = arg[0];
+    char *blockPin = &arg[1];
+    if (blockLetter >= 'a' && blockLetter <= 'g') {
+        blockLetter = (blockLetter - 'a') + 'A';
+    }
+
+    GPIO_TypeDef *gpioBlocks[] = {GPIOA, GPIOB, GPIOC, GPIOD, GPIOE, GPIOF, GPIOG};
+
+    if (blockLetter >= 'A' && blockLetter <= 'G') {
+        *block = gpioBlocks[blockLetter - 'A'];
+        *pin = atoi(blockPin);
+        return NOERR;
+    }
+
+    return -1;
+}
+```
+Improve error specificity, migrate away from entering strings for GPIO and instead input pin number (chip referenced). Eliminates need for 2 translation steps, saves memory, and further reduces potential fallout from BO overwriting LU's for pin assignment.
+
+```
+#ifndef CLI_HELPERS_H
+#define CLI_HELPERS_H
+```
+Does this do anything?
+
+## comm
+```
+uint8_t _xmit_buffer[N_FIFO_PACKETS * PACKET_MEM_SIZE];
+uint8_t _recv_buffer[N_FIFO_PACKETS * PACKET_MEM_SIZE];
+```
+Revise nomeclature.
+
+```
+/**
+ * @brief Waits after UART IDLE event to allow DMA transfer to complete.
+ *
+ * Ensures enough delay after an IDLE interrupt for DMA transfer to finish
+ * so that frame processing does not occur prematurely, which could lead to
+ * CRC errors or packet loss.
+ */
+void _receive_idle_wait_for_dma() {
+    // When the IDLE interrupt fires the DMA is typically not done transferring.
+
+    // I don't think there's a good way of doing this that isn't packet-size aware
+    // because the DMA has no idea how many bytes are coming and therefore checking
+    // its registers only tells you how far it is from filling the max-size buffer.
+    //
+    // Furthermore, if I use a size-based in the packet prefix then I might get a corruption
+    // and then block for too long (although I can limit the problem by limiting to the max buffer size).
+    //
+    // If I wanted to so that size check without that failure mode then I'd need to apply a CRC to the
+    // header and a different CRC to the data block.
+    //
+    // For now, I'm going to simply spin and in the case that this proceeds too early
+    // it will result in a failed CRC and thus a packet drop.
+    // Based on tests:
+    //   20 was sufficeint 0% of the time
+    //   30 was sufficient 50% of the time
+    //   40 was sufficient 100% of the time
+    for (int i = 0; i < 40; i++) {
+    }
+}
+```
+Perhaps we have DMA module send ready flag/read ready flag from peripheral as separate interrupt instead of timing relative to UART_IDLE -> NOT SAFE!
+
+
+```
+/**
+ * @brief Callback for DMA error interrupts.
+ *
+ * Logs DMA error flags for debugging purposes.
+ *
+ * @param hdma Pointer to DMA handle where the error occurred.
+ */
+void HAL_DMA_ErrorCallback(DMA_HandleTypeDef *hdma) {
+    printf("HAL_DMA_ErrorCallback\n");
+    if (__HAL_DMA_GET_FLAG(hdma, DMA_FLAG_TC6)) {
+        printf("  DMA_FLAG_TC6: Transfer complete\n");
+    }
+    if (__HAL_DMA_GET_FLAG(hdma, DMA_FLAG_HT6)) {
+        printf("  DMA_FLAG_HT6: Half-transfer complete\n");
+    }
+    if (__HAL_DMA_GET_FLAG(hdma, DMA_FLAG_TE6)) {
+        printf("  DMA_FLAG_TE6: Trasfer error\n");
+    }
+    if (__HAL_DMA_GET_FLAG(hdma, DMA_FLAG_GL6)) {
+        printf("  DMA_FLAG_GL6: Global interrupt\n");
+    }
+}
+```
+Let's review errors across codebase, could we fold this into a general error format? Consistently ad-hoc flags and printouts need to be overhauled into consolidated system.
+
+```
+/**
+ * @brief Callback for UART error interrupts.
+ *
+ * Handles UART overrun, framing, noise, and other errors. Attempts recovery by
+ * restarting reception or flushing buffers.
+ *
+ * @param huart Pointer to UART handle where the error occurred.
+ */
+void HAL_UART_ErrorCallback(UART_HandleTypeDef *huart) {
+    printf("HAL_UART_ErrorCallback: ");
+
+    if (huart->ErrorCode & HAL_UART_ERROR_ORE) {
+        // TODO: I do not understand under what situation this occurs.
+        // Right now its happening whenver the CMS sleeps for a long time.
+        HAL_UART_DMAStop(huart);
+        __HAL_UART_CLEAR_OREFLAG(huart);
+        comm_recv_packets();
+    }
+
+    if (huart->ErrorCode & HAL_UART_ERROR_PE) {
+        printf("Parity Error\n");
+    }
+    if (huart->ErrorCode & HAL_UART_ERROR_NE) {
+        printf("Noise Error\n");
+    }
+    if (huart->ErrorCode & HAL_UART_ERROR_FE) {
+        printf("Framing Error\n");
+        HAL_UART_DMAStop(huart);
+        __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_FEF);
+        __HAL_UART_FLUSH_DRREGISTER(huart);
+        __HAL_UART_CLEAR_OREFLAG(huart);
+        comm_recv_packets();
+    }
+    if (huart->ErrorCode & HAL_UART_ERROR_ORE) {
+        printf("Overrun Error\n");
+    }
+    if (huart->ErrorCode & HAL_UART_ERROR_DMA) {
+        printf("DMA Transfer Error\n");
+    }
+    if (huart->Instance->ISR & USART_ISR_PE) {
+        printf("  USART_ISR_PE\n");
+    }
+    printf("ISR State: ");
+    if (huart->Instance->ISR & USART_ISR_FE) {
+        printf("USART_ISR_FE ");
+    }
+    if (huart->Instance->ISR & USART_ISR_NE) {
+        printf("USART_ISR_NE ");
+    }
+    if (huart->Instance->ISR & USART_ISR_ORE) {
+        printf("USART_ISR_ORE ");
+    }
+    if (huart->Instance->ISR & USART_ISR_IDLE) {
+        printf("USART_ISR_IDLE ");
+    }
+    if (huart->Instance->ISR & USART_ISR_RXNE) {
+        printf("USART_ISR_RXNE ");
+    }
+    if (huart->Instance->ISR & USART_ISR_TC) {
+        printf("USART_ISR_TC ");
+    }
+    if (huart->Instance->ISR & USART_ISR_TXE) {
+        printf("USART_ISR_TXE ");
+    }
+    if (huart->Instance->ISR & USART_ISR_LBDF) {
+        printf("USART_ISR_LBDF ");
+    }
+    if (huart->Instance->ISR & USART_ISR_CTSIF) {
+        printf("USART_ISR_CTSIF ");
+    }
+    if (huart->Instance->ISR & USART_ISR_CTS) {
+        printf("USART_ISR_CTS ");
+    }
+    if (huart->Instance->ISR & USART_ISR_RTOF) {
+        printf("USART_ISR_RTOF ");
+    }
+    if (huart->Instance->ISR & USART_ISR_EOBF) {
+        printf("USART_ISR_EOBF ");
+    }
+    if (huart->Instance->ISR & USART_ISR_ABRE) {
+        printf("USART_ISR_ABRE ");
+    }
+    if (huart->Instance->ISR & USART_ISR_ABRF) {
+        printf("USART_ISR_ABRF ");
+    }
+    if (huart->Instance->ISR & USART_ISR_BUSY) {
+        printf("USART_ISR_BUSY ");
+    }
+    if (huart->Instance->ISR & USART_ISR_CMF) {
+        printf("USART_ISR_CMF ");
+    }
+    if (huart->Instance->ISR & USART_ISR_SBKF) {
+        printf("USART_ISR_SBKF ");
+    }
+    if (huart->Instance->ISR & USART_ISR_RWU) {
+        printf("USART_ISR_RWU ");
+    }
+    if (huart->Instance->ISR & USART_ISR_WUF) {
+        printf("USART_ISR_WUF ");
+    }
+    if (huart->Instance->ISR & USART_ISR_TEACK) {
+        printf("USART_ISR_TEACK ");
+    }
+    if (huart->Instance->ISR & USART_ISR_REACK) {
+        printf("USART_ISR_REACK ");
+    }
+    printf("\n");
+
+    comm_enable_reception();
+}
+```
+Safe but can be folded into LUT for concision.
+
+
+```
+    if (huart->ErrorCode & HAL_UART_ERROR_ORE) {
+        // TODO: I do not understand under what situation this occurs.
+        // Right now its happening whenver the CMS sleeps for a long time.
+        HAL_UART_DMAStop(huart);
+        __HAL_UART_CLEAR_OREFLAG(huart);
+        comm_recv_packets();
+    }
+```
+This is from the same snippet as above: need to investigate in emulator and understand.
+
+
+
+```
+/**
+ * @brief UART transmission complete callback.
+ *
+ * Called when DMA transmission is complete. Enables reception and triggers
+ * next receive call.
+ *
+ * @param huart Pointer to UART handle that finished transmitting.
+ */
+void HAL_UART_TxCpltCallback(UART_HandleTypeDef *huart) {
+    // Called by the HAL when a transmission is complete.
+    // This is in the context of an interrupt.
+    if (huart->ErrorCode != 0 || huart->Instance != USART2) {
+        printf("HAL_UART_TxCpltCallback. huart->ErrorCode = %u\n", (unsigned)huart->ErrorCode);
+    }
+    else {
+        comm_enable_reception();
+        comm_recv_packets();
+        xmit_done_count++;
+    }
+}
+```
+Investigate.
+
+```
+#if ! defined(CRIT_SECT_TEST) && ! defined(ATOMIC_INC_TEST)
+/**
+ * @brief Timer interrupt callback for elapsed period.
+ *
+ * Transmits packets after a delay to simulate reply timing.
+ *
+ * @param htim Timer handle which triggered the callback.
+ */
+void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim) {
+    // After a bit of delay we can now send the reply.
+    if (htim->Instance == TIM2) {
+        comm_xmit_packets();
+    }
+}
+#endif
+```
+Need standard for writing tests.
+
+```
+/**
+ * @brief UART receive event callback for IDLE detection.
+ *
+ * Handles frame reception using DMA and verifies CRC. Decodes valid packets into
+ * the receive FIFO and optionally schedules a reply using a timer.
+ *
+ * @param huart UART handle that received data.
+ * @param size Number of bytes received.
+ */
+void HAL_UARTEx_RxEventCallback(UART_HandleTypeDef *huart, uint16_t size) {
+    if (huart->ErrorCode != 0 ) {
+        // TODO Proper error handling
+        printf("HAL_UARTEx_RxEventCallback. huart->ErrorCode = %u\n", (unsigned)huart->ErrorCode);
+    }
+    if(huart->Instance != USART2) {
+        printf("HAL_UARTEx_RxEventCallback non-usart2\n");
+    }
+
+    HAL_UART_RxEventTypeTypeDef event = HAL_UARTEx_GetRxEventType(huart);
+    if (event == HAL_UART_RXEVENT_IDLE) {
+        _receive_idle_wait_for_dma();
+
+        uint16_t bytes_received = sizeof(_recv_buffer) - __HAL_DMA_GET_COUNTER(huart->hdmarx);
+
+        // A frame has arrived. Split it into packets and check the CRC.
+        Frame *frame = (Frame *)_recv_buffer;
+
+        // Compare receved and computed CRC
+        uint32_t recv_crc = frame->crc;
+        frame->crc = 0;
+        uint32_t comp_crc = crc32_calc((uint8_t *)frame, bytes_received, CRC_INITIAL);
+
+        Packet *last_dst_packet = NULL;
+
+        if (comp_crc == recv_crc) {
+            // Decode the frame into packets into the recv fifo
+            int src_i = 0;
+            for (int i = 0; i < frame->n_packets; i++) {
+                if (src_i < bytes_received) {
+                    Packet *src_packet = (Packet *)&frame->packets[src_i];
+                    size_t src_size = src_packet->n_bytes;
+                    if (src_i + src_size <= bytes_received) {
+                        Packet *dst_packet = fifo_writ_get_ptr(&recv_fifo);
+                        if (dst_packet) {
+                            last_dst_packet = dst_packet;
+                            if (src_size <= PACKET_SIZE) {
+                                memcpy(dst_packet, src_packet, src_size);
+
+                                // printf("<-------- recv_packet\n  ");
+                                // packet_dump(dst_packet);
+
+                            }
+                            fifo_writ_done(&recv_fifo);
+                        }
+                        else {
+                            // printf("Overflow. No place to put next recv packet\n");
+                        }
+                        src_i += src_size;
+                    }
+                }
+            }
+        }
+        else {
+            printf("Error: CRC check failed on received packet\n");
+        }
+
+        if (_comm_reply_callback) {
+            (*_comm_reply_callback)(last_dst_packet);
+
+            // At 100 was good enough
+            // 50 was also good enough
+            // 25 was too little -- BUT, and this is weird. It is only too little for the FIRST packet. WHy?
+            // There's somethign different about the first time. Somethign about the CMS start isn't fast at first.
+            // I really don't see what it is so maybe I should just reduce the timeout period? Or maybe for the first
+            // packet?
+            const uint32_t reply_delay_ms = 25;
+            comm_timer_start(reply_delay_ms);
+        }
+        else {
+            comm_recv_packets();
+        }
+
+        recv_done_count++;
+    }
+    else {
+        // This could be a HT or full buffer.
+        // In the case of a full buffer it means that somehow something larger than a full packet
+        // was sent so this is a serious error that should be handled.
+    }
+}
+```
+Not acceptable to leave unfinished code, unhandled errors, and trial&error derived timings in production code. Needs revision asap.
+
+```
+void comm_timer_start(uint32_t period_ms) {
+    // When the period_ms is less than 2 the timer doesn't work.
+    // There's go to be some genral solution to that but I don't relaly
+    // care right now while I'm debugging the reply timing so I'm just going to make the minimum 2.
+    period_ms = max(2, period_ms);
+
+    TIM_HandleTypeDef *htim = &htim2;
+
+    HAL_TIM_Base_Stop_IT(htim);
+
+    // Set the desired prescaler and auto-reload values to match the required period
+    uint32_t clock_freq = HAL_RCC_GetPCLK1Freq(); // Or PCLK2 depending on the timer
+    uint32_t prescaler = (clock_freq / 1000) - 1; // Convert clock to milliseconds
+    uint32_t period = period_ms - 1;
+
+    // Set the prescaler and the period (ARR) for the timer
+    __HAL_TIM_SET_PRESCALER(htim, prescaler);
+    __HAL_TIM_SET_AUTORELOAD(htim, period);
+
+    // Start the timer in interrupt mode
+    __HAL_TIM_SET_COUNTER(htim, 0);              // Reset the counter
+    __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_UPDATE); // Clear any pending update event
+
+    __HAL_TIM_ENABLE_IT(htim, TIM_IT_UPDATE); // Enable the update interrupt explicitly
+
+    // Ensure the timer is in OPM mode (One Pulse Mode)
+    htim->Instance->CR1 |= TIM_CR1_OPM;
+    Err err = HAL_TIM_Base_Start_IT(htim);
+    inquis_assert(err == 0);
+}
+```
+Good that it works, we should know why one and done.
+
+
+```
+void comm_xmit_packets() {
+    // Copy all of the xmit packets in the FIFO into a single xmit_buffer, compute CRC, frame and start DMA xmit.
+    int n_avail = fifo_n_avail(&xmit_fifo);
+
+    Frame *frame = (Frame *)_xmit_buffer;
+    frame->crc = 0;
+    frame->n_packets = n_avail;
+    uint8_t *dst = frame->packets;
+
+    for (int i = 0; i < n_avail; i++) {
+        Packet *packet = fifo_read_get_ptr(&xmit_fifo, 0);
+        if (packet) {
+            // printf("--------> xmit_packet[%d]\n  ", i);
+            // packet_dump(packet);
+
+            uint8_t *src = (uint8_t *)packet;
+            int src_size = packet->n_bytes;
+            memcpy(dst, src, src_size);
+            dst += src_size;
+            inquis_assert(dst - _xmit_buffer < sizeof(_xmit_buffer));
+            fifo_read_done(&xmit_fifo);
+        }
+    }
+
+    size_t xmit_size = dst - _xmit_buffer;
+    frame->crc = crc32_calc((uint8_t *)frame, xmit_size, CRC_INITIAL);
+
+    comm_enable_transmission();
+    Err err = HAL_UART_Transmit_DMA(&huart2, _xmit_buffer, xmit_size);
+    if (err != HAL_OK) {
+        printf("  ERROR: HAL_UART_Transmit_DMA, err = %d\n", err);
+    }
+}
+```
+Replace commented out debug lines with ifdef blocks for consistency.
+
+## common
+
+```
+// To get this value I have to remove the "static" declaration in
+extern uint8_t *__sbrk_heap_end;
+```
+???
+
+```
+#if TESTING_ENABLED == 1
+// Used to monitor the error conditions by tests
+char *try_scope_error_handler_was_run_msg = NULL;
+char *try_scope_error_handler_was_run_file = NULL;
+int try_scope_error_handler_was_run_line = 0;
+#endif
+```
+Not the way to do this, let's start here when speccing the new error reporting framework.
+
+
+```
+/**
+ * @brief Error handler used by TRY macros for testing and logging.
+ *
+ * Emits debug messages and optionally tracks error details for testing purposes.
+ *
+ * @param msg   Description of the failed operation.
+ * @param err   Error code returned.
+ * @param file  Source file where the error occurred.
+ * @param line  Line number where the error occurred.
+ */
+void try_scope_error_handler(char *msg, Err err, char *file, int line) {
+#if TESTING_ENABLED == 1
+    if (tests_running) {
+        try_scope_error_handler_was_run_msg = msg;
+        try_scope_error_handler_was_run_file = file;
+        try_scope_error_handler_was_run_line = line;
+    }
+    else {
+        try_scope_error_handler_was_run_msg = NULL;
+        try_scope_error_handler_was_run_file = NULL;
+        try_scope_error_handler_was_run_line = 0;
+    }
+#endif
+    emit_debug("Try-Catch Error: '%s' failed with code: %d @%s:%d\n", msg, err, file, line);
+}
+```
+Same comment as above and case and point. Needs a close look, this approach is unsustainable in production and for sophisticated stacktraces.
+
+
+
+```
+/**
+ * @brief Sleeps for the specified number of milliseconds while petting the watchdog.
+ *
+ * @param ms Duration in milliseconds.
+ */
+void sleep_ms(int ms) {
+    // Sleep and pet the watchdog every 100ms
+    while (ms > 0) {
+        pet_watchdog();
+        int _ms = min(ms, 100);
+        HAL_Delay(_ms);
+        ms -= _ms;
+    }
+}
+```
+Funny.
+
+
+```
+/**
+ * @brief Returns the current system time in milliseconds since boot.
+ */
+TimeMS get_time_ms() {
+    // This is wrapped to avoid inclusion of the entire HAL headers into the state headers.
+    return (TimeMS)HAL_GetTick();
+}
+```
+Investigate further, may have better approach.
+
+
+```
+/**
+ * @brief Returns adjusted time with offset applied.
+ *
+ * Do not use for timers, as time may go backward.
+ */
+TimeMS get_sync_time_ms() {
+    // TODO: This wil have an adjustable offset which might allow time to go backwards
+    // so do not use as a timer.
+    return get_time_ms() - _time_difference_ms;
+}
+```
+Trace usage with Doxygen; why does this exist given the reverse time bug?
+
+
+```
+/**
+ * @brief Halts program execution, continuously pets the watchdog.
+ *
+ * @param msg Optional message to emit before halting.
+ */
+void halt(char *msg) {
+    // TODO Emit message to BOTH stdout and to SD Card streams
+    if (msg) {
+        printf("%s", msg);
+    }
+    fflush(stdout);
+    fflush(stderr);
+
+    // #if TESTING_ENABLED == 1
+    //     if (inttest_bypass_halt != 0) {
+    //         inttest_bypass_halt_reason = msg;
+    //         return;
+    //     }
+    // #endif
+
+    // Loop forever
+    while (1) {
+        pet_watchdog();
+    }
+}
+```
+Unfinished code. Trace usage with Doxygen; why do we explicitly halt as opposed to simply exiting?
+
+
+```
+ /*
+    This function is for the "Buffer manipulation paranoia level 10" pattern
+    wherein you check the size of a buffer before you write into it
+    AND you check it again with a strlen afterwards to ensure you didn't overwrite.
+
+    Args:
+        dst: The destination buffer.
+            This is used for sanity checking (non-NULL) and also for strlen.
+            It is also convenient in the case of a real memory corruption in that
+            you could log or check these addresses in debug mode.
+        dst_buf_size:
+            The total size of the buffer.
+        n_chars:
+            The number of characters to write. Because of C's nul-string
+            character this must be <= dstBufSize - 1
+        stop_on_fail:
+            If true then it halts execution on failure.
+
+    Returns:
+        err-style. 0=success
+
+    Example usage:
+        void write_a_string(char *buf, int buf_len, float value) {
+            // This will write an 8 character string of value into buf
+
+            int err = 0;
+            TRY_START {
+                const int need_chars = 8;
+                err = stringBufferCheck(buf, buf_len, need_chars, false);
+                TRY_CHECK("destination string not long enough for target");
+
+                // Use snprintf, note that a common mistake is to
+                // Forget to -1 on the n. This would be caught by
+                // the following second check.
+                snprintf(buf, bufMaxSize - 1, "%08.1f", value);
+
+                err = stringBufferCheck(buf, buf_len, 0, false);
+                TRY_CHECK("destination string overwrote end of buffer");
+
+            } TRY_END;
+        }
+
+        void main() {
+            #define BUF_LEN (16)
+            char dstBuf[BUF_LEN];
+            writeAString(char *buf, int buf_len, float value) {
+        }
+    */
+```
+Pythonic docstring?
+
+
+```
+// Based on
+// https://community.st.com/t5/stm32-mcu-products/how-do-you-measure-the-execution-cpu-cycles-for-a-section-of/td-p/213709
+volatile unsigned int *DWT_CYCCNT = (volatile unsigned int *)0xE0001004;
+volatile unsigned int *DWT_CONTROL = (volatile unsigned int *)0xE0001000;
+volatile unsigned int *DWT_LAR = (volatile unsigned int *)0xE0001FB0;
+volatile unsigned int *SCB_DHCSR = (volatile unsigned int *)0xE000EDF0;
+volatile unsigned int *SCB_DEMCR = (volatile unsigned int *)0xE000EDFC;
+volatile unsigned int *ITM_TER = (volatile unsigned int *)0xE0000E00;
+volatile unsigned int *ITM_TCR = (volatile unsigned int *)0xE0000E80;
+static int Debug_ITMDebug = 0;
+
+/**
+ * @brief Enables CPU cycle counter (DWT_CYCCNT) for profiling.
+ */
+void enable_timing() {
+    if ((*SCB_DHCSR & 1) && (*ITM_TER & 1)) {
+        Debug_ITMDebug = 1;
+    }
+
+    *SCB_DEMCR |= 0x01000000;
+    *DWT_LAR = 0xC5ACCE55; // enable access
+    *DWT_CYCCNT = 0;       // reset the counter
+    *DWT_CONTROL |= 1;     // enable the counter
+}
+```
+Not needed, this should be profiled in emulation.
+
+
+```
+/**
+ * @brief Fails with an assert and halts while petting the watchdog.
+ *
+ * @param msg Assertion message.
+ * @param file Source file name.
+ * @param line Line number of failure.
+ */
+void inquis_assert_failed(char *msg, char *file, int line) {
+    // We use a custom version of assert here instead of the
+    // standard C assert because we do not want to exit but
+    // rather we want to go into a halt() that will pet the watchdog.
+    char buf[256];
+    sprintf(buf, "Assert failed: '%s' at %s:%d\n", msg, file, line);
+    halt(buf);
+}
+```
+Same comments about overhauling error handling; we also need a better naming standard, inquis randomly appears here.
+
+
+```
+/**
+ * @brief Prints a hexadecimal and ASCII representation of memory.
+ *
+ * @param _ptr Pointer to memory.
+ * @param n_bytes Number of bytes to dump.
+ */
+void hex_dump(void *_ptr, uint32_t n_bytes) {
+    int i, j;
+    int last_line_start_i = 0;
+    uint8_t *ptr = (uint8_t *)_ptr;
+
+    for (i = 0; i < n_bytes; i++) {
+        pet_watchdog();
+        if (i % 16 == 8) {
+            printf(" ");
+        }
+        printf("%02x ", ptr[i]);
+        bool is_end = i == n_bytes - 1;
+        if ((i > 0 && i % 16 == 15) || is_end) {
+            printf("  ");
+            if (is_end) {
+                int padding = i % 16 == 15 ? 0 : 16 - ((i + 1) % 16);
+                for (j = 0; j < padding; j++) {
+                    printf("   ");
+                }
+                if (padding >= 8) {
+                    printf(" "); // Center gap.
+                }
+            }
+            int w = i - last_line_start_i + 1; // +1 because we're at %16 == 15
+            for (int j = 0; j < w; j++) {
+                if (j % 16 == 8) {
+                    printf(" ");
+                }
+                uint8_t c = ptr[last_line_start_i + j];
+                printf("%c", (c >= 32 && c <= 126) ? c : '.');
+            }
+            last_line_start_i = i + 1; // +1 because we're at %16 == 15
+            printf("\n");
+        }
+    }
+}
+```
+Verify.
+
+
+```
+/**
+ * @brief Asserts that there is sufficient free stack space.
+ */
+void stack_check() {
+    // The value of __sbrk_heap_end wil be wrong until a single malloc is called
+    // extern uint8_t _estack; // Defines the bottom of the stack (which is higher in memory as the stack grows down)
+    uint32_t stack_top = __get_MSP();
+    // int stack_size = (int)((unsigned)&_estack - (unsigned)stack_top);
+    int stack_free_space = (unsigned)stack_top - (unsigned)__sbrk_heap_end;
+    // printf("stack_size=%d stack_free=%d\n", stack_size, stack_free_space);
+    inquis_assert(stack_free_space > 512);
+}
+```
+Unfinished code and potentially trouble.
+
+
+```
+
+// A TRY_SCOPE is a C preprocessor macro-set to make a scope-like
+// block that acts like a try-finally block.
+//   It is particularly useful when there are a long series
+// of verbose and repetitive error checks as it allows
+// the block of checks to terminate early and jump over
+// the code that should not be exxecuted given the error mode.
+//
+// For example:
+//   void try_scope_error_handler(char *msg, Err err, char *file, int line) {
+//       printf("Error: '%s' with code: %d @ %s:%d\n", msg, err, file, line);
+//   }
+//
+//   Err err = 0;
+//   TRY_START {
+//      err = do_something_error_prone();
+//      TRY_CHECK("do_something_error_prone");
+//      // When err is non-zero we do NOT want to run
+//      // do_something_else() NOR get_some_value_that_needs_to_be_in_range()
+//
+//      err = do_something_else();
+//      TRY_CHECK("something_else");
+//
+//      int someVal = get_some_value_that_needs_to_be_in_range();
+//      TRY_CHECK_IS(someVal < 10, "someVal was wrong");
+//   }
+//   TRY_END;
+//
+//   printf("This will be run no matter the success or failure.\n");
+
+#define TRY_START do
+#define TRY_END                                                                                                        \
+    while (0)                                                                                                          \
+        ;
+#define TRY_CHECK(fail_msg)                                                                                            \
+    if (err != 0) {                                                                                                    \
+        try_scope_error_handler(fail_msg, err, __FILE__, __LINE__);                                                    \
+        break;                                                                                                         \
+    }
+#define TRY_CHECK_IS(predicate, fail_msg)                                                                              \
+    if (! (predicate)) {                                                                                               \
+        err = __LINE__;                                                                                                \
+        try_scope_error_handler(fail_msg, err, __FILE__, __LINE__);                                                    \
+        break;                                                                                                         \
+    }
+
+// We use a custom version of assert here instead of the
+// standard C assert because we do not want to exit but
+// rather we want to go into a halt() that will pet the watchdog.
+// There should be NO references to assert() anywhere.
+#define inquis_assert(x)                                                                                               \
+    if (! (x)) {                                                                                                       \
+        inquis_assert_failed(#x, __FILE__, __LINE__);                                                                  \
+    }
+```
+Need better error handling.
+
+
+Remarks on common: needs extensive work to bring up to spec. Should be one of primary focuses in upcoming code review and project to spec error system.
+
+## config
+
+```
+
+char *_config_names[] = {
+    // Do NOT change this without also updating config.h:Config and default_config.txt also.
+    "cath_24F_imp_scale_factor_times_100",
+    "cath_16F_imp_scale_factor_times_100",
+
+    "syringe_motion_start_delta_time_ms",
+    "syringe_motion_start_threshold",
+    "syringe_motion_stop_delta_time_ms",
+    "syringe_motion_stop_threshold",
+    "syringe_vacuum_threshold",
+
+    "valve_strike_ms",
+    "valve_strike_pwm",
+    "valve_hold_pwm",
+
+    "cms_Ls",
+    "cms_Lr",
+    "cms_v1",
+    "cms_v2",
+    "cms_v3",
+    "cms_v4",
+    "cms_v5",
+    "cms_v6",
+    "cms_v7",
+    "cms_v8",
+    "cms_TB1",
+    "cms_TB3",
+    "cms_TB4",
+    "cms_TR",
+    "cms_Tlatch",
+    "cms_Tstack",
+    "cms_Tup",
+    "cms_BatLow",
+    "cms_Timeout",
+    "cms_J",
+    "cms_C",
+    "cms_M",
+    "cms_Trst",
+    "cms_Tblue",
+    "cms_Toff",
+    // "cms_piston_back_alert_ms",
+    "handle_impedance_filter_n",
+    // "handle_start_aspiration_n_samples_lookback",
+    // "handle_aspiration_n_samples",
+    "handle_range_2",
+    "handle_range_3",
+    "handle_range_4",
+    "handle_range_5",
+    "handle_A",
+    "handle_B",
+    "handle_D",
+    "handle_G",
+    "handle_H",
+    "handle_K",
+    "handle_L",
+    "handle_L2",
+    "handle_N",
+    "handle_P",
+    "handle_Pdrop",
+    "handle_Pfilter",
+    "handle_Q",
+    "handle_R",
+    "handle_X",
+    "handle_Tdrop",
+    "handle_W",
+    "handle_Lookback",
+    
+    "handle_disallow_wall_latch",
+
+    "cms_light_off_rgb",
+    "cms_light_connecting_rgb",
+    "cms_light_cms_error_rgb",
+    "cms_light_imp_state_1_short_circuit_rgb",
+    "cms_light_imp_state_2_saline_blood_wall_rgb",
+    "cms_light_imp_state_3_clot_rgb",
+    "cms_light_imp_state_4_air_rgb",
+    "cms_light_imp_state_5_open_circuit_rgb",
+    "cms_light_fluid_injection_rgb",
+    "cms_light_wall_latch_rgb",
+    "cms_light_handle_error_rgb",
+    "cms_light_clogged_rgb",
+    "cms_light_lid_removed_rgb",
+    "cms_light_out_of_co2_rgb",
+
+    "han_light_off_rgb",
+    "han_light_connecting_rgb",
+    "han_light_cms_error_rgb",
+    "han_light_imp_state_1_short_circuit_rgb",
+    "han_light_imp_state_2_saline_blood_wall_rgb",
+    "han_light_imp_state_3_clot_rgb",
+    "han_light_imp_state_4_air_rgb",
+    "han_light_imp_state_5_open_circuit_rgb",
+    "han_light_fluid_injection_rgb",
+    "han_light_wall_latch_rgb",
+    "han_light_handle_error_rgb",
+    "han_light_clogged_rgb",
+    "han_light_lid_removed_rgb",
+    "han_light_out_of_co2_rgb",
+
+    "test_rig_light_button_pressed",
+    "test_rig_light_low_pressure",
+    "test_rig_light_disconnected",
+
+    "calib_m_times_1000",
+    "calib_b_times_1000",
+
+    "Tcom",
+    "Tbeep",
+    "TaudioBlank",
+    "flash_half_period_in_ms",
+    "debug_mode",
+
+    "audio_clot_file_number",
+    "audio_warnback_file_number",
+    "audio_clot_volume_divisor",
+    "audio_warnback_volume_divisor",
+
+    "handle_test_rig",
+};
+```
+This is unsafe; chance of silent failure if edits out of sync with header.
+
+
+```
+// Inspired by https://stackoverflow.com/a/54975587
+char *_default_config_file_static_str = (
+#include "default_config.txt"
+);
+```
+Investigate, probably better solution.
+
+
+```
+BBStrNode *_strip_comments(BBStrNode *head) {
+    // Delete the lines that are comments
+    // Returns new head (which might or might not change).
+```
+Probably not necessary if we parse the right way
+
+
+```
+    int n_config_fields = sizeof(Config) / sizeof(int);
+    // This assert is to catch the case during development that
+    // a dev forgot to add a name to config_names after adding
+    // a field to Config (or vice-versa) and will never happen
+    // in release builds.
+```
+Confirm if true/if built into rest of code; can we trust this assumption.
+
+```
+Config *default_config() {
+    // used especially for testing
+    static Config default_config;
+    static bool default_config_cached = false;
+    Err err = 0;
+    if (! default_config_cached) {
+        BBStr *config_file_contents = bbstr_new(_default_config_file_static_str, BBSTR_COPY);
+        err = _parse_config_file(config_file_contents, &default_config, true);
+        if (err) {
+            halt("The default_config.txt did not parse correctly. This is fatal.\n");
+        }
+        bbstr_del(config_file_contents);
+        emit_log_comment_record("Default config loaded successfully\n");
+        default_config_cached = true;
+    }
+    return &default_config;
+}
+```
+If we overhaul the string-name based LUT for config then we can set default values to LUT that remove need for this approach.
+
+
+```
+// void dump_config(char *filename) {
+//     BBStr *config_file_contents = sd_card_read_file(filename);
+//     if (! config_file_contents) {
+//         printf("Unable to load config '%s'\n", filename);
+//         return;
+//     }
+//     printf("%s\n", config_file_contents->str);
+//     bbstr_del(config_file_contents);
+//     inquis_assert(bbstrnode_global_ref_count == 0);
+//     inquis_assert(bbstr_global_ref_count == 0);
+// }
+```
+Let's remove deprecated blocks of code if possible. They still live in repo history.
+
+
+```
+/**
+ * @brief Initializes the CRC-32 lookup table.
+ *
+ * Precomputes a 256-entry table using the standard polynomial (0xEDB88320)
+ * to speed up CRC-32 calculation at runtime.
+ */
+void crc32_init() {
+    uint32_t crc;
+    for (uint32_t i = 0; i < 256; i++) {
+        crc = i;
+        for (uint32_t j = 8; j > 0; j--) {
+            if (crc & 1) {
+                crc = (crc >> 1) ^ POLYNOMIAL;
+            }
+            else {
+                crc >>= 1;
+            }
+        }
+        _crc32_table[i] = crc;
+    }
+}
+
+/**
+ * @brief Computes CRC-32 checksum over a data buffer.
+ *
+ * Uses a precomputed lookup table for efficient CRC calculation.
+ *
+ * @param data Pointer to the data buffer to checksum.
+ * @param length Number of bytes to process.
+ * @param crc Initial CRC value (typically 0xFFFFFFFF).
+ * @return The final CRC-32 value after applying the standard final XOR.
+ */
+uint32_t crc32_calc(uint8_t *data, size_t length, uint32_t crc) {
+    while (length--) {
+        uint8_t byte = *data++;
+        crc = (crc >> 8) ^ _crc32_table[(crc ^ byte) & 0xFF];
+    }
+    return crc ^ FINAL_XOR_VALUE;
+}
+```
+STM32 may be able to accelerate this.
+
+
+## defines
+
+```
+/* @TODO NOT CLEAN */
+#define EMC 0
+#define TIP_SIZE 24
+```
+This should not be a file if it is 2 lines. Can be folded into something else that is already more permanent.
+
+## devices 
+
+```
+const int _switch_debounce_ms = 2;
+```
+Adequate? Stress testing on lid state suggests this needs to be looked at.
+
+```
+/**
+ * @brief Restarts the microcontroller unit (currently unused and commented out).
+ */
+void restart_mcu() {
+    // HAL_GPIO_WritePin(SHDN_REGS_GPIO_Port, SHDN_REGS_Pin, 1);
+    // sleep_ms(1);
+    // HAL_GPIO_WritePin(SHDN_REGS_GPIO_Port, SHDN_REGS_Pin, 0);
+    // // Lock-up awaiting restart
+    // while (1) {
+    // }
+}
+```
+Probably good to delete.
+
+```
+/**
+ * @brief Reads pressure from the Honeywell MPRLS sensor and converts to mmHg.
+ *
+ * Maintains a simple state machine to request and retrieve sensor data.
+ * @param print_debugging If true, prints raw sensor values and error codes.
+ * @return Last successfully read pressure value in mmHg.
+ */
+int read_pressure(bool print_debugging) {
+    // Return pressure in mmHg.
+
+    // Note that this function RETURNS THE LAST AVAILABLE pressure
+    // which isn't necessarily the current pressure
+    // since this call has to maintain a state machine to read the pressure.
+    // Asking the chip to begin a reading and then querying that
+    // value if the request has been completed.
+
+    // Reference:
+    // https://prod-edam.honeywell.com/content/dam/honeywell-edam/sps/siot/en-us/products/sensors/pressure-sensors/board-mount-pressure-sensors/micropressure-mpr-series/documents/sps-siot-mpr-series-datasheet-32332628-ciid-172626.pdf?download=false
+
+    // Read the pressure from the Honeywell MPRLS 30PSI sensor. I2C address 0x18. (Note I2C address are in top 7 bits)
+    // 32 bits read: status bytes followed by 24 bit pressure. 0 = LSB
+    //     7: always 0
+    //     6: power. 1 = device is powered, 0 = not powered
+    //     5: busy. 1 = device is busy, 0 = ready
+    //     4: always 0
+    //     3: always 0
+    //     2: memory check status: 0 = memory good, 1 = memory bad
+    //     1: always 0
+    //     0: math saturation: 1 = saturation error
+
+    // Pressure sampling is done in two steps: request, wait 5ms, read
+    // So here we check the time of the last request and only if it has been more
+    static int _pressure_last_val = 0;
+    static int _pressure_state = 0;
+    static TimeMS _pressure_request_time_ms = 0;
+
+    const float pressure_input_min = 0x19999A;
+    const float pressure_input_max = 0xE66666;
+    const float pressure_output_min = 0;
+    const float pressure_output_max = 30;
+
+    #if defined(SUBSYSTEM_HANDLE)
+        I2C_HandleTypeDef *hi2c = &hi2c2;
+    #elif defined(SUBSYSTEM_CMS)
+        I2C_HandleTypeDef *hi2c = &hi2c1;
+    #else
+        #error("No subsystem defined: must be either CMS or HANDLE")
+    #endif
+
+    Err err0, err1 = 0;
+    TimeMS now = get_time_ms();
+
+    int elapsed = now - _pressure_request_time_ms;
+    uint8_t read_data[4] = {
+        0,
+    };
+
+    if (_pressure_state == 0 && elapsed > 10) {
+        // Pressure request
+        uint8_t write_data[] = {0x00, 0x00};
+        err0 = HAL_I2C_Mem_Write(hi2c, 0x18 << 1, 0xAA, I2C_MEMADD_SIZE_8BIT, write_data, 2, HAL_MAX_DELAY);
+        if (err0 == 0) {
+            _pressure_request_time_ms = now;
+            _pressure_state = 1;
+        }
+        else {
+            // Try again later
+            _pressure_request_time_ms = now;
+        }
+    }
+    else if (_pressure_state == 1) {
+        // In experiments it needs less than 6 and it returns an err of zero when it is ready.
+        // So we're going to just poll it until we get a good read or we time out.
+        err1 = HAL_I2C_Mem_Read(hi2c, 0x18 << 1, 0, I2C_MEMADD_SIZE_8BIT, read_data, sizeof(read_data), HAL_MAX_DELAY);
+        if (err1 == 0) {
+            // Data is valid, save into _pressure_last_val
+            uint32_t press_counts = read_data[3] + read_data[2] * 256 + read_data[1] * 65536;
+            
+            // A presscount of zero is a special case of failure
+            float pressure_psi;
+            if(press_counts == 0) {
+                pressure_psi = 0;
+            }
+            else {
+                pressure_psi = (
+                    ((press_counts - pressure_input_min) * (pressure_output_max - pressure_output_min))
+                    / (pressure_input_max - pressure_input_min)
+                    + pressure_output_min
+                );
+            }
+            // Convert from PSI to mmHg
+            _pressure_last_val = (int)(51.71 * pressure_psi);
+            _pressure_request_time_ms = now;
+            _pressure_state = 0;
+        }
+        else {
+            // Try again on next call
+        }
+    }
+
+    if (print_debugging) {
+        printf(
+            "err0=%d errr1=%d  raw=%02X%02X%02X%02X\n",
+            err0,
+            err1,
+            read_data[0],
+            read_data[1],
+            read_data[2],
+            read_data[3]
+        );
+    }
+
+    return _pressure_last_val;
+}
+
+// For now switch is simple poll-debounce logic.
+// Later it might turn out that we need more complex interrupt-based logic if we're
+// polling slower than the debounce speed but that logic feels more complex and probably unnecessary.
+```
+Needs close look, mission critical.
+
+
+## emc
+
+```
+
+```
+
+
+
+##
+
+```
+
+```
+
+
+
+
 ---
 
 # Critical
diff --git a/common/comm.c b/common/comm.c
index a1dd7f99..4e499393 100644
--- a/common/comm.c
+++ b/common/comm.c
@@ -97,8 +97,7 @@ void _receive_idle_wait_for_dma() {
     //   20 was sufficeint 0% of the time
     //   30 was sufficient 50% of the time
     //   40 was sufficient 100% of the time
-    for (int i = 0; i < 40; i++) {
-    }
+    for (int i = 0; i < 40; i++) {}
 }
 
 // **************************************************************************************
@@ -130,7 +129,7 @@ void HAL_DMA_ErrorCallback(DMA_HandleTypeDef *hdma) {
         printf("  DMA_FLAG_TE6: Trasfer error\n");
     }
     if (__HAL_DMA_GET_FLAG(hdma, DMA_FLAG_GL6)) {
-        printf("  DMA_FLAG_GL6: Gloval interrupt\n");
+        printf("  DMA_FLAG_GL6: Global interrupt\n");
     }
 }
 
diff --git a/common/common.c b/common/common.c
index bdac05a8..e6cee22f 100644
--- a/common/common.c
+++ b/common/common.c
@@ -1,6 +1,6 @@
 //  @author  Zack Booth Simpson
 //  @date    20 Jun 2023
-//  @brief   Common symbols and function for all modules
+//  @brief   Common symbols and functions for all modules
 
 // **************************************************************************************
 // THEORY

34fddcc4ec7969770f95e22828bb6aae6b9c6d57
Author: Neekon Saadat <neekonsu@gmail.com>
Date: Thu Jul 24 16:17:41 2025
Subject: Minor edits to BBStr docstrings, finished in-depth code-review of BBStr API in isolation (no step-in or usage tracing). Documenting this second-pass in remarks.md, pending consolidation into a comprehensive slidedeck on codebase suggestions.

diff --git a/Documentation/REMARKS.md b/Documentation/REMARKS.md
index 94f725a7..68def20d 100644
--- a/Documentation/REMARKS.md
+++ b/Documentation/REMARKS.md
@@ -1,10 +1,280 @@
-GLOVES MUST COME OFF LEAVING RND LAB, HANDS MUST BE WASHED
+# GLOVES MUST COME OFF LEAVING RND LAB, HANDS MUST BE WASHED
 
+# Queue
 
-# TASKS
+# common/
 
-Create pipeline for scrubbing and bundling gen 3 data
-Design database format and 
+## bbstr
+```
+BBStr *bbstr_new(char *s, int len) {
+    // Create a new bbstr from an existing string or allocate empty.
+    // If len < 0 (BBSTR_COPY) then it will use strlen.
+    // Len should NOT include the nul.
+    // s can be NULL in which case the new buffer is allocated.
+    // and filled with zeros.
+
+    // TODO: Remove?
+    stack_check();
+```
+Peek into stack_check()
+
+```
+void bbstr_del(BBStr *bbstr) {
+    // Delete a bbstr, decremening the reference count.
+    // and deallocating if the reference is zero.
+
+    if (bbstr) {
+        bbstr->ref_count--;
+        if (bbstr->ref_count <= 0) {
+            *bbstr->str = 0; // For good measure
+            free(bbstr->str);
+            free(bbstr);
+            bbstr_global_ref_count--;
+        }
+    }
+}
+```
+Set a stanard for deallocated pointers, this doesn't make it safer; could corrupt program.
+
+```
+BBStr *bbstr_ref(BBStr *bbstr) {
+    // Increment the reference count on a bbstr.
+
+    bbstr->ref_count++;
+    return bbstr;
+}
+```
+purpose? 
+
+```
+char *bbstr_malloc_copy(BBStr *bstr) {
+    // Return a malloced copy of a bbstr.
+    // This is a converter that handles code
+    // ?expenting? a plain-old malloc-based string.
+
+    size_t len = strlen(bstr->str) + 1;
+    char *buf = (char *)malloc(len);
+    inquis_assert(buf != NULL);
+    strcpy(buf, bstr->str);
+    return buf;
+}
+```
+Trace usage using Doxygen reference tracker. This could be unsafe and/or redundant, pending review of usage.
+
+```
+/**
+ * @brief Trim whitespace from both ends of a BBStr.
+ *
+ * @param bbstr Input BBStr to trim.
+ * @return A new BBStr with whitespace removed from ends.
+ */
+BBStr *bbstr_trim(BBStr *bbstr) {
+    // Return a new bbstr that has whitspace trimmed on both ends.
+
+    char *lft = bbstr->str;
+    while (*lft == ' ' || *lft == '\t' || *lft == '\r' || *lft == '\n') {
+        lft++;
+    }
+
+    char *rgt = bbstr->str + strlen(bbstr->str) - 1;
+    while (rgt > lft && (*rgt == ' ' || *rgt == '\t' || *rgt == '\r' || *rgt == '\n')) {
+        rgt--;
+    }
+
+    int len = rgt - lft + 1;
+    return bbstr_new(lft, len);
+}
+```
+While loop conditions possibly limited in scope. Could protect against buffer overflow/corruption when trimming extremties by excluding alphanumericals instead of case-based statement. Requires revision or removal of method.
+Method name, suggest change to bbstr_trim_ends or bbstr_trim_whitespace
+
+```
+BBStr *bbstr_left(BBStr *bbstr, unsigned int n) {
+    char *lft = bbstr->str;
+    int len = 0;
+    for (len = 0; len < n && lft[len] != 0; len++)
+        ;
+    return bbstr_new(lft, len);
+}
+```
+Unsafe, BO risk. Trace references in Doxygen to determine risk as implemented/called. Highly recommend implementing field in BBStr to store size and/or terminate with a more unique character for safety.
+
+```
+/**
+ * @brief Create a new empty BBStrNode list.
+ *
+ * @return Pointer to a new BBStrNode with no string attached.
+ */
+BBStrNode *bbstr_list_new() {
+    // Create a new (empy) list of strings.
+
+    BBStrNode *new_bbstr_node = (BBStrNode *)malloc(sizeof(BBStrNode));
+    inquis_assert(new_bbstr_node != NULL);
+    new_bbstr_node->next = NULL;
+    new_bbstr_node->bbstr = NULL;
+    bbstrnode_global_ref_count++;
+    return new_bbstr_node;
+}
+```
+Why do we need this to be a method? Check usage with doxygen, redundant, suggest removal.
+
+```
+BBStr *bbstr_join(BBStrNode *head, char delimiter) {
+    // Join a list of strings together as a new bbstr with delimiter.
+
+    // FIND total length
+    int len = 0;
+    int count = 0;
+    for (BBStrNode *curr = head; curr; curr = curr->next) {
+        if (curr->bbstr) {
+            len += strlen(curr->bbstr->str);
+            count++;
+        }
+    }
+
+    len += (count - 1); // Include interstitial delimiters
+    BBStr *new = bbstr_new(NULL, len);
+
+    // COPY into the final
+    char *dst = new->str;
+    int i = 0;
+    for (BBStrNode *curr = head; curr; curr = curr->next) {
+        if (curr->bbstr) {
+            int len = strlen(curr->bbstr->str);
+            memcpy(dst, curr->bbstr->str, len);
+            dst += len;
+            if (i < count - 1) {
+                *dst++ = delimiter;
+            }
+            i++;
+        }
+    }
+    *dst++ = 0;
+
+    return new;
+}
+```
+Verify safety of "interstitial delimiters"
+
+**Remarks on BBStrNode API:** Not necessary, pending usage review via Doxygen. All functionality should be implemented generically via a list API *if even*. BBStr should be designed to be safe in all data structures; we shouldn't need a dedicated API for BBStr lists if they are safe in any OOP datastructure usage. Review then discuss with team. Also review 'reference counting' functionality as it is used across codebase: why was this feature implemented, and is there an alternative with improved inherent safety.
+
+```
+/*
+Bare-Bones Str (BBStr) Funcs
+----------------------------
+
+This is a bare-bones set of common string functions with reference counting
+
+Example usage:
+
+    // Make a copy of a static string
+    BBStr *s = bbstr_new("foo", BBSTR_COPY);
+    printf("%s\n", s->str);
+    // ... and delete it.
+    bbstr_del(s);
+
+    // Make list of strings from statics
+    char *strs[] = { "123", "456", "789" };
+    BBStrNode *head = bbstr_list_new();
+    BBStrNode *curr = head;
+    for(int i=0; i<3; i++) {
+        BBStr *s = bbstr_new(strs[i], BBSTR_COPY);
+        curr = bbstr_list_add(curr, s, 1);
+        bbstr_del(s);  // Delete here decrements ref count so the node's memory is still available to the list
+    }
+
+    // Traverse the list
+    for(BBStrNode *curr=head; curr; curr=curr->next) {
+        printf("%s\n", curr->bbstr->str);
+    }
+
+    // Get a specific element of the list
+    char *elem = bbstr_list_get(head, 0, "");
+    assert(0 == strcmp(elem, "123"));
+
+    // Get an element and return default if it doesn't exist
+    char *elem = bbstr_list_get(head, 1000, "foo");
+    assert(0 == strcmp(elem, "foo"));
+
+    // Delete a list. If it is the owner of the the elements
+    // they will also be freed. Otherwise their refernce
+    // count will decrement by one.
+    bbstr_list_del(head);
+
+    // Delete one element of a list given the previous node
+    // (assumes you are traversing).
+    BBStrNode *prev = NULL;
+    for(BBStrNode *curr=head; curr; ) {
+        BBStrNode *next = curr->next;
+        if(should_delete(curr)) {
+            bbstr_list_del_node(curr, prev);
+        }
+        else {
+            prev = curr;
+        }
+        curr = next;
+    }
+
+    // Make a standalone malloc copy
+    char *my_private_copy_of_s = bbstr_malloc_copy(s);
+    // Now it can be freed.
+    free(my_private_copy_of_s);
+
+    // Split a string...
+    BBStr *line = bbstr_new("123, 456, 789", BBSTR_COPY);
+    BBStrNode *list = bbstr_split(line, ',', BBSTR_TRIM);
+    // ... delete the line now that we don't need it...
+    bbstr_del(line);
+    // ... and print the elements.
+    for(BBStrNode *curr = list; curr; curr = curr->next) {
+        printf("%s\n", curr->bbstr->str);
+    }
+
+    // Remember to always new and delete.
+    // For example, this iS BAD, do NOT do the following!!!
+    //   BBStrNode *list = bbstr_split(bbstr_new("123; 456; 789", BBSTR_COPY), ';', BBSTR_TRIM);
+    //   bbstr_list_del(list);
+    // ... The above code will strand the string that was allocated in the first arg of bbstr_split
+
+    // You can also walk the list as an index although this is inefficeint
+    // because it will traverse the list from the head on every call.
+    int count = bbstr_list_count(list);
+    for(int i=0; i < count; i++) {
+        char *s = bbstr_list_get(list, i, NULL);
+        printf("list[%d] = %s\n", i, s);
+    }
+
+    // ...don't forget to delete lists.
+    bbstr_list_del(list);
+
+    // Finally, check that everything was deleted. These should both be zeros
+    printf("%d %d\n", bbstr_global_ref_count, bbstrnode_global_ref_count);
+
+    return 0;
+*/
+```
+While BBStr may need a close look, we can improve the usage guide in the meantime. Delete lists/strings functionality not unlike malloc/calloc/free. Let's specify static memory in engineering document and pass through DCO; code needs to reflect spec, not the other way around (spec reflects code).
+This can start with an Excel spreadsheet.
+Static memory will force us to optimize some buffer usage across codebase that could be improved.
+
+```
+// **************************************************************************************
+// TYPEDEFS
+// **************************************************************************************
+
+typedef struct _BBStr {
+    char *str;
+    int ref_count;
+} BBStr;
+
+typedef struct _BBStrNode {
+    BBStr *bbstr;
+    struct _BBStrNode *next;
+} BBStrNode;
+```
+All that in bbstr.c just for ref_count? Let's review.
+
+---
 
 # Critical
 
diff --git a/common/bbstr.c b/common/bbstr.c
index 5b891d65..3b7741a5 100644
--- a/common/bbstr.c
+++ b/common/bbstr.c
@@ -146,8 +146,8 @@ BBStr *bbstr_ref(BBStr *bbstr) {
  */
 char *bbstr_malloc_copy(BBStr *bstr) {
     // Return a malloced copy of a bbstr.
-    // This is a converter that hands code
-    // expenting a plain-old malloc-based string.
+    // This is a converter that handles code
+    // ?expenting? a plain-old malloc-based string.
 
     size_t len = strlen(bstr->str) + 1;
     char *buf = (char *)malloc(len);

843ce7f7bd587d5cfcc690589b0e482ef2b51179
Author: Neekon Saadat <neekonsu@gmail.com>
Date: Thu Jul 24 15:35:52 2025
Subject: Cleaned out stragglers in project root

diff --git a/.gitignore b/.gitignore
index a5b5ee9c..98f6a2e8 100644
--- a/.gitignore
+++ b/.gitignore
@@ -70,10 +70,10 @@ gen*.hex
 **/.DS_Store
 # release/**/*
 
-#cms/.settings
-#cms/.project
-#handle/.settings
-#handle/.project
+cms/.settings
+cms/.project
+handle/.settings
+handle/.project
 
 release/**/*
 
@@ -82,3 +82,5 @@ common/version.h.bak
 _logs/
 inquis__3_0*/
 inquis__3_0*/**/*
+CLAUDE.md
+.vscode
\ No newline at end of file
diff --git a/update.sh b/update.sh
old mode 100755
new mode 100644

dba8d88d175a44c0b8d7d9c0b49dd62fc00e47bd
Author: Neekon Saadat <neekonsu@gmail.com>
Date: Thu Jul 17 13:44:49 2025
Subject: Finished revisions on Dev Tasks Report and Robustness Testing STrategy

diff --git a/Gen_3_0_Robustness_Testing_Strategy.md b/Gen_3_0_Robustness_Testing_Strategy.md
index d1f68007..645c5eb1 100644
--- a/Gen_3_0_Robustness_Testing_Strategy.md
+++ b/Gen_3_0_Robustness_Testing_Strategy.md
@@ -1,102 +1,1105 @@
-Embedded System Robustness Testing Report
+# Embedded System Robustness Testing Report
 
-Repository: inquis_gen_3_0
-Analysis Date: July 17, 2025
-Prepared by: GPT-4 Embedded Systems Analysis
+**Repository:** inquis_gen_3_0  
+**Analysis Date:** July 17, 2025  
+**Prepared by:** GPT-4 Embedded Systems Analysis  
 
-⸻
+---
 
-Executive Summary
+## Executive Summary
 
 This report details a concise and targeted series of high-yield robustness tests designed explicitly to induce errors, crashes, or unexpected behaviors in the Inquis Gen 3.0 dual-MCU embedded medical device. Based on extensive analysis of the architecture, memory safety, and outstanding development tasks, the following test recommendations prioritize critical vulnerabilities, particularly memory corruption, state synchronization issues, and communication resilience.
 
-⸻
+---
 
-Targeted Robustness Testing
+## Targeted Robustness Testing
 
-Piston Control State Machine Tests
+### Piston Control State Machine Tests
 
-Priority	Test Scenario	Targeted Failure Conditions	States Impacted
-CRITICAL	Abrupt Lid Removal	Lid detection interrupts during piston motion	ACTIVE_MOTION_BACKWARD, ACTIVE_MOTION_FORWARDS
-HIGH	Rapid CO2 Depletion Simulation	State transitions triggered by piston position	OUT_OF_CO2, CONFIRMING_STOP
-HIGH	Vacuum Timeout & Button Press	Vacuum stack timeout boundary conditions	VACUUM_HOLDING_AT_BACK, AWAITING_ASPIRATION
-HIGH	Forced Invalid Position	Invalid sensor inputs to exceed position thresholds	CONFIRMING_STOP, SYSTEM_ERROR
+| Priority | Test Scenario | Targeted Failure Conditions | States Impacted |
+|----------|---------------|------------------------------|------------------|
+| **CRITICAL** | Abrupt Lid Removal | Lid detection interrupts during piston motion | `ACTIVE_MOTION_BACKWARD`, `ACTIVE_MOTION_FORWARDS` |
+| **HIGH** | Rapid CO2 Depletion Simulation | State transitions triggered by piston position | `OUT_OF_CO2`, `CONFIRMING_STOP` |
+| **HIGH** | Vacuum Timeout & Button Press | Vacuum stack timeout boundary conditions | `VACUUM_HOLDING_AT_BACK`, `AWAITING_ASPIRATION` |
+| **HIGH** | Forced Invalid Position | Invalid sensor inputs to exceed position thresholds | `CONFIRMING_STOP`, `SYSTEM_ERROR` |
 
-Expected Impact: Expose synchronization faults and error recovery robustness in critical operational scenarios.
+**Expected Impact:** Expose synchronization faults and error recovery robustness in critical operational scenarios.
 
-⸻
+---
 
-LED & Light State Machine Tests
+### LED & Light State Machine Tests
 
-Priority	Test Scenario	Targeted Failure Conditions	States Impacted
-HIGH	Rapid Handle Connect/Disconnect	Communication synchronization during LED connection	START_HANDLE_CONNECT - AWAIT_HANDLE_CONFIG
-HIGH	Repeated Clot & Clog Cycles	Rapid impedance changes causing state oscillation	CLOT, CLOGGED, MIRROR_HANDLE
-MEDIUM	Flashing Pattern Stress Test	LED state flashing logic race conditions	CONNECTING, CLOGGED, CLOT
+| Priority | Test Scenario | Targeted Failure Conditions | States Impacted |
+|----------|---------------|------------------------------|------------------|
+| **HIGH** | Rapid Handle Connect/Disconnect | Communication synchronization during LED connection | `START_HANDLE_CONNECT` - `AWAIT_HANDLE_CONFIG` |
+| **HIGH** | Repeated Clot & Clog Cycles | Rapid impedance changes causing state oscillation | `CLOT`, `CLOGGED`, `MIRROR_HANDLE` |
+| **MEDIUM** | Flashing Pattern Stress Test | LED state flashing logic race conditions | `CONNECTING`, `CLOGGED`, `CLOT` |
 
-Expected Impact: Identify race conditions and synchronization vulnerabilities between LED indicators and underlying state logic.
+**Expected Impact:** Identify race conditions and synchronization vulnerabilities between LED indicators and underlying state logic.
 
-⸻
+---
 
-Audio State Machine Tests
+### Audio State Machine Tests
 
-Priority	Test Scenario	Targeted Failure Conditions	States Impacted
-HIGH	Continuous Clot Sound Triggers	Audio playback buffer overflow or corruption	CLOT_SOUND_START, CLOT_SOUND
-MEDIUM	Bleed Path Sound Timeout Test	Oscillation at sound trigger threshold conditions	BLEED_PATH_SOUND_START, BLEED_PATH_SOUND
+| Priority | Test Scenario | Targeted Failure Conditions | States Impacted |
+|----------|---------------|------------------------------|------------------|
+| **HIGH** | Continuous Clot Sound Triggers | Audio playback buffer overflow or corruption | `CLOT_SOUND_START`, `CLOT_SOUND` |
+| **MEDIUM** | Bleed Path Sound Timeout Test | Oscillation at sound trigger threshold conditions | `BLEED_PATH_SOUND_START`, `BLEED_PATH_SOUND` |
 
-Expected Impact: Stress-test audio buffer management and state-driven sound playback logic under frequent state transitions.
+**Expected Impact:** Stress-test audio buffer management and state-driven sound playback logic under frequent state transitions.
 
-⸻
+---
 
-Handle Impedance & Pressure Sampling Tests
+### Handle Impedance & Pressure Sampling Tests
 
-Priority	Test Scenario	Targeted Failure Conditions	States Impacted
-CRITICAL	Impedance Array Overflow	memmove operations causing impedance buffer overflow	MONITOR_THRESHOLDS, ASPIRATION_EVAL_ANALYSIS
-HIGH	Wall Latch Condition Oscillation	Continuous threshold boundary impedance/pressure	WALL_LATCH, WALL_LATCH_DELAY
-HIGH	Pressure Drop Stress Test	Rapid oscillating pressure changes	START_ASPIRATION, ASPIRATION_EVAL_DATA_COLLECTION
+| Priority | Test Scenario | Targeted Failure Conditions | States Impacted |
+|----------|---------------|------------------------------|------------------|
+| **CRITICAL** | Impedance Array Overflow | `memmove` operations causing impedance buffer overflow | `MONITOR_THRESHOLDS`, `ASPIRATION_EVAL_ANALYSIS` |
+| **HIGH** | Wall Latch Condition Oscillation | Continuous threshold boundary impedance/pressure | `WALL_LATCH`, `WALL_LATCH_DELAY` |
+| **HIGH** | Pressure Drop Stress Test | Rapid oscillating pressure changes | `START_ASPIRATION`, `ASPIRATION_EVAL_DATA_COLLECTION` |
 
-Expected Impact: Highlight array boundary vulnerabilities and robustness of impedance-pressure analysis logic.
+**Expected Impact:** Highlight array boundary vulnerabilities and robustness of impedance-pressure analysis logic.
 
-⸻
+---
 
-Inter-MCU Communication & FIFO Buffer Tests
+### Inter-MCU Communication & FIFO Buffer Tests
 
-Priority	Test Scenario	Targeted Failure Conditions	Systems Impacted
-CRITICAL	FIFO Overflow Exploit	Packet generation exceeding defined packet size	FIFO communication, CMS, Handle
-HIGH	Communication Timeout Injection	Randomized communication drops	UART communication, CMS, Handle
-HIGH	UART Communication Overload	Induced UART overruns with excessive traffic	UART communication, CMS, Handle
+| Priority | Test Scenario | Targeted Failure Conditions | Systems Impacted |
+|----------|---------------|------------------------------|-------------------|
+| **CRITICAL** | FIFO Overflow Exploit | Packet generation exceeding defined packet size | FIFO communication, CMS, Handle |
+| **HIGH** | Communication Timeout Injection | Randomized communication drops | UART communication, CMS, Handle |
+| **HIGH** | UART Communication Overload | Induced UART overruns with excessive traffic | UART communication, CMS, Handle |
 
-Expected Impact: Validate error handling and recovery mechanisms for critical inter-MCU communications.
+**Expected Impact:** Validate error handling and recovery mechanisms for critical inter-MCU communications.
 
-⸻
+---
 
-Memory Safety & Resource Management Tests
+### Memory Safety & Resource Management Tests
 
-Priority	Test Scenario	Targeted Failure Conditions	Modules Impacted
-MEDIUM	Configuration Load Memory Exhaustion	Malformed/excessive configuration file sizes	Configuration loader, bbstr
-MEDIUM	Continuous Reconfiguration Cycles	Frequent configuration changes uncovering leaks	bbstr, memory management utilities
-MEDIUM	Long-Term Sample Counting Overflow	Integer overflow due to continuous sampling	Sampling system, han_sample
+| Priority | Test Scenario | Targeted Failure Conditions | Modules Impacted |
+|----------|---------------|------------------------------|-------------------|
+| **MEDIUM** | Configuration Load Memory Exhaustion | Malformed/excessive configuration file sizes | Configuration loader, bbstr |
+| **MEDIUM** | Continuous Reconfiguration Cycles | Frequent configuration changes uncovering leaks | bbstr, memory management utilities |
+| **MEDIUM** | Long-Term Sample Counting Overflow | Integer overflow due to continuous sampling | Sampling system, han_sample |
 
-Expected Impact: Assess the device’s stability and error management in scenarios of resource exhaustion and integer overflow.
+**Expected Impact:** Assess the device's stability and error management in scenarios of resource exhaustion and integer overflow.
 
-⸻
+---
 
-Architectural Robustness & Abstraction Layer Tests
+### Architectural Robustness & Abstraction Layer Tests
 
-Priority	Test Scenario	Targeted Failure Conditions	Modules Impacted
-HIGH	Direct Peripheral Manipulation	Abstraction violation through direct state variable access	lights.c, abstraction barriers
-MEDIUM	Subsystem Build Flag Misuse	Improperly defined subsystem compilation flags	Build system, comm.c
+| Priority | Test Scenario | Targeted Failure Conditions | Modules Impacted |
+|----------|---------------|------------------------------|-------------------|
+| **HIGH** | Direct Peripheral Manipulation | Abstraction violation through direct state variable access | `lights.c`, abstraction barriers |
+| **MEDIUM** | Subsystem Build Flag Misuse | Improperly defined subsystem compilation flags | Build system, `comm.c` |
 
-Expected Impact: Identify and resolve architectural vulnerabilities that could lead to systemic stability and maintainability issues.
+**Expected Impact:** Identify and resolve architectural vulnerabilities that could lead to systemic stability and maintainability issues.
 
-⸻
+---
 
-Recommendations for Implementation
-	•	Implement Critical Tests Immediately: Prioritize tests related to FIFO buffer overflow, impedance array overflow, and abrupt lid removal due to their severe risk to device stability and patient safety.
-	•	Automate Tests Where Feasible: Develop automated test harnesses to systematically apply the outlined stress tests, ensuring consistent coverage and reproducibility.
-	•	Monitor and Document Failure Modes: Clearly document any observed failures, including state transitions, memory conditions, and recovery actions, to facilitate targeted remediation efforts.
+### Recommendations for Implementation
 
-⸻
+- **Implement Critical Tests Immediately:** Prioritize tests related to FIFO buffer overflow, impedance array overflow, and abrupt lid removal due to their severe risk to device stability and patient safety.
+- **Automate Tests Where Feasible:** Develop automated test harnesses to systematically apply the outlined stress tests, ensuring consistent coverage and reproducibility.
+- **Monitor and Document Failure Modes:** Clearly document any observed failures, including state transitions, memory conditions, and recovery actions, to facilitate targeted remediation efforts.
 
-Conclusion
+---
 
-The targeted robustness testing strategy provided herein offers a structured, high-yield approach to rigorously evaluating the embedded device’s resilience to real-world misuse scenarios. Successful execution and mitigation based on these recommendations will significantly enhance the reliability, safety, and production readiness of the Inquis Gen 3.0 medical device system.
\ No newline at end of file
+## Interrupt Vulnerability Testing Tasks
+
+### Critical System Stress Testing Requirements
+
+Based on the comprehensive interrupt analysis, the following testing procedures are essential to demonstrate and fix race conditions, buffer overflows, and synchronization vulnerabilities that could interfere with medical device functionality during critical procedures.
+
+#### **High-Priority Interrupt Vulnerability Tests**
+
+##### `common/comm.c` - FIFO Buffer Race Condition Testing
+**Issue Type:** Critical Race Condition  
+**Status:** Requires immediate stress testing  
+**Location:** `fifo.c:112-133, comm.c:292-372`
+
+| Test Scenario | Implementation | Expected Failure Mode | Priority |
+|---------------|----------------|----------------------|----------|
+| Rapid UART Interrupt Storm | Generate continuous UART idle interrupts during FIFO operations | FIFO pointer corruption, packet loss | CRITICAL |
+| Concurrent FIFO Access | Trigger interrupts during main loop FIFO read operations | Memory corruption, invalid packet reads | CRITICAL |
+| DMA Boundary Overflow | Send malformed frames with excessive `n_packets` values | Buffer overflow in interrupt context | CRITICAL |
+
+**Test Implementation:**
+```c
+// Test rapid interrupt generation during FIFO operations
+void test_fifo_race_condition() {
+    for (int i = 0; i < 10000; i++) {
+        // Main loop FIFO access
+        fifo_read_get_ptr(&recv_fifo);
+        
+        // Trigger UART interrupt during FIFO operation
+        HAL_UARTEx_RxEventCallback(&huart2, sizeof(test_frame));
+        
+        // Verify FIFO integrity
+        assert(fifo_is_valid(&recv_fifo));
+    }
+}
+
+// Test DMA buffer overflow with malformed packets
+void test_dma_buffer_overflow() {
+    Frame malformed_frame;
+    malformed_frame.n_packets = 0xFFFF; // Excessive packet count
+    malformed_frame.crc = calculate_crc(&malformed_frame);
+    
+    // Send malformed frame to trigger overflow
+    memcpy(_recv_buffer, &malformed_frame, sizeof(malformed_frame));
+    HAL_UARTEx_RxEventCallback(&huart2, sizeof(malformed_frame));
+    
+    // Check for memory corruption
+    check_stack_canary();
+}
+```
+
+##### `handle/inquis/han_state.c` - Handle State Machine Race Condition
+**Issue Type:** Critical State Corruption  
+**Status:** Requires immediate testing  
+**Location:** `han_state.c:89-99, han_state.c:422-463`
+
+| Test Scenario | Implementation | Expected Failure Mode | Priority |
+|---------------|----------------|----------------------|----------|
+| State Transition Interrupt | Trigger comm_reply_callback during state transitions | Inconsistent state transmission to CMS | CRITICAL |
+| Multi-word State Corruption | Interrupt during clot detection state updates | False clot detection or missed clots | CRITICAL |
+| Button Press Race | Trigger communication interrupt during button handling | Missed aspirate button presses | HIGH |
+
+**Test Implementation:**
+```c
+// Test state variable corruption during interrupt
+void test_handle_state_race() {
+    // Start state machine transition
+    han_state_transition(HAN_STATE_ASPIRATION_EVAL_DATA_COLLECTION);
+    
+    // Trigger comm_reply_callback interrupt during transition
+    comm_reply_callback();
+    
+    // Verify state consistency
+    assert(_comm_reply_curr_state == han_state_get_current());
+    assert(_comm_reply_imp_state_val == han_imp_state_get_current());
+}
+
+// Test clot detection state corruption
+void test_clot_detection_race() {
+    // Simulate clot detection in progress
+    han_state_set_clot_detected(true);
+    
+    // Trigger interrupt during clot state update
+    comm_reply_callback();
+    
+    // Verify clot state transmitted correctly
+    assert(_comm_reply_last_aspiration_with_new_clot_seen_ms > 0);
+}
+```
+
+##### Interrupt Priority Inversion Testing
+**Issue Type:** Critical Timing Violation  
+**Status:** Requires priority testing  
+**Location:** `stm32l4xx_hal_msp.c:276-278`
+
+| Test Scenario | Implementation | Expected Failure Mode | Priority |
+|---------------|----------------|----------------------|----------|
+| Communication Interrupt Blocking | Generate continuous UART interrupts | Timer interrupts blocked, timing violations | HIGH |
+| State Machine Timing Violations | Block critical interrupts during state transitions | Missed state transition deadlines | HIGH |
+| Button Response Degradation | High interrupt load during button polling | Missed button presses, poor responsiveness | MEDIUM |
+
+**Test Implementation:**
+```c
+// Test interrupt priority inversion
+void test_interrupt_priority_inversion() {
+    uint32_t start_time = HAL_GetTick();
+    
+    // Generate continuous UART interrupts
+    while (HAL_GetTick() - start_time < 1000) {
+        trigger_uart_interrupt();
+        
+        // Check if timer interrupts are being blocked
+        if (timer_interrupt_count < expected_timer_count) {
+            // Priority inversion detected
+            assert(false);
+        }
+    }
+}
+```
+
+#### **Medium-Priority Interrupt Vulnerability Tests**
+
+##### Communication Protocol Timing Tests
+**Issue Type:** Timing Vulnerability  
+**Status:** Requires stress testing  
+**Location:** `comm.c:358-360, comm.c:275-280`
+
+| Test Scenario | Implementation | Expected Failure Mode | Priority |
+|---------------|----------------|----------------------|----------|
+| Reply Timeout Under Load | Generate high interrupt load during reply timing | Communication timeouts, Handle isolation | MEDIUM |
+| Timer Interrupt Jitter | Measure timer interrupt consistency under load | Variable reply timing, protocol violations | MEDIUM |
+
+#### **System Integration Stress Tests**
+
+##### Full System Interrupt Storm Testing
+**Test Purpose:** Verify system stability under maximum interrupt load
+**Implementation:**
+```c
+void test_full_system_interrupt_storm() {
+    // Enable all interrupt sources simultaneously
+    enable_uart_interrupts();
+    enable_timer_interrupts();
+    enable_dma_interrupts();
+    enable_gpio_interrupts();
+    
+    // Generate maximum interrupt load
+    for (int duration = 0; duration < 60000; duration++) { // 60 seconds
+        trigger_all_interrupts();
+        
+        // Monitor for system failures
+        check_communication_integrity();
+        check_state_machine_consistency();
+        check_memory_corruption();
+        check_timing_violations();
+        
+        delay_ms(1);
+    }
+}
+```
+
+##### Medical Procedure Simulation Under Stress
+**Test Purpose:** Verify device reliability during critical medical procedures
+**Implementation:**
+```c
+void test_medical_procedure_under_stress() {
+    // Simulate aspiration procedure
+    start_aspiration_procedure();
+    
+    // Generate interrupt stress during critical phases
+    while (aspiration_in_progress()) {
+        // Phase 1: Clot detection
+        if (in_clot_detection_phase()) {
+            stress_test_impedance_interrupts();
+        }
+        
+        // Phase 2: Wall latch detection
+        if (in_wall_latch_phase()) {
+            stress_test_pressure_interrupts();
+        }
+        
+        // Phase 3: Aspiration control
+        if (in_aspiration_control_phase()) {
+            stress_test_piston_interrupts();
+        }
+        
+        // Verify medical procedure continues correctly
+        assert(procedure_still_valid());
+    }
+}
+```
+
+---
+
+## Advanced Vulnerability Testing Procedures
+
+### Configuration and Input Validation Vulnerabilities
+
+| Priority | Test Scenario | Targeted Failure Conditions | Implementation Method |
+|----------|---------------|------------------------------|------------------------|
+| **CRITICAL** | Malformed Configuration File Attack | Integer overflow, memory exhaustion during config parsing | Load config files with extreme values, negative numbers, oversized strings |
+| **HIGH** | Configuration Structure Type Confusion | Memory corruption via type assumptions in `config.c:326` | Modify config with non-integer fields, test structure boundary violations |
+| **HIGH** | Default Config Boundary Testing | Array bounds violations in config loading | Test configs with values exceeding defined ranges (pressure thresholds, timing values) |
+| **MEDIUM** | SD Card Configuration Corruption | Filesystem corruption during config write/read cycles | Interrupt power during config saves, test with corrupted FAT32 structures |
+
+**Test Implementation:**
+```c
+// Test extreme configuration values
+void test_config_boundary_violations() {
+    // Test integer overflow scenarios
+    config.cms_Ls = INT_MAX;
+    config.handle_K = -1;
+    config.vacuum_threshold = 0xFFFFFFFF;
+    
+    // Test string fields with excessive lengths
+    strcpy(config.device_name, "A_VERY_LONG_STRING_THAT_EXCEEDS_BUFFER_SIZE_...");
+    
+    // Verify system behavior with invalid configs
+    test_system_startup_with_invalid_config();
+}
+
+// Test configuration memory exhaustion
+void test_config_memory_exhaustion() {
+    // Create config file with 10,000+ lines
+    generate_massive_config_file();
+    
+    // Monitor memory usage during parsing
+    monitor_heap_usage_during_config_load();
+    
+    // Verify graceful degradation vs system crash
+}
+```
+
+### State Machine Transition Boundary Testing
+
+| Priority | Test Scenario | Targeted Failure Conditions | FSM States Targeted |
+|----------|---------------|------------------------------|----------------------|
+| **CRITICAL** | Invalid State Injection | Array bounds access in state name lookups | All CMS and Handle states |
+| **CRITICAL** | State Transition Race Conditions | Inconsistent state updates during interrupts | Handle states 3002, 5002-5003 |
+| **HIGH** | State Machine Deadlock Testing | Circular state dependencies, stuck states | Piston vacuum states 71-72 |
+| **HIGH** | State Overflow Attack | State enumeration values beyond array bounds | LED states, audio states |
+| **MEDIUM** | State Timing Boundary Violations | Missed state transitions due to timing edge cases | All timed state transitions |
+
+**Test Implementation:**
+```c
+// Test state enumeration boundary violations
+void test_state_boundary_attacks() {
+    // Force invalid state values into state machines
+    cms_state.curr_piston_state = 999;  // Beyond valid range
+    cms_state.curr_led_state = -1;      // Negative state
+    
+    // Trigger state name lookup to cause array bounds violation
+    log_state_transition();  // Should crash or corrupt memory
+}
+
+// Test state machine deadlock scenarios
+void test_state_machine_deadlocks() {
+    // Force piston into vacuum hold state
+    force_piston_state(PISTON_STATE_72_VACUUM_HOLDING_AT_BACK);
+    
+    // Block pressure sensors to prevent state exit conditions
+    block_pressure_readings();
+    
+    // Verify system doesn't hang permanently
+    monitor_state_transitions_for_timeout(30000); // 30 seconds
+}
+
+// Test concurrent state transitions under interrupt load
+void test_state_transition_races() {
+    // Start state machine transition
+    begin_handle_state_transition(HAN_STATE_ASPIRATION_EVAL_ANALYSIS);
+    
+    // Generate communication interrupt during transition
+    trigger_comm_reply_callback_interrupt();
+    
+    // Verify state consistency across interrupt boundary
+    assert_state_consistency();
+}
+```
+
+### Memory Corruption and Buffer Overflow Testing
+
+Priority	Test Scenario	Targeted Failure Conditions	Vulnerable Code Locations
+CRITICAL	FIFO Buffer Overflow Exploitation	Memory corruption via packet size manipulation	fifo.c:76, comm.c:305-343
+CRITICAL	Impedance Array Overflow	Buffer overflow in memmove operations	han_state.c:653-661
+HIGH	String Buffer Overflows	BBStr malloc exhaustion, string copying overflows	bbstr.c:77-88
+HIGH	Audio Buffer Stack Overflow	Stack corruption via large audio buffers	cms_devices.c:63-64
+MEDIUM	Configuration Parsing Overflows	Buffer overruns during config file processing	config.c parsing functions
+
+**Test Implementation:**
+```c
+// Test FIFO buffer overflow exploitation
+void test_fifo_overflow_attacks() {
+    // Create malformed packet with excessive n_packets value
+    Frame attack_frame;
+    attack_frame.n_packets = 0xFFFF;  // Exceeds buffer capacity
+    attack_frame.crc = calculate_crc(&attack_frame);
+    
+    // Send via UART to trigger overflow in comm.c
+    send_uart_frame(&attack_frame);
+    
+    // Check for memory corruption
+    verify_stack_canary_integrity();
+    verify_heap_integrity();
+}
+
+// Test impedance buffer boundary violations
+void test_impedance_buffer_attacks() {
+    // Force IMPEDANCE_MAX_N to be exceeded
+    for (int i = 0; i < IMPEDANCE_MAX_N + 100; i++) {
+        // Force sample processing to overflow buffer
+        process_impedance_sample(mock_sample);
+    }
+    
+    // Verify buffer integrity
+    check_buffer_canaries();
+}
+
+// Test malloc exhaustion scenarios
+void test_memory_exhaustion() {
+    // Repeatedly trigger bbstr allocations
+    for (int i = 0; i < 10000; i++) {
+        BBStr *str = bbstr_new("test_string", -1);
+        // Don't free to simulate leak
+    }
+    
+    // Verify graceful degradation vs system halt
+    test_system_functionality_under_memory_pressure();
+}
+```
+
+### Communication Protocol Stress Testing
+
+Priority	Test Scenario	Targeted Failure Conditions	Communication Paths
+CRITICAL	UART Error Recovery Exploitation	Permanent communication failure	CMS-Handle UART channel
+CRITICAL	Communication Timeout Cascade	System isolation during critical procedures	All inter-MCU communication
+HIGH	DMA Buffer Boundary Attacks	Memory corruption via DMA overflow	DMA communication channels
+HIGH	Packet Fragmentation Stress	Protocol confusion, packet loss	All packet-based communication
+MEDIUM	Communication Timing Attacks	Protocol violations via timing manipulation	Reply timing, timeout handling
+
+**Test Implementation:**
+```c
+// Test communication protocol failure cascades
+void test_communication_failure_cascades() {
+    // Start critical aspiration procedure
+    initiate_aspiration_procedure();
+    
+    // Generate continuous UART errors during procedure
+    while (aspiration_in_progress()) {
+        trigger_uart_overrun_error();
+        trigger_uart_framing_error();
+        delay_ms(50);
+    }
+    
+    // Verify system maintains safety during communication failure
+    assert_safe_system_state();
+}
+
+// Test DMA buffer manipulation attacks
+void test_dma_buffer_attacks() {
+    // Manipulate DMA buffer contents during transfer
+    setup_dma_transfer();
+    
+    // Corrupt buffer during DMA operation
+    corrupt_dma_buffer_during_transfer();
+    
+    // Verify error detection and recovery
+    verify_dma_error_handling();
+}
+
+// Test communication timing boundary conditions
+void test_communication_timing_attacks() {
+    // Send packets at exact timeout boundaries
+    send_packet_at_timeout_minus_1ms();
+    send_packet_at_timeout_plus_1ms();
+    
+    // Verify timeout handling robustness
+    verify_timeout_recovery_behavior();
+}
+```
+
+### Real-World Misuse Scenario Testing
+
+Priority	Test Scenario	Targeted Failure Conditions	User Misuse Patterns
+CRITICAL	Rapid Button Mashing During Procedures	Button debouncing failures, state confusion	Aspiration button during clot detection
+HIGH	Power Cycling During Critical States	Incomplete state persistence, corruption	Power loss during aspiration
+HIGH	Catheter Manipulation During Operation	Sensor confusion, impedance range violations	Physical sensor manipulation
+MEDIUM	Environmental Stress Conditions	Temperature/humidity impact on timing	Extended operation in extreme conditions
+MEDIUM	Simultaneous Multiple Operations	Resource contention, timing violations	Multiple rapid procedure attempts
+
+**Test Implementation:**
+```c
+// Test rapid user input scenarios
+void test_rapid_button_attacks() {
+    // Generate button presses faster than debouncing logic
+    for (int i = 0; i < 1000; i++) {
+        trigger_aspirate_button_press();
+        delay_microseconds(100);  // Faster than expected human input
+        trigger_aspirate_button_release();
+        delay_microseconds(100);
+    }
+    
+    // Verify button state consistency
+    verify_button_state_machine_integrity();
+}
+
+// Test power cycling stress scenarios
+void test_power_cycling_stress() {
+    // Cycle power during each critical state
+    for (each_critical_state) {
+        enter_critical_state();
+        power_cycle_device();
+        verify_recovery_behavior();
+        check_state_persistence();
+    }
+}
+
+// Test sensor manipulation scenarios
+void test_sensor_manipulation_attacks() {
+    // Rapidly change impedance values outside normal ranges
+    simulate_impedance_values(0);           // Short circuit
+    simulate_impedance_values(1000000);     // Open circuit
+    simulate_impedance_values(-1);          // Invalid negative
+    
+    // Test pressure sensor manipulation
+    simulate_pressure_values(-100);         // Invalid negative pressure
+    simulate_pressure_values(10000);        // Excessive pressure
+    
+    // Verify sensor range validation
+    verify_sensor_input_validation();
+}
+```
+
+### Timing and Synchronization Stress Testing
+
+Priority	Test Scenario	Targeted Failure Conditions	Timing Dependencies
+CRITICAL	Interrupt Priority Inversion	Critical timing violations	UART vs Timer interrupts
+CRITICAL	Watchdog Timer Bypass	System hang detection failure	All long-running operations
+HIGH	State Machine Timing Violations	Missed deadlines, stuck states	All timed state transitions
+HIGH	Communication Timeout Edge Cases	Premature/delayed timeout handling	Tcom=1000ms boundaries
+MEDIUM	Real-Time Constraint Violations	Missed impedance sampling, audio glitches	Real-time sampling loops
+
+**Test Implementation:**
+```c
+// Test interrupt priority inversion scenarios
+void test_interrupt_priority_attacks() {
+    // Generate continuous low-priority interrupts
+    while (test_duration < 60000) {  // 60 seconds
+        trigger_continuous_uart_interrupts();
+        
+        // Monitor for blocked timer interrupts
+        if (timer_interrupt_missed()) {
+            log_priority_inversion_detected();
+        }
+    }
+}
+
+// Test watchdog bypass scenarios
+void test_watchdog_bypass_attacks() {
+    // Create scenarios that could hang the system
+    enter_infinite_loop_in_state_machine();
+    block_all_interrupts_permanently();
+    create_memory_allocation_deadlock();
+    
+    // Verify watchdog triggers system reset
+    verify_watchdog_reset_within_timeout();
+}
+
+// Test timing constraint boundary conditions
+void test_timing_constraint_violations() {
+    // Test each timing parameter at boundary conditions
+    test_timing_parameter(Tcom, 999);   // Just under timeout
+    test_timing_parameter(Tcom, 1001);  // Just over timeout
+    test_timing_parameter(TB1, 0);      // Minimum value
+    test_timing_parameter(TB1, 10000);  // Excessive value
+    
+    // Verify system behavior at timing boundaries
+    verify_timing_behavior_correctness();
+}
+```
+
+### Integration Stress Testing Scenarios
+
+Priority	Test Scenario	Targeted Failure Conditions	System Integration Points
+CRITICAL	Full System State Explosion	Exponential state combinations	All state machines simultaneously
+HIGH	Resource Exhaustion Under Load	Memory, CPU, I/O resource depletion	All system resources
+HIGH	Error Propagation Cascades	Single failures causing system-wide failures	Cross-module error handling
+MEDIUM	Performance Degradation Testing	System slowdown under stress	All performance-critical paths
+MEDIUM	Concurrent Operation Stress	Multiple simultaneous operations	All parallel subsystems
+
+**Test Implementation:**
+```c
+// Test exponential state combination explosion
+void test_state_explosion_scenarios() {
+    // Force all state machines into complex state combinations
+    force_piston_state(PISTON_STATE_72_VACUUM_HOLDING_AT_BACK);
+    force_led_state(LED_STATE_502_CLOT);
+    force_audio_state(AUDIO_STATE_30002_CLOT_SOUND);
+    force_handle_state(HAN_STATE_6001_WALL_LATCH);
+    
+    // Generate state transitions in all machines simultaneously
+    trigger_all_state_machines_simultaneously();
+    
+    // Monitor for unexpected state combinations
+    verify_state_combination_validity();
+}
+
+// Test system resource exhaustion
+void test_resource_exhaustion_scenarios() {
+    // Exhaust memory resources
+    allocate_all_available_memory();
+    
+    // Exhaust CPU resources
+    create_cpu_intensive_interrupt_storm();
+    
+    // Exhaust I/O resources
+    flood_all_communication_channels();
+    
+    // Verify graceful degradation
+    verify_system_maintains_core_functionality();
+}
+
+// Test cascading failure scenarios
+void test_cascading_failure_scenarios() {
+    // Introduce single point failures
+    simulate_sd_card_failure();
+    simulate_pressure_sensor_failure();
+    simulate_impedance_sensor_failure();
+    
+    // Monitor for cascade effects
+    monitor_cross_system_error_propagation();
+    
+    // Verify isolation of failures
+    verify_failure_containment();
+}
+```
+
+### Long-Duration Stress Testing
+
+Priority	Test Scenario	Targeted Failure Conditions	Duration Requirements
+CRITICAL	24+ Hour Continuous Operation	Memory leaks, integer overflows, cumulative errors	24-72 hours minimum
+HIGH	Thermal Stress Extended Operation	Temperature-induced timing drift, component failure	12+ hours at temperature extremes
+HIGH	Power Supply Stress Testing	Brown-out conditions, voltage fluctuations	Extended operation with power stress
+MEDIUM	Repeated Procedure Cycling	Wear-out failures, cumulative state corruption	10,000+ procedure cycles
+MEDIUM	Data Logging Stress Testing	SD card wear, filesystem corruption	Continuous logging for days
+
+**Test Implementation:**
+```c
+// Test extended operation scenarios
+void test_extended_operation_stress() {
+    uint32_t test_start_time = get_time_ms();
+    uint32_t procedure_count = 0;
+    
+    while ((get_time_ms() - test_start_time) < (24 * 60 * 60 * 1000)) {  // 24 hours
+        // Perform complete aspiration procedure
+        perform_complete_aspiration_cycle();
+        procedure_count++;
+        
+        // Monitor for degradation indicators
+        check_memory_usage();
+        check_timing_drift();
+        check_communication_integrity();
+        check_state_machine_consistency();
+        
+        // Log any anomalies
+        if (anomaly_detected()) {
+            log_anomaly_with_timestamp_and_count(procedure_count);
+        }
+    }
+    
+    // Generate comprehensive stress test report
+    generate_extended_operation_report();
+}
+
+// Test thermal stress scenarios
+void test_thermal_stress_scenarios() {
+    // Test at temperature extremes
+    set_environmental_temperature(70);  // High temperature
+    run_stress_test_suite();
+    
+    set_environmental_temperature(-10); // Low temperature  
+    run_stress_test_suite();
+    
+    // Test thermal cycling
+    for (int cycle = 0; cycle < 100; cycle++) {
+        thermal_cycle_device();
+        verify_system_functionality();
+    }
+}
+```
+
+---
+
+## Unexpected Input and Error Condition Testing
+
+### SD Card and File System Corruption Testing
+
+| Priority | Test Scenario | Targeted Failure Conditions | System Impact |
+|----------|---------------|------------------------------|---------------|
+| **CRITICAL** | SD Card Removal During Logging | Incomplete log writes, file system corruption | CMS logging system, data integrity |
+| **CRITICAL** | Corrupted FAT32 File System | File system mount failures, data loss | SD card initialization, log recovery |
+| **HIGH** | SD Card Write Protection Active | Failed log operations, error handling | Log system error recovery |
+| **HIGH** | Insufficient SD Card Space | Write failures during critical operations | Graceful degradation testing |
+| **MEDIUM** | SD Card Physical Corruption | Bad sector handling, data recovery | File system resilience |
+| **MEDIUM** | Power Loss During SD Write | Incomplete file operations, journal recovery | Data consistency validation |
+
+**Test Implementation:**
+```c
+// Test SD card removal during active logging
+void test_sd_card_removal_during_logging() {
+    // Start continuous logging operation
+    start_continuous_logging();
+    
+    // Simulate SD card removal mid-write
+    simulate_sd_card_removal();
+    
+    // Verify system behavior
+    verify_log_error_handling();
+    verify_no_system_crash();
+    
+    // Test recovery when card reinserted
+    simulate_sd_card_insertion();
+    verify_logging_recovery();
+}
+
+// Test corrupted file system handling
+void test_corrupted_filesystem() {
+    // Create corrupted FAT32 structure
+    corrupt_fat32_boot_sector();
+    corrupt_fat32_allocation_table();
+    
+    // Attempt system startup
+    result = initialize_sd_card_system();
+    
+    // Verify graceful failure handling
+    assert(result == SD_INIT_FAILED);
+    verify_system_continues_without_logging();
+}
+
+// Test insufficient storage scenarios
+void test_sd_storage_exhaustion() {
+    // Fill SD card to near capacity
+    fill_sd_card_to_threshold();
+    
+    // Generate continuous log data
+    while (log_space_available()) {
+        generate_log_entry();
+    }
+    
+    // Verify behavior when storage exhausted
+    verify_storage_exhaustion_handling();
+    verify_log_rotation_or_cleanup();
+}
+```
+
+### Corrupted Configuration File Testing
+
+| Priority | Test Scenario | Targeted Failure Conditions | Configuration Parameters |
+|----------|---------------|------------------------------|---------------------------|
+| **CRITICAL** | Malformed `default_config.txt` | Config parsing failures, invalid parameters | All system thresholds and timing |
+| **CRITICAL** | Config File Truncation | Incomplete parameter loading | Critical pressure/impedance thresholds |
+| **HIGH** | Invalid Parameter Ranges | Out-of-bounds values causing system instability | K, L, Ls pressure thresholds |
+| **HIGH** | Config File with Binary Data | Text parsing corruption, buffer overflows | Config file integrity |
+| **MEDIUM** | Missing Configuration File | Default value fallback testing | System startup with defaults |
+| **MEDIUM** | Config File Permission Errors | Read access failures during startup | Error recovery mechanisms |
+
+**Test Implementation:**
+```c
+// Test malformed configuration file handling
+void test_malformed_config_file() {
+    // Create config with invalid syntax
+    create_config_file_with_syntax_errors();
+    
+    // Test invalid parameter formats
+    add_config_line("cms_Ls = INVALID_NUMBER");
+    add_config_line("handle_K = 999999999999999999999"); // Overflow
+    add_config_line("Tcom = -500"); // Invalid negative timing
+    
+    // Attempt system initialization
+    result = load_system_configuration();
+    
+    // Verify error handling
+    verify_config_load_error_handling();
+    verify_fallback_to_defaults();
+}
+
+// Test configuration boundary violations
+void test_config_boundary_violations() {
+    // Test extreme pressure threshold values
+    set_config_value("cms_Ls", "0");           // Minimum pressure
+    set_config_value("handle_K", "100000");    // Excessive pressure
+    set_config_value("handle_L", "-100");      // Invalid negative
+    
+    // Test timing parameter violations
+    set_config_value("Tcom", "0");             // Zero timeout
+    set_config_value("TB1", "999999");         // Excessive timing
+    set_config_value("Trst", "-1");            // Invalid reset time
+    
+    // Verify parameter validation
+    verify_config_parameter_validation();
+    verify_safe_fallback_values();
+}
+
+// Test configuration file corruption scenarios
+void test_config_file_corruption() {
+    // Inject random binary data into config file
+    inject_binary_data_into_config();
+    
+    // Truncate config file mid-parameter
+    truncate_config_file_randomly();
+    
+    // Add extremely long lines
+    add_config_line_with_excessive_length();
+    
+    // Verify parsing robustness
+    verify_config_parsing_robustness();
+}
+```
+
+### Corrupted Audio File Testing
+
+Priority	Test Scenario	Targeted Failure Conditions	Audio System Impact
+HIGH	Corrupted Audio Header Files	WAV file parsing errors, audio playback failures	Audio state machine failures
+HIGH	Missing Audio Files	File not found during audio state transitions	Audio system error recovery
+MEDIUM	Invalid Audio Format	Unsupported audio format handling	Audio initialization errors
+MEDIUM	Truncated Audio Data	Incomplete audio playback, buffer underruns	Audio state timing issues
+MEDIUM	Audio File Size Mismatches	Memory allocation errors, buffer overflows	Audio buffer management
+
+**Test Implementation:**
+```c
+// Test corrupted audio file handling
+void test_corrupted_audio_files() {
+    // Corrupt WAV header information
+    corrupt_wav_file_header("audio0.wav");
+    corrupt_wav_file_sample_rate("audio0.wav");
+    
+    // Test audio system initialization
+    result = initialize_audio_system();
+    
+    // Verify error handling
+    verify_audio_init_error_handling();
+    verify_audio_state_machine_stability();
+}
+
+// Test missing audio file scenarios
+void test_missing_audio_files() {
+    // Remove critical audio files
+    delete_file("audio0.wav");
+    delete_file("clot_detection_sound.wav");
+    
+    // Attempt audio playback
+    trigger_clot_detection_audio();
+    
+    // Verify graceful degradation
+    verify_silent_operation_mode();
+    verify_no_audio_state_machine_crash();
+}
+
+// Test audio buffer overflow scenarios
+void test_audio_buffer_corruption() {
+    // Create audio file larger than expected buffer
+    create_oversized_audio_file();
+    
+    // Trigger audio playback
+    result = play_audio_file();
+    
+    // Monitor for buffer overflow
+    verify_audio_buffer_bounds_checking();
+    verify_stack_integrity();
+}
+```
+
+### Hardware Component Failure Simulation
+
+Priority	Test Scenario	Targeted Failure Conditions	Hardware Components
+CRITICAL	Pressure Sensor Disconnection	Invalid pressure readings, sensor error detection	Pressure monitoring system
+CRITICAL	Impedance Sensor Malfunction	AD5940 communication failures, invalid impedance	Handle impedance detection
+HIGH	LED Driver I2C Failures	LED control errors, communication timeouts	Visual feedback system
+HIGH	UART Communication Hardware Failure	Inter-MCU communication loss	CMS-Handle coordination
+MEDIUM	Power Supply Voltage Fluctuations	Brown-out conditions, system instability	Power management
+MEDIUM	Button Hardware Debouncing Failures	False button presses, missed inputs	User interface
+
+**Test Implementation:**
+```c
+// Test pressure sensor failure scenarios
+void test_pressure_sensor_failures() {
+    // Simulate sensor disconnection
+    simulate_pressure_sensor_disconnect();
+    
+    // Test invalid pressure readings
+    inject_invalid_pressure_values(0xFFFF);    // Sensor error value
+    inject_invalid_pressure_values(-1);        // Impossible negative pressure
+    
+    // Verify error detection and handling
+    verify_pressure_sensor_error_detection();
+    verify_safe_system_behavior_without_pressure();
+}
+
+// Test impedance sensor malfunction
+void test_impedance_sensor_failures() {
+    // Simulate AD5940 communication failure
+    simulate_ad5940_i2c_failure();
+    
+    // Test impedance reading corruption
+    inject_corrupted_impedance_readings();
+    
+    // Simulate sensor calibration errors
+    corrupt_impedance_calibration_data();
+    
+    // Verify error handling
+    verify_impedance_error_recovery();
+    verify_clot_detection_fallback_behavior();
+}
+
+// Test LED driver I2C communication failures
+void test_led_driver_failures() {
+    // Simulate I2C bus errors
+    simulate_i2c_bus_hang();
+    simulate_i2c_ack_failures();
+    
+    // Test LED driver timeout scenarios
+    block_led_driver_responses();
+    
+    // Verify LED system error handling
+    verify_led_timeout_recovery();
+    verify_visual_feedback_fallback();
+}
+```
+
+### Unexpected System State Testing
+
+Priority	Test Scenario	Targeted Failure Conditions	System State Impact
+CRITICAL	Boot Sequence Interruption	Incomplete initialization, partially initialized state	System startup integrity
+CRITICAL	Unexpected Reset During Operation	State persistence, recovery from unknown state	State machine consistency
+HIGH	Clock/Timer Subsystem Failure	Timing-dependent operations, state transition timing	All timed operations
+HIGH	Memory Allocation Failures	malloc() failures during operation	Dynamic memory handling
+MEDIUM	Interrupt Controller Malfunction	Missed interrupts, interrupt priority corruption	Real-time system behavior
+MEDIUM	Watchdog Timer Premature Trigger	Unexpected system resets, operation interruption	System stability
+
+**Test Implementation:**
+```c
+// Test boot sequence interruption scenarios
+void test_boot_sequence_interruption() {
+    // Interrupt boot at various stages
+    interrupt_boot_during_peripheral_init();
+    interrupt_boot_during_config_loading();
+    interrupt_boot_during_state_machine_init();
+    
+    // Test recovery behavior
+    verify_boot_recovery_mechanisms();
+    verify_safe_default_state();
+}
+
+// Test unexpected reset scenarios
+void test_unexpected_reset_recovery() {
+    // Force reset during critical operations
+    force_reset_during_aspiration();
+    force_reset_during_clot_detection();
+    force_reset_during_communication();
+    
+    // Verify state recovery
+    verify_state_machine_recovery();
+    verify_operation_resumption();
+}
+
+// Test memory allocation failure scenarios
+void test_memory_allocation_failures() {
+    // Force malloc() failures
+    simulate_heap_exhaustion();
+    
+    // Test critical allocation points
+    test_bbstr_allocation_failures();
+    test_fifo_allocation_failures();
+    
+    // Verify graceful degradation
+    verify_allocation_failure_handling();
+    verify_system_continues_operation();
+}
+```
+
+### Input Validation Edge Case Testing
+
+Priority	Test Scenario	Targeted Failure Conditions	Input Validation Points
+HIGH	Extreme Sensor Value Injection	Out-of-range sensor readings, overflow conditions	All sensor input processing
+HIGH	Invalid State Machine Inputs	State transition triggers with invalid parameters	State machine validation
+MEDIUM	Communication Protocol Violations	Malformed packets, invalid packet sequences	Packet validation logic
+MEDIUM	User Input Boundary Testing	Button press timing violations, invalid sequences	User interface validation
+MEDIUM	Configuration Parameter Injection	Invalid runtime parameter changes	Runtime config validation
+
+**Test Implementation:**
+```c
+// Test extreme sensor value handling
+void test_extreme_sensor_values() {
+    // Test pressure sensor extremes
+    inject_pressure_value(INT_MIN);
+    inject_pressure_value(INT_MAX);
+    inject_pressure_value(0xFFFFFFFF);
+    
+    // Test impedance sensor extremes
+    inject_impedance_value(-1);
+    inject_impedance_value(0);
+    inject_impedance_value(UINT32_MAX);
+    
+    // Verify input validation
+    verify_sensor_input_validation();
+    verify_range_checking();
+}
+
+// Test invalid state machine inputs
+void test_invalid_state_inputs() {
+    // Inject invalid state values
+    force_state_value(-1);
+    force_state_value(999999);
+    force_state_value(0xDEADBEEF);
+    
+    // Test invalid state transitions
+    attempt_invalid_state_transitions();
+    
+    // Verify state validation
+    verify_state_bounds_checking();
+    verify_transition_validation();
+}
+
+// Test communication protocol violations
+void test_protocol_violations() {
+    // Send malformed packets
+    send_packet_with_invalid_crc();
+    send_packet_with_wrong_size();
+    send_packet_sequence_out_of_order();
+    
+    // Test protocol state violations
+    send_unexpected_packet_types();
+    
+    // Verify protocol error handling
+    verify_packet_validation();
+    verify_protocol_error_recovery();
+}
+```
+
+---
+
+## Testing Implementation Strategy
+
+### Phase 1: Critical Vulnerability Testing (Week 1)
+1. **FIFO Buffer Overflow Tests** - Highest risk to communication system
+2. **State Machine Boundary Tests** - Array bounds violations in state transitions
+3. **Interrupt Race Condition Tests** - Critical for Handle state machine integrity
+4. **Memory Corruption Tests** - Buffer overflows in impedance processing
+
+### Phase 2: Integration Stress Testing (Week 2)
+1. **Communication Protocol Stress** - Full protocol failure scenarios
+2. **State Machine Combination Testing** - Complex multi-state scenarios
+3. **Resource Exhaustion Testing** - Memory, CPU, I/O limits
+4. **Real-World Misuse Scenarios** - User error simulation
+
+### Phase 3: Extended Duration Testing (Weeks 3-4)
+1. **24+ Hour Continuous Operation** - Long-term stability verification
+2. **Thermal Stress Testing** - Environmental extreme conditions
+3. **Procedure Cycle Stress** - 10,000+ aspiration cycles
+4. **Data Logging Stress** - Extended SD card operation
+
+### Phase 4: Failure Analysis and Remediation (Week 5)
+1. **Root Cause Analysis** - Detailed failure investigation
+2. **Code Review for Identified Issues** - Targeted vulnerability fixes
+3. **Regression Testing** - Verify fixes don't introduce new issues
+4. **Documentation Update** - Update robustness test procedures
+
+### Test Environment Requirements
+
+#### Hardware Setup:
+- Multiple Gen 3.0 units for parallel testing
+- Environmental chambers for thermal stress
+- Oscilloscopes for timing analysis
+- Logic analyzers for communication debugging
+- Adjustable power supplies for power stress
+- Test fixtures for physical manipulation
+
+#### Software Tools:
+- Memory corruption detection tools
+- Stack canary monitoring
+- Heap integrity checking
+- Communication protocol analyzers
+- Real-time performance monitors
+- Automated test harnesses
+
+#### Safety Considerations:
+- All testing performed on non-clinical units
+- Comprehensive logging of all test procedures
+- Immediate documentation of any safety-critical failures
+- Escalation procedures for critical vulnerability discovery
+
+---
+
+## Conclusion
+
+This comprehensive robustness testing strategy targets specific vulnerabilities identified through detailed codebase analysis, combining architectural knowledge with real-world failure scenarios. The testing procedures are designed to systematically explore the boundaries of system behavior, identify failure modes that may not be obvious during normal operation, and ensure the device maintains safety and reliability under all conceivable stress conditions.
+
+The enhanced testing strategy addresses vulnerabilities across **memory management**, **state machine logic**, **communication protocols**, **timing constraints**, and **integration points**. By implementing these tests systematically, the engineering team can identify and remediate potential failure modes before deployment, significantly improving the overall robustness and safety of the Inquis Gen 3.0 medical device system.
+
+Special attention has been given to scenarios that require deep understanding of the codebase interactions - **race conditions between interrupts and state machines**, **buffer overflow vulnerabilities in communication paths**, and **timing-dependent failure modes** that could manifest only under specific operational stress conditions. This approach ensures comprehensive vulnerability coverage that goes beyond surface-level testing to explore the complex interactions that could lead to system failures in critical medical environments.
\ No newline at end of file
diff --git a/Outstanding_Development_Tasks_Report.md b/Outstanding_Development_Tasks_Report.md
index d9ca8e1d..b4ec9845 100644
--- a/Outstanding_Development_Tasks_Report.md
+++ b/Outstanding_Development_Tasks_Report.md
@@ -19,197 +19,6 @@ This report catalogs outstanding development tasks, unfinished code sections, an
 
 ---
 
-## Interrupt Vulnerability Testing Tasks
-
-### Critical System Stress Testing Requirements
-
-Based on the comprehensive interrupt analysis, the following testing procedures are essential to demonstrate and fix race conditions, buffer overflows, and synchronization vulnerabilities that could interfere with medical device functionality during critical procedures.
-
-#### **High-Priority Interrupt Vulnerability Tests**
-
-##### `common/comm.c` - FIFO Buffer Race Condition Testing
-**Issue Type:** Critical Race Condition  
-**Status:** Requires immediate stress testing  
-**Location:** `fifo.c:112-133, comm.c:292-372`
-
-| Test Scenario | Implementation | Expected Failure Mode | Priority |
-|---------------|----------------|----------------------|----------|
-| Rapid UART Interrupt Storm | Generate continuous UART idle interrupts during FIFO operations | FIFO pointer corruption, packet loss | CRITICAL |
-| Concurrent FIFO Access | Trigger interrupts during main loop FIFO read operations | Memory corruption, invalid packet reads | CRITICAL |
-| DMA Boundary Overflow | Send malformed frames with excessive `n_packets` values | Buffer overflow in interrupt context | CRITICAL |
-
-**Test Implementation:**
-```c
-// Test rapid interrupt generation during FIFO operations
-void test_fifo_race_condition() {
-    for (int i = 0; i < 10000; i++) {
-        // Main loop FIFO access
-        fifo_read_get_ptr(&recv_fifo);
-        
-        // Trigger UART interrupt during FIFO operation
-        HAL_UARTEx_RxEventCallback(&huart2, sizeof(test_frame));
-        
-        // Verify FIFO integrity
-        assert(fifo_is_valid(&recv_fifo));
-    }
-}
-
-// Test DMA buffer overflow with malformed packets
-void test_dma_buffer_overflow() {
-    Frame malformed_frame;
-    malformed_frame.n_packets = 0xFFFF; // Excessive packet count
-    malformed_frame.crc = calculate_crc(&malformed_frame);
-    
-    // Send malformed frame to trigger overflow
-    memcpy(_recv_buffer, &malformed_frame, sizeof(malformed_frame));
-    HAL_UARTEx_RxEventCallback(&huart2, sizeof(malformed_frame));
-    
-    // Check for memory corruption
-    check_stack_canary();
-}
-```
-
-##### `handle/inquis/han_state.c` - Handle State Machine Race Condition
-**Issue Type:** Critical State Corruption  
-**Status:** Requires immediate testing  
-**Location:** `han_state.c:89-99, han_state.c:422-463`
-
-| Test Scenario | Implementation | Expected Failure Mode | Priority |
-|---------------|----------------|----------------------|----------|
-| State Transition Interrupt | Trigger comm_reply_callback during state transitions | Inconsistent state transmission to CMS | CRITICAL |
-| Multi-word State Corruption | Interrupt during clot detection state updates | False clot detection or missed clots | CRITICAL |
-| Button Press Race | Trigger communication interrupt during button handling | Missed aspirate button presses | HIGH |
-
-**Test Implementation:**
-```c
-// Test state variable corruption during interrupt
-void test_handle_state_race() {
-    // Start state machine transition
-    han_state_transition(HAN_STATE_ASPIRATION_EVAL_DATA_COLLECTION);
-    
-    // Trigger comm_reply_callback interrupt during transition
-    comm_reply_callback();
-    
-    // Verify state consistency
-    assert(_comm_reply_curr_state == han_state_get_current());
-    assert(_comm_reply_imp_state_val == han_imp_state_get_current());
-}
-
-// Test clot detection state corruption
-void test_clot_detection_race() {
-    // Simulate clot detection in progress
-    han_state_set_clot_detected(true);
-    
-    // Trigger interrupt during clot state update
-    comm_reply_callback();
-    
-    // Verify clot state transmitted correctly
-    assert(_comm_reply_last_aspiration_with_new_clot_seen_ms > 0);
-}
-```
-
-##### Interrupt Priority Inversion Testing
-**Issue Type:** Critical Timing Violation  
-**Status:** Requires priority testing  
-**Location:** `stm32l4xx_hal_msp.c:276-278`
-
-| Test Scenario | Implementation | Expected Failure Mode | Priority |
-|---------------|----------------|----------------------|----------|
-| Communication Interrupt Blocking | Generate continuous UART interrupts | Timer interrupts blocked, timing violations | HIGH |
-| State Machine Timing Violations | Block critical interrupts during state transitions | Missed state transition deadlines | HIGH |
-| Button Response Degradation | High interrupt load during button polling | Missed button presses, poor responsiveness | MEDIUM |
-
-**Test Implementation:**
-```c
-// Test interrupt priority inversion
-void test_interrupt_priority_inversion() {
-    uint32_t start_time = HAL_GetTick();
-    
-    // Generate continuous UART interrupts
-    while (HAL_GetTick() - start_time < 1000) {
-        trigger_uart_interrupt();
-        
-        // Check if timer interrupts are being blocked
-        if (timer_interrupt_count < expected_timer_count) {
-            // Priority inversion detected
-            assert(false);
-        }
-    }
-}
-```
-
-#### **Medium-Priority Interrupt Vulnerability Tests**
-
-##### Communication Protocol Timing Tests
-**Issue Type:** Timing Vulnerability  
-**Status:** Requires stress testing  
-**Location:** `comm.c:358-360, comm.c:275-280`
-
-| Test Scenario | Implementation | Expected Failure Mode | Priority |
-|---------------|----------------|----------------------|----------|
-| Reply Timeout Under Load | Generate high interrupt load during reply timing | Communication timeouts, Handle isolation | MEDIUM |
-| Timer Interrupt Jitter | Measure timer interrupt consistency under load | Variable reply timing, protocol violations | MEDIUM |
-
-#### **System Integration Stress Tests**
-
-##### Full System Interrupt Storm Testing
-**Test Purpose:** Verify system stability under maximum interrupt load
-**Implementation:**
-```c
-void test_full_system_interrupt_storm() {
-    // Enable all interrupt sources simultaneously
-    enable_uart_interrupts();
-    enable_timer_interrupts();
-    enable_dma_interrupts();
-    enable_gpio_interrupts();
-    
-    // Generate maximum interrupt load
-    for (int duration = 0; duration < 60000; duration++) { // 60 seconds
-        trigger_all_interrupts();
-        
-        // Monitor for system failures
-        check_communication_integrity();
-        check_state_machine_consistency();
-        check_memory_corruption();
-        check_timing_violations();
-        
-        delay_ms(1);
-    }
-}
-```
-
-##### Medical Procedure Simulation Under Stress
-**Test Purpose:** Verify device reliability during critical medical procedures
-**Implementation:**
-```c
-void test_medical_procedure_under_stress() {
-    // Simulate aspiration procedure
-    start_aspiration_procedure();
-    
-    // Generate interrupt stress during critical phases
-    while (aspiration_in_progress()) {
-        // Phase 1: Clot detection
-        if (in_clot_detection_phase()) {
-            stress_test_impedance_interrupts();
-        }
-        
-        // Phase 2: Wall latch detection
-        if (in_wall_latch_phase()) {
-            stress_test_pressure_interrupts();
-        }
-        
-        // Phase 3: Aspiration control
-        if (in_aspiration_control_phase()) {
-            stress_test_piston_interrupts();
-        }
-        
-        // Verify medical procedure continues correctly
-        assert(procedure_still_valid());
-    }
-}
-```
-
----
 
 ## Common Directory (`common/`)
 

d70e9558268cd7197a0688a48aa189628594f5dc
Author: Neekon Saadat <neekonsu@gmail.com>
Date: Wed Jul 16 09:53:07 2025
Subject: Removed favicon

diff --git a/Doxyfile b/Doxyfile
index 1689e5b3..f8aca1f9 100644
--- a/Doxyfile
+++ b/Doxyfile
@@ -61,13 +61,13 @@ PROJECT_BRIEF          = "DOCUMENTATION OF INQUIS GEN 3 SOURCECODE"
 # pixels and the maximum width should not exceed 200 pixels. Doxygen will copy
 # the logo to the output directory.
 
-PROJECT_LOGO           = ./Inquis_3_0_GUI/favicon.ico
+PROJECT_LOGO           = 
 
 # With the PROJECT_ICON tag one can specify an icon that is included in the tabs
 # when the HTML document is shown. Doxygen will copy the logo to the output
 # directory.
 
-PROJECT_ICON           = ./Inquis_3_0_GUI/favicon.ico
+PROJECT_ICON           = 
 
 # The OUTPUT_DIRECTORY tag is used to specify the (relative or absolute) path
 # into which the generated documentation will be written. If a relative path is
diff --git a/REMARKS.md b/REMARKS.md
index 4cf30ad9..94f725a7 100644
--- a/REMARKS.md
+++ b/REMARKS.md
@@ -393,4 +393,36 @@ typedef struct {
 // TEMP REMOVED until the state machines are sorted out between handle and cms
 
 // @TODO NOT CLEAN 
-```
\ No newline at end of file
+```
+
+
+
+
+# Code Tasks Meetig 26/7/2025
+
+- POST doesn't really check anything, just if function returns
+- - We call something called post
+- - We don't check for all zeros on pressure readings in POST, performed somewhere else
+- CLI side, implement raw dump all sensors instead of ?pretty print?
+- 
+
+we need to pund on gen 3 , use the shit out of it, and verify that it behaves the way we intended the design
+
+Do everything we can to crash it
+
+Document tests
+
+what's been missing recently is 'someone poundin on the system'
+
+Use flow diagrams to break it
+
+Check for memory leaks
+
+Currently notebooks used and synced out of sharepoint, needs to be concsolidated to git
+
+V4 V5 Vxx logs have different state names associated with them; we need to have a solid method to load in any logs and decode them using the appropriate state names for the version
+
+- Let's put notebooks on colab so people can make a copy of the base to plot their data
+
+- Help steve with monarch board testing system ready/arduino code
+

4496058a8529155b4c723e6cb527c7157be7683f
Author: Neekon Saadat <neekonsu@gmail.com>
Date: Tue Jul 15 13:06:20 2025
Subject: sync commit

diff --git a/cms/inquis/cms_cli.c b/cms/inquis/cms_cli.c
index beb5af58..dba859e1 100644
--- a/cms/inquis/cms_cli.c
+++ b/cms/inquis/cms_cli.c
@@ -80,6 +80,12 @@
 bool cfg_overload = false;
 Config *config = NULL;
 
+/**
+ * @brief Load system configuration from SD card or fallback to defaults.
+ *
+ * Attempts to mount the SD card and read the configuration file. If unsuccessful,
+ * falls back to loading default configuration values. Initializes the global `config` pointer.
+ */
 void _load_config() {
     Err err = sd_card_mount();
     if (err != 0) {
@@ -100,6 +106,14 @@ void _load_config() {
     check_str_allocates(0, 0);
 }
 
+/**
+ * @brief Command for accessing or modifying GPIO pin state.
+ *
+ * @param argc Number of arguments.
+ * @param argv Array of string arguments.
+ *
+ * - `gpio [val0] [delay] [val1]`: read or write pin values with optional timing.
+ */
 void _cmd_gpio(int argc, char **argv) {
     if (argc == 0) {
         printf("pin [val0] [delay] [val1]: Get/Set GPIO.\n");
@@ -141,6 +155,12 @@ void _cmd_gpio(int argc, char **argv) {
     }
 }
 
+/**
+ * @brief Command to set both onboard LEDs to a specific RGB value.
+ *
+ * @param argc Number of arguments.
+ * @param argv Array of string arguments.
+ */
 void _cmd_led(int argc, char **argv) {
     if (argc == 0) {
         printf("led set both leds to r g b\n");
@@ -160,6 +180,12 @@ void _cmd_led(int argc, char **argv) {
     rgb_led_set(1, r, g, b);
 }
 
+/**
+ * @brief Command to display or set configuration key-value pairs.
+ *
+ * @param argc Number of arguments.
+ * @param argv Array of string arguments.
+ */
 void _cmd_cfg(int argc, char **argv) {
     if (argc == 0) {
         printf("cfg set key val\n");
@@ -204,6 +230,12 @@ void _cmd_cfg(int argc, char **argv) {
     cfg_overload = true;
 }
 
+/**
+ * @brief Command to monitor and report ADC values and statistics.
+ *
+ * @param argc Number of arguments.
+ * @param argv Array of string arguments.
+ */
 void _cmd_adc(int argc, char **argv) {
     if (argc == 0) {
         printf("adc. Monitors ADC\n");
@@ -305,6 +337,12 @@ void _cmd_adc(int argc, char **argv) {
     }
 }    
 
+/**
+ * @brief Interactive audio playback command from SD card.
+ *
+ * @param argc Number of arguments.
+ * @param argv Array of string arguments.
+ */
 void _cmd_audio(int argc, char **argv) {
     if (argc == 0) {
         printf("audio. Toggles sound\n");
@@ -362,6 +400,12 @@ void _cmd_audio(int argc, char **argv) {
     }
 }
 
+/**
+ * @brief Play default audio file in a loop with interactive prompts.
+ *
+ * @param argc Number of arguments.
+ * @param argv Array of string arguments.
+ */
 void _cmd_defaudio(int argc, char **argv) {
     if (argc == 0) {
         printf("default audio.\n");
@@ -406,6 +450,11 @@ void _cmd_defaudio(int argc, char **argv) {
     }
 }
 
+/**
+ * @brief Load and prepare audio files based on configuration values.
+ *
+ * @param config Pointer to the configuration structure.
+ */
 void _setup_audio(Config *config) {
     Err err = 0;
     err = sd_card_mount();
@@ -417,6 +466,12 @@ void _setup_audio(Config *config) {
     // audio_load(AUDIO_WARNBACK, config->audio_warnback_file_number, config->audio_warnback_volume_divisor, false);
 }
 
+/**
+ * @brief Automatic startup routine that loads config and launches main state machine.
+ *
+ * @param argc Number of arguments.
+ * @param argv Array of string arguments.
+ */
 void _cmd_autorun(int argc, char **argv) {
     // Load the config file to decide what mode to run in
 
@@ -464,6 +519,12 @@ void _cmd_autorun(int argc, char **argv) {
     cms_log_uninit();
 }
 
+/**
+ * @brief Command to manually start the main state machine with logging and debug options.
+ *
+ * @param argc Number of arguments.
+ * @param argv Array of string arguments.
+ */
 void _cmd_run(int argc, char **argv) {
     if (argc == 0) {
         printf("run\n");
@@ -528,6 +589,12 @@ void _cmd_run(int argc, char **argv) {
     cms_log_uninit();
 }
 
+/**
+ * @brief Serial transmission test using UART2 and DMA.
+ *
+ * @param argc Number of arguments.
+ * @param argv Array of string arguments.
+ */
 void _cmd_serial(int argc, char **argv) {
     if (argc == 0) {
         printf("serial port test\n");
@@ -559,6 +626,12 @@ void _cmd_serial(int argc, char **argv) {
     //comm_enable_reception();
 }
 
+/**
+ * @brief Continuously reads pressure sensor values until a key is pressed.
+ *
+ * @param argc Number of arguments.
+ * @param argv Array of string arguments.
+ */
 void _cmd_press(int argc, char **argv) {
     if (argc == 0) {
         printf("read pressure values until key press\n");
@@ -585,6 +658,12 @@ void _cmd_press(int argc, char **argv) {
     }
 }
 
+/**
+ * @brief Continuously reads syringe position sensor values until a key is pressed.
+ *
+ * @param argc Number of arguments.
+ * @param argv Array of string arguments.
+ */
 void _cmd_pos(int argc, char **argv) {
     if (argc == 0) {
         printf("read syringe position values until key press\n");
@@ -610,6 +689,12 @@ void _cmd_pos(int argc, char **argv) {
     }
 }
 
+/**
+ * @brief Communication loopback test (if testing enabled).
+ *
+ * @param argc Number of arguments.
+ * @param argv Array of string arguments.
+ */
 void _cmd_loop(int argc, char **argv) {
     if (argc == 0) {
         printf("Run communication loop-back test\n");
@@ -630,6 +715,12 @@ void _cmd_loop(int argc, char **argv) {
     #endif
 }
 
+/**
+ * @brief Performs a valve strike and PWM cycle based on user parameters.
+ *
+ * @param argc Number of arguments.
+ * @param argv Array of string arguments.
+ */
 void _cmd_valve(int argc, char **argv) {
     if (argc == 0) {
         printf("valve strike_ms duty_cycle_percent: Runs a single strike-duty-cycle\n");
@@ -653,6 +744,12 @@ void _cmd_valve(int argc, char **argv) {
     valve_set_pwm(0);
 }
 
+/**
+ * @brief Tests valve state transitions with user-defined delays and final state.
+ *
+ * @param argc Number of arguments.
+ * @param argv Array of string arguments.
+ */
 void _cmd_valve_state(int argc, char **argv) {
     if (argc == 0) {
         printf("Test the valve state machine\n");
@@ -743,6 +840,12 @@ void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim) {
 }
 #endif
 
+/**
+ * @brief Runs a critical section test under high-frequency timer interrupts.
+ *
+ * @param argc Number of arguments.
+ * @param argv Array of string arguments.
+ */
 void _cmd_crit_sect(int argc, char **argv) {
     if (argc == 0) {
         printf("Run critical section test\n");
@@ -804,6 +907,12 @@ void _cmd_crit_sect(int argc, char **argv) {
 #endif
 }
 
+/**
+ * @brief Runs extended duration communication tests (if enabled).
+ *
+ * @param argc Number of arguments.
+ * @param argv Array of string arguments.
+ */
 void _cmd_long_comm_tests(int argc, char **argv) {
     if (argc == 0) {
         printf("Run long comm tests\n");
@@ -820,6 +929,12 @@ void _cmd_long_comm_tests(int argc, char **argv) {
 }
 
 
+/**
+ * @brief Executes unit and integration test suites based on compile-time flags.
+ *
+ * @param argc Number of arguments.
+ * @param argv Array of string arguments.
+ */
 void _cmd_tests(int argc, char **argv) {
     if (argc == 0) {
         printf("Run tests\n");
@@ -899,6 +1014,12 @@ void _cmd_tests(int argc, char **argv) {
     #endif
 }
 
+/**
+ * @brief Simulates watchdog timeout by skipping watchdog petting for a duration.
+ *
+ * @param argc Number of arguments.
+ * @param argv Array of string arguments.
+ */
 void _cmd_watchdog(int argc, char **argv) {
     // Do not pet the watchdog and see what happens
     if (argc == 0) {
@@ -916,6 +1037,12 @@ void _cmd_watchdog(int argc, char **argv) {
     printf("Watchdog should have reset. If you see this, it failed.\n");
 }
 
+/**
+ * @brief Lists contents of the SD card directory.
+ *
+ * @param argc Number of arguments.
+ * @param argv Array of string arguments.
+ */
 void _cmd_dir(int argc, char **argv) {
     if (argc == 0) {
         printf("show contents of SD card\n");
@@ -992,16 +1119,33 @@ void *_commands[] = {
     CMD(watchdog),
 };
 
+/**
+ * @brief Get the total number of registered CLI commands.
+ *
+ * @return Number of CLI commands.
+ */
 int _get_n_cmds() {
     // There are two elements per command, see _commands
     return countof(_commands) / 2;
 }
 
+/**
+ * @brief Get the name of a CLI command by index.
+ *
+ * @param i Index of the command.
+ * @return Pointer to command name string.
+ */
 char *_get_cmd_name_i(int i) {
     char *name = (char *)_commands[i * 2];
     return name;
 }
 
+/**
+ * @brief Get the function pointer of a CLI command by index.
+ *
+ * @param i Index of the command.
+ * @return Function pointer of the command.
+ */
 CmdFuncPtr _get_cmd_func_i(int i) {
     CmdFuncPtr cmd_func_ptr = (CmdFuncPtr)_commands[i * 2 + 1];
     return cmd_func_ptr;
@@ -1012,6 +1156,9 @@ CmdFuncPtr _get_cmd_func_i(int i) {
 // (Do NOT start with underscore)
 // **************************************************************************************
 
+/**
+ * @brief Print help text and usage for all available CLI commands.
+ */
 void print_usage() {
     printf("%s", ansi_term_reset);
     sleep_ms(100);
@@ -1025,6 +1172,11 @@ void print_usage() {
     }
 }
 
+/**
+ * @brief Parses and executes a single command line string.
+ *
+ * @param command_line The raw command line string to execute.
+ */
 void call_cmd(char *command_line) {
     char *argv[N_CMD_MAX_ARGS];
 
@@ -1054,10 +1206,18 @@ void call_cmd(char *command_line) {
     free(_command_line);
 }
 
+/**
+ * @brief Handles command-line errors by printing an error message.
+ *
+ * @param fail_msg String describing the error.
+ */
 void cmd_error_handler(char *fail_msg) {
     printf("ERROR: %s\n", fail_msg);
 }
 
+/**
+ * @brief Main CLI loop for accepting and executing user commands.
+ */
 void cli_main() {
     while (1) {
         printf("> ");

9f42f318b82a85fb4b28106d9da6a9e4d7373a52
Author: Neekon Saadat <neekonsu@gmail.com>
Date: Mon Jul 14 21:52:27 2025
Subject: Updated Doxyfile and commented out cms/main.c

diff --git a/Doxyfile b/Doxyfile
index 84b1f45f..1689e5b3 100644
--- a/Doxyfile
+++ b/Doxyfile
@@ -2021,7 +2021,7 @@ EXTRA_SEARCH_MAPPINGS  =
 # If the GENERATE_LATEX tag is set to YES, Doxygen will generate LaTeX output.
 # The default value is: YES.
 
-GENERATE_LATEX         = YES
+GENERATE_LATEX         = NO
 
 # The LATEX_OUTPUT tag is used to specify where the LaTeX docs will be put. If a
 # relative path is entered the value of OUTPUT_DIRECTORY will be put in front of
diff --git a/cms/Core/Src/main.c b/cms/Core/Src/main.c
index bfa32ad0..a2603e4c 100644
--- a/cms/Core/Src/main.c
+++ b/cms/Core/Src/main.c
@@ -99,9 +99,14 @@ static void MX_IWDG_Init(void);
 /* USER CODE END 0 */
 
 /**
-  * @brief  The application entry point.
-  * @retval int
-  */
+ * @brief Entry point of the firmware application.
+ *
+ * Initializes the HAL, configures the system clock, initializes all
+ * configured peripherals, and then enters an infinite loop. The main
+ * user application is started by calling inquis_main().
+ *
+ * @retval int Always returns 0 (though never reached).
+ */
 int main(void)
 {
 
@@ -161,9 +166,11 @@ int main(void)
 }
 
 /**
-  * @brief System Clock Configuration
-  * @retval None
-  */
+ * @brief Configures the system clock for the MCU.
+ *
+ * Sets up the oscillators, PLL settings, and the AHB and APB clock dividers.
+ * This function is device-specific and sets the MCU to a stable clock configuration.
+ */
 void SystemClock_Config(void)
 {
   RCC_OscInitTypeDef RCC_OscInitStruct = {0};
@@ -210,10 +217,12 @@ void SystemClock_Config(void)
 }
 
 /**
-  * @brief ADC1 Initialization Function
-  * @param None
-  * @retval None
-  */
+ * @brief Initializes ADC1 peripheral.
+ *
+ * Configures ADC resolution, clock prescaler, conversion mode, and 
+ * associated channel (ADC_CHANNEL_10) with specified sample time and 
+ * offset configuration.
+ */
 static void MX_ADC1_Init(void)
 {
 
@@ -277,10 +286,11 @@ static void MX_ADC1_Init(void)
 }
 
 /**
-  * @brief DAC1 Initialization Function
-  * @param None
-  * @retval None
-  */
+ * @brief Initializes DAC1 peripheral.
+ *
+ * Sets up DAC channel 1 with a trigger from TIM6 TRGO, enables output buffer,
+ * and uses factory trimming. Channel is configured for non-sample-and-hold operation.
+ */
 static void MX_DAC1_Init(void)
 {
 
@@ -320,10 +330,10 @@ static void MX_DAC1_Init(void)
 }
 
 /**
-  * @brief I2C1 Initialization Function
-  * @param None
-  * @retval None
-  */
+ * @brief Initializes I2C1 peripheral.
+ *
+ * Configures timing, addressing mode, filters, and disables general call and no-stretch mode.
+ */
 static void MX_I2C1_Init(void)
 {
 
@@ -368,10 +378,10 @@ static void MX_I2C1_Init(void)
 }
 
 /**
-  * @brief I2C3 Initialization Function
-  * @param None
-  * @retval None
-  */
+ * @brief Initializes I2C3 peripheral.
+ *
+ * Similar to I2C1, sets up timing configuration, addressing, and filter settings.
+ */
 static void MX_I2C3_Init(void)
 {
 
@@ -416,10 +426,10 @@ static void MX_I2C3_Init(void)
 }
 
 /**
-  * @brief IWDG Initialization Function
-  * @param None
-  * @retval None
-  */
+ * @brief Initializes Independent Watchdog (IWDG).
+ *
+ * Configures prescaler, window value, and reload value. Starts the watchdog timer.
+ */
 static void MX_IWDG_Init(void)
 {
 
@@ -445,10 +455,11 @@ static void MX_IWDG_Init(void)
 }
 
 /**
-  * @brief SPI2 Initialization Function
-  * @param None
-  * @retval None
-  */
+ * @brief Initializes SPI2 peripheral.
+ *
+ * Sets up SPI in master mode, 8-bit data, low polarity, phase 1 edge,
+ * and enables NSS pulse management.
+ */
 static void MX_SPI2_Init(void)
 {
 
@@ -485,10 +496,11 @@ static void MX_SPI2_Init(void)
 }
 
 /**
-  * @brief TIM2 Initialization Function
-  * @param None
-  * @retval None
-  */
+ * @brief Initializes TIM2 base timer.
+ *
+ * Configures timer for up-counting with prescaler and period settings.
+ * No master/slave synchronization is used.
+ */
 static void MX_TIM2_Init(void)
 {
 
@@ -530,10 +542,11 @@ static void MX_TIM2_Init(void)
 }
 
 /**
-  * @brief TIM3 Initialization Function
-  * @param None
-  * @retval None
-  */
+ * @brief Initializes TIM3 for PWM generation.
+ *
+ * Sets up PWM channels 1 and 3 with configured period and pulse.
+ * No master/slave synchronization is used.
+ */
 static void MX_TIM3_Init(void)
 {
 
@@ -583,10 +596,11 @@ static void MX_TIM3_Init(void)
 }
 
 /**
-  * @brief TIM4 Initialization Function
-  * @param None
-  * @retval None
-  */
+ * @brief Initializes TIM4 base timer.
+ *
+ * Configures TIM4 with internal clock, counter mode, and prescaler.
+ * Used for general-purpose timing.
+ */
 static void MX_TIM4_Init(void)
 {
 
@@ -628,10 +642,10 @@ static void MX_TIM4_Init(void)
 }
 
 /**
-  * @brief TIM5 Initialization Function
-  * @param None
-  * @retval None
-  */
+ * @brief Initializes TIM5 base timer.
+ *
+ * Configures TIM5 for a very long period, useful as a time base counter.
+ */
 static void MX_TIM5_Init(void)
 {
 
@@ -673,10 +687,11 @@ static void MX_TIM5_Init(void)
 }
 
 /**
-  * @brief TIM6 Initialization Function
-  * @param None
-  * @retval None
-  */
+ * @brief Initializes TIM6 for DAC trigger timing.
+ *
+ * Configures the timer to generate an update event used as a trigger
+ * source for DAC channel 1.
+ */
 static void MX_TIM6_Init(void)
 {
 
@@ -711,10 +726,11 @@ static void MX_TIM6_Init(void)
 }
 
 /**
-  * @brief UART4 Initialization Function
-  * @param None
-  * @retval None
-  */
+ * @brief Initializes UART4 peripheral.
+ *
+ * Configures baud rate, data format, and disables hardware flow control.
+ * Used for TX/RX communication.
+ */
 static void MX_UART4_Init(void)
 {
 
@@ -746,10 +762,10 @@ static void MX_UART4_Init(void)
 }
 
 /**
-  * @brief USART1 Initialization Function
-  * @param None
-  * @retval None
-  */
+ * @brief Initializes USART1 peripheral.
+ *
+ * Configures UART settings and enables RTS/CTS hardware flow control.
+ */
 static void MX_USART1_UART_Init(void)
 {
 
@@ -781,10 +797,10 @@ static void MX_USART1_UART_Init(void)
 }
 
 /**
-  * @brief USART2 Initialization Function
-  * @param None
-  * @retval None
-  */
+ * @brief Initializes USART2 peripheral.
+ *
+ * High-speed UART configuration (921600 baud) with no flow control.
+ */
 static void MX_USART2_UART_Init(void)
 {
 
@@ -816,11 +832,12 @@ static void MX_USART2_UART_Init(void)
 }
 
 /**
-  * Enable DMA controller clock
-  * Configure DMA for memory to memory transfers
-  *   hdma_memtomem_dma1_channel2
-  *   hdma_memtomem_dma1_channel1
-  */
+ * @brief Initializes DMA controller and memory-to-memory DMA channels.
+ *
+ * Enables the DMA1 clock and configures two memory-to-memory DMA channels
+ * with byte alignment and very high priority. Also enables IRQs for
+ * USART2 RX/TX and general DMA interrupts.
+ */
 static void MX_DMA_Init(void)
 {
 
@@ -871,10 +888,12 @@ static void MX_DMA_Init(void)
 }
 
 /**
-  * @brief GPIO Initialization Function
-  * @param None
-  * @retval None
-  */
+ * @brief Initializes all GPIO pins used in the project.
+ *
+ * Configures input/output modes, initial output levels, and pull-up/down
+ * settings for various GPIO pins controlling hardware components such as
+ * LEDs, regulators, SD card, valve controls, and board revision detection.
+ */
 static void MX_GPIO_Init(void)
 {
   GPIO_InitTypeDef GPIO_InitStruct = {0};
@@ -968,9 +987,11 @@ static void MX_GPIO_Init(void)
 /* USER CODE END 4 */
 
 /**
-  * @brief  This function is executed in case of error occurrence.
-  * @retval None
-  */
+ * @brief Error handling routine.
+ *
+ * Disables interrupts and enters an infinite loop. Used when a HAL function
+ * returns an error status. This allows debugging via a breakpoint or LED signal.
+ */
 void Error_Handler(void)
 {
   /* USER CODE BEGIN Error_Handler_Debug */
@@ -982,14 +1003,13 @@ void Error_Handler(void)
   /* USER CODE END Error_Handler_Debug */
 }
 
-#ifdef  USE_FULL_ASSERT
+ #ifdef  USE_FULL_ASSERT
 /**
-  * @brief  Reports the name of the source file and the source line number
-  *         where the assert_param error has occurred.
-  * @param  file: pointer to the source file name
-  * @param  line: assert_param error line source number
-  * @retval None
-  */
+ * @brief Reports source file and line number of an assert failure.
+ *
+ * @param file Pointer to the file name where the assert occurred.
+ * @param line Line number of the assertion failure.
+ */
 void assert_failed(uint8_t *file, uint32_t line)
 {
   /* USER CODE BEGIN 6 */

eec1bd5b2ddae203139c781e2eb0d29f283d4477
Author: Neekon Saadat <neekonsu@gmail.com>
Date: Mon Jul 14 16:48:31 2025
Subject: Created remarks markdon for entire common directory.

diff --git a/REMARKS.md b/REMARKS.md
index 17426c8e..4cf30ad9 100644
--- a/REMARKS.md
+++ b/REMARKS.md
@@ -4,4 +4,393 @@ GLOVES MUST COME OFF LEAVING RND LAB, HANDS MUST BE WASHED
 # TASKS
 
 Create pipeline for scrubbing and bundling gen 3 data
-Design database format and 
\ No newline at end of file
+Design database format and 
+
+# Critical
+
+## comm.c
+```
+/**
+ * @brief Callback for UART error interrupts.
+ *
+ * Handles UART overrun, framing, noise, and other errors. Attempts recovery by
+ * restarting reception or flushing buffers.
+ *
+ * @param huart Pointer to UART handle where the error occurred.
+ */
+void HAL_UART_ErrorCallback(UART_HandleTypeDef *huart) {
+    printf("HAL_UART_ErrorCallback: ");
+
+    if (huart->ErrorCode & HAL_UART_ERROR_ORE) {
+        // TODO: I do not understand under what situation this occurs.
+        // Right now its happening whenver the CMS sleeps for a long time.
+        HAL_UART_DMAStop(huart);
+        __HAL_UART_CLEAR_OREFLAG(huart);
+        comm_recv_packets();
+    }
+```
+
+## SD CARD
+### sd_card_read_file_binary
+```
+char *sd_card_read_file_binary(char *filename, size_t *out_size) {
+    // Returns a malloc'd buffer. Be sure to free it!
+    // I found that opening large files (such as the audio files)
+    // was taking enough time that I was resetting the MCU so I added
+    // aggressive watchdog petting.
+```
+
+### sd_card_get_freespace
+```
+Err sd_card_get_freespace(uint32_t *out_totalSpace, uint32_t *out_freeSpace) {
+    Err err = 0;
+    DWORD free_clusters;
+
+    TRY_START {
+        // The read free is taking about 2 minutes in some cases
+        // as it scans all the sectors. I suspect this is a failure
+        // of the card format.
+```
+
+## lights.c
+```
+/* TODO: THE BELOW STATIC DEFINITIONS VIOLATE ABSTRACTION BARRIER, UNSAFE */
+static LightVal _curr_light_val = LIGHT_OFF; // TODO wrap into state, avoid explicit peripheral manipulation outside state -> major debug hole potential
+static bool _curr_light_on = true; // TODO large name overlap, needs to change, and prev remark about direct manipulation outside state.
+static uint32_t _light_val_to_rgb_lut[LIGHT_N_VALS] = { 0, }; // static variable, initialization is redundant
+bool _is_flashing = false; // TODO NOT DECLARED STATIC BUT IN STATIC SECTION ||| same suggestion, should not be manipulated globally, or document intent to initialize to defaults in this block
+```
+
+## led_driver.c
+```
+// At 32MHz, a period is 1.0 / 32,000,000 = 3.12e-8 which is 31 nano secs. But they want 200usec == 200,000 nsec.
+    // So we need to wait like 6451 clocks before doing anything.
+
+    uint8_t val = 0x7;
+    HAL_I2C_Mem_Write(&hi2c3, FRONT_LED_I2C, ENABLE_REGISTER, I2C_MEMADD_SIZE_8BIT, &val, 1, HAL_MAX_DELAY);
+
+    // TODO: Feels like an err here is a legit POST failure that needs to propagate up.
+    // inquis_assert(err == 0);
+
+    HAL_I2C_Mem_Write(&hi2c3, REAR_LED_I2C, ENABLE_REGISTER, I2C_MEMADD_SIZE_8BIT, &val, 1, HAL_MAX_DELAY);
+```
+
+# Non-Critical, High Importance
+
+## comm.c
+```
+/**
+ * @brief UART receive event callback for IDLE detection.
+ *
+ * Handles frame reception using DMA and verifies CRC. Decodes valid packets into
+ * the receive FIFO and optionally schedules a reply using a timer.
+ *
+ * @param huart UART handle that received data.
+ * @param size Number of bytes received.
+ */
+void HAL_UARTEx_RxEventCallback(UART_HandleTypeDef *huart, uint16_t size) {
+    if (huart->ErrorCode != 0 ) {
+        // TODO Proper error handling
+        printf("HAL_UARTEx_RxEventCallback. huart->ErrorCode = %u\n", (unsigned)huart->ErrorCode);
+    }
+    if(huart->Instance != USART2) {
+        printf("HAL_UARTEx_RxEventCallback non-usart2\n");
+    }
+
+    HAL_UART_RxEventTypeTypeDef event = HAL_UARTEx_GetRxEventType(huart);
+    if (event == HAL_UART_RXEVENT_IDLE) {
+        _receive_idle_wait_for_dma();
+```
+
+## comm.h
+```
+#include "common.h"
+#include "fifo.h"
+#include "packet.h"
+
+// **************************************************************************************
+// MACROS AND DEFINES
+// **************************************************************************************
+
+#define PRSMAGPHA_SAMPLES_PER_PACKET (32) // TODO: Tune
+```
+
+## common.c
+```
+/**
+ * @brief Returns adjusted time with offset applied.
+ *
+ * Do not use for timers, as time may go backward.
+ */
+TimeMS get_sync_time_ms() {
+    // TODO: This wil have an adjustable offset which might allow time to go backwards
+    // so do not use as a timer.
+    return get_time_ms() - _time_difference_ms;
+}
+
+/**
+ * @brief Halts program execution, continuously pets the watchdog.
+ *
+ * @param msg Optional message to emit before halting.
+ */
+void halt(char *msg) {
+    // TODO Emit message to BOTH stdout and to SD Card streams
+    if (msg) {
+        printf("%s", msg);
+    }
+    fflush(stdout);
+    fflush(stderr);
+
+    // #if TESTING_ENABLED == 1
+    //     if (inttest_bypass_halt != 0) {
+    //         inttest_bypass_halt_reason = msg;
+    //         return;
+    //     }
+    // #endif
+
+    // Loop forever
+    while (1) {
+        pet_watchdog();
+    }
+}
+```
+
+## default_config.txt
+```
+R"#(#
+# The first line must be EXACTLY as it appears above TODO NOT CLEAN
+```
+
+## defines.h
+```
+// Modified by inquis_gen_3_0/build.sh
+/* @TODO NOT CLEAN */
+#define EMC 0
+#define TIP_SIZE 24
+
+```
+
+## fifo.h
+```
+/**
+ * @brief Circular buffer for packet exchange between microcontrollers.
+ *
+ * Manages a fixed-size FIFO queue of raw packet memory blocks, supporting
+ * concurrent read/write indices with basic locking. Used for CMS/handle communication.
+ */
+typedef struct _FIFO {
+    uint32_t read_lock;
+    uint32_t writ_lock;
+    uint32_t read_i;
+    uint32_t writ_i;
+    uint32_t n_reads; // TODO. Consider if this can roll (and force it in a test)
+    uint32_t n_writs;
+    uint8_t packets[N_FIFO_PACKETS][PACKET_MEM_SIZE];
+} FIFO;
+```
+
+## log.c
+```
+/**
+ * @brief Emit an error log message only once.
+ *
+ * Avoids repeated logging of identical static messages. Tracks unique
+ * pointer values to detect duplicates.
+ *
+ * @param msg Pointer to a static error message string.
+ */
+void emit_log_error_once(char *msg) {
+    // Log msg as an error but only once in case it repeats
+    // Assumes that msg is a static string pointer
+    // TODO: Add an integration test on this.
+    #define N_MSG_PTRS_SEEN_MAX (8)
+    static int n_msg_ptrs_seen = 0;
+    static char *msg_ptrs_seen[N_MSG_PTRS_SEEN_MAX] = {0,};
+```
+
+## lights.c
+```
+**
+ * @brief Load light RGB values from system configuration.
+ *
+ * Populates the internal lookup table with RGB values for each LightVal
+ * enum based on the current system's configuration (CMS or HANDLE).
+ *
+ * @param config Pointer to the configuration struct with RGB values.
+ */
+void lights_load_rgb_vals_from_config(Config *config) {
+
+    #if defined(SUBSYSTEM_CMS) /* TODO should be implemented as compiler flag instead of IFDEF, harder to track and debug with IFDEF */
+        _light_val_to_rgb_lut[LIGHT_OFF] = config->cms_light_off_rgb;
+        _light_val_to_rgb_lut[LIGHT_CONNECTING] = config->cms_light_connecting_rgb;
+        _light_val_to_rgb_lut[LIGHT_CMS_ERROR] = config->cms_light_cms_error_rgb;
+        _light_val_to_rgb_lut[LIGHT_IMP_STATE_1_SHORT_CIRCUIT] = config->cms_light_imp_state_1_short_circuit_rgb;
+        _light_val_to_rgb_lut[LIGHT_IMP_STATE_2_SALINE_BLOOD] = config->cms_light_imp_state_2_saline_blood_wall_rgb;
+        _light_val_to_rgb_lut[LIGHT_IMP_STATE_3_CLOT] = config->cms_light_imp_state_3_clot_rgb;
+        _light_val_to_rgb_lut[LIGHT_IMP_STATE_4_AIR] = config->cms_light_imp_state_4_air_rgb;
+        _light_val_to_rgb_lut[LIGHT_IMP_STATE_5_OPEN_CIRCUIT] = config->cms_light_imp_state_5_open_circuit_rgb;
+        _light_val_to_rgb_lut[LIGHT_FLUID_INJECTION] = config->cms_light_fluid_injection_rgb;
+        _light_val_to_rgb_lut[LIGHT_WALL_LATCH] = config->cms_light_wall_latch_rgb;
+        _light_val_to_rgb_lut[LIGHT_HANDLE_ERROR] = config->cms_light_handle_error_rgb;
+        _light_val_to_rgb_lut[LIGHT_CLOGGED] = config->cms_light_clogged_rgb;
+        _light_val_to_rgb_lut[LIGHT_LID_REMOVED] = config->cms_light_lid_removed_rgb;
+        _light_val_to_rgb_lut[LIGHT_OUT_OF_CO2] = config->cms_light_out_of_co2_rgb;
+    #elif defined(SUBSYSTEM_HANDLE) /* ALL OF THIS LOGIC SHOULD BE LOADED FROM HEADER, NOT IN SOURCE */
+```
+
+```
+#else
+    #error("No subsystem defined: must be either CMS or HANDLE") /* TODO: THIS ERROR SHOULD BE THROWN AT COMPILETIME/ENTRY, NOT IN SOURCE!! DANGEROUS IF CAPABLE OF COMPILING WITHOUT DEFINITION OF SUBSYSTEM */
+#endif
+```
+
+# Nice to Have
+
+## bbstr.c
+```
+/**
+ * @brief Create a new BBStr string object.
+ *
+ * Allocates a new BBStr structure with a copy of the given string (if provided)
+ * or an empty buffer of the specified length.
+ *
+ * @param s Source string to copy from, or NULL to create an empty string.
+ * @param len Length of the string to copy; use -1 to auto-calculate from s.
+ * @return Pointer to the newly created BBStr.
+ */
+BBStr *bbstr_new(char *s, int len) {
+    // Create a new bbstr from an existing string or allocate empty.
+    // If len < 0 (BBSTR_COPY) then it will use strlen.
+    // Len should NOT include the nul.
+    // s can be NULL in which case the new buffer is allocated.
+    // and filled with zeros.
+
+    // TODO: Remove?
+    stack_check();
+
+    if (len < 0) {
+```
+
+## config.h
+```
+/**
+ * @struct Config
+ * @brief Holds all configurable parameters for CMS and handle behavior.
+ *
+ * These values are loaded from a configuration file and define system behavior,
+ * thresholds, timing, LED colors, calibration values, and test rig settings.
+ * All fields must be integers. Modifications require changes in config.c:_config_names
+ * and default_config.txt.
+ */
+typedef struct {
+    // DO NOT change this without updating config.c:_config_names!
+    // and default_config.txt also.
+
+    // This MUST be all ints! See _set_field_key_val() @TODO NOT CLEAN, USE INTERFACE TO ASSERT TYPES
+
+    int cath_24F_imp_scale_factor_times_100;
+    int cath_16F_imp_scale_factor_times_100;
+
+    // CMS config
+    int syringe_motion_start_delta_time_ms;
+    int syringe_motion_start_threshold;
+    int syringe_motion_stop_delta_time_ms;
+    int syringe_motion_stop_threshold;
+    int syringe_vacuum_threshold;
+
+    int valve_strike_ms;
+    int valve_strike_pwm;
+    int valve_hold_pwm;
+
+    int cms_Ls;
+```
+
+## lights.c
+```
+// ************************************************************************************** TODO
+// THEORY
+// (Why is does this module exist?)
+// (Why was some simpler option avoided?)
+// (What non-obvious vocabulary is used?)
+// (What naming conventions are used?)
+// **************************************************************************************
+
+// ************************************************************************************** TODO
+// INCLUDES
+// (Use double quotes, not <>)
+// (List system includes first in alphabetic order when possible)
+// (Note when order is important)
+// **************************************************************************************
+
+#include "stdio.h"
+
+#include "lights.h"
+#include "led_driver.h"
+
+// ************************************************************************************** TODO REMOVE
+// EXTERN VARIABLES
+// (Used rarely, usually imported via #include)
+// **************************************************************************************
+
+// ************************************************************************************** TODO REMOVE
+// PRIVATE MACROS AND DEFINES
+// (Used rarely, usually destined for header files)
+// **************************************************************************************
+
+// ************************************************************************************** TODO REMOVE
+// PRIVATE TYPEDEFS
+// (Used rarely, usually destined for header files)
+// **************************************************************************************
+
+// ************************************************************************************** TODO REMOVE
+// STATIC VARIABLES
+// (Do start each with underscore)
+// **************************************************************************************
+```
+
+## test_define
+```
+// This file should be included by any file that refers to TESTING_ENABLED
+// It should be included before any other non-stdlib includes
+/* @TODO NOT CLEAN */
+#define TESTING_ENABLED 1
+```
+
+## sample_err.h
+```
+// **************************************************************************************
+// MACROS AND DEFINES
+// **************************************************************************************
+
+// @TODO: These need to be cleaned up, not all are applicable anymore
+
+#define SAMPLE_ERR_NONE (0)
+#define SAMPLE_ERR_WAKEUP_FAILED (1)          // 5940 did not wake up
+#define SAMPLE_ERR_PASSWORD (2)               // FIFO found the password in the stream
+#define SAMPLE_ERR_OVERFLOW (3)               // FIFO overflowed
+```
+
+## led_driver.c
+```
+// The intensities appear to be from 0 - 0xb7
+    r = (int)r * (int)0xb7 / (int)0xff;
+    g = (int)g * (int)0xb7 / (int)0xff;
+    b = (int)b * (int)0xb7 / (int)0xff;
+
+    // TODO: Skip these I2C writes if we're not changing and periodically refresh?
+    if(_is_on[led_i] && r == 0 && g == 0 && b == 0) {
+        _is_on[led_i] = false;
+        _rgb_led_set_enable(led_i, false);
+    }
+    else if (! _is_on[led_i] && (r != 0 || g != 0 || b != 0)) {
+        _is_on[led_i] = true;
+        _rgb_led_set_enable(led_i, true);
+    }
+```
+
+## fmt.c
+```
+// TEMP REMOVED until the state machines are sorted out between handle and cms
+
+// @TODO NOT CLEAN 
+```
\ No newline at end of file
diff --git a/cms/inquis/sd_card.c b/cms/inquis/sd_card.c
index b62f0eaa..09facfe8 100644
--- a/cms/inquis/sd_card.c
+++ b/cms/inquis/sd_card.c
@@ -10,6 +10,11 @@
 bool _sd_card_is_mounted = false;
 FATFS _fatFs;
 
+/**
+ * @brief Converts a string to uppercase in-place.
+ * 
+ * @param s Input string to convert. Must be mutable.
+ */
 void _to_upper_case_inplace(char *s) {
     while (*s != 0) {
         char c = *s;
@@ -20,6 +25,13 @@ void _to_upper_case_inplace(char *s) {
     }
 }
 
+/**
+ * @brief Converts a filename to uppercase 8.3 format.
+ * 
+ * @param filename Input filename string.
+ * @param out_filename Output buffer for short filename (must be at least 13 bytes).
+ * @param out_max_len Maximum length of output buffer.
+ */
 void _to_upper_case_8_3(char *filename, char *out_filename, int out_max_len) {
     // Find '.'
     char *s = filename;
@@ -38,10 +50,20 @@ void _to_upper_case_8_3(char *filename, char *out_filename, int out_max_len) {
     strncpy(out_filename, short_filename, out_max_len - 1);
 }
 
+/**
+ * @brief Checks if the SD card is mounted.
+ * 
+ * @return true if mounted, false otherwise.
+ */
 Err sd_card_is_mounted() {
     return _sd_card_is_mounted;
 }
 
+/**
+ * @brief Mounts the SD card file system if not already mounted.
+ * 
+ * @return 0 on success, error code otherwise.
+ */
 Err sd_card_mount() {
     Err err = 0;
     if (! _sd_card_is_mounted) {
@@ -56,10 +78,22 @@ Err sd_card_mount() {
     return err;
 }
 
+/**
+ * @brief Unmounts the SD card.
+ * 
+ * @return Result of unmount operation.
+ */
 int sd_card_unmount() {
     return f_mount(NULL, "", 0);
 }
 
+/**
+ * @brief Opens a file for read/write access, overwriting existing file.
+ * 
+ * @param filename Filename to open.
+ * @param fh File handle to populate.
+ * @return 0 on success, error code otherwise.
+ */
 Err sd_card_open_read_write(char *filename, FIL *fh) {
     char short_filename[13] = {
         0,
@@ -75,6 +109,13 @@ Err sd_card_open_read_write(char *filename, FIL *fh) {
     return err;
 }
 
+/**
+ * @brief Opens a file for read-only access.
+ * 
+ * @param filename Filename to open.
+ * @param fh File handle to populate.
+ * @return 0 on success, error code otherwise.
+ */
 Err sd_card_open_read_only(char *filename, FIL *fh) {
     char short_filename[13] = {
         0,
@@ -91,14 +132,33 @@ Err sd_card_open_read_only(char *filename, FIL *fh) {
     return err;
 }
 
+/**
+ * @brief Closes an open file handle.
+ * 
+ * @param fh File handle to close.
+ * @return 0 on success, error code otherwise.
+ */
 Err sd_card_close(FIL *fh) {
     return f_close(fh);
 }
 
+/**
+ * @brief Flushes a file's buffers to storage.
+ * 
+ * @param fh File handle to flush.
+ * @return 0 on success, error code otherwise.
+ */
 Err sd_card_flush(FIL *fh) {
     return f_sync(fh);
 }
 
+/**
+ * @brief Retrieves total and free space on the SD card.
+ * 
+ * @param out_totalSpace Pointer to store total space in KB.
+ * @param out_freeSpace Pointer to store free space in KB.
+ * @return 0 on success, error code otherwise.
+ */
 Err sd_card_get_freespace(uint32_t *out_totalSpace, uint32_t *out_freeSpace) {
     Err err = 0;
     DWORD free_clusters;
@@ -119,6 +179,11 @@ Err sd_card_get_freespace(uint32_t *out_totalSpace, uint32_t *out_freeSpace) {
     return err;
 }
 
+/**
+ * @brief Prints the contents of the SD card root directory.
+ * 
+ * @return 0 on success, error code otherwise.
+ */
 Err sd_card_dir() {
     // Print every file (used for debugging)
 
@@ -153,6 +218,12 @@ Err sd_card_dir() {
     return err;
 }
 
+/**
+ * @brief Reads a text file from SD card into a BBStr buffer.
+ * 
+ * @param filename Filename to read.
+ * @return Pointer to BBStr buffer, or NULL on failure.
+ */
 BBStr *sd_card_read_file(char *filename) {
     BBStr *buf = NULL;
     FIL fh;
@@ -174,6 +245,13 @@ BBStr *sd_card_read_file(char *filename) {
     return buf;
 }
 
+/**
+ * @brief Reads a binary file from SD card into a malloc'd buffer.
+ * 
+ * @param filename Filename to read.
+ * @param out_size Pointer to receive size of read buffer.
+ * @return Malloc'd buffer, or NULL on failure. Must be freed by caller.
+ */
 char *sd_card_read_file_binary(char *filename, size_t *out_size) {
     // Returns a malloc'd buffer. Be sure to free it!
     // I found that opening large files (such as the audio files)
@@ -207,6 +285,12 @@ char *sd_card_read_file_binary(char *filename, size_t *out_size) {
     return buf;
 }
 
+/**
+ * @brief Deletes a file from the SD card.
+ * 
+ * @param filename Filename to delete.
+ * @return 0 on success, error code otherwise.
+ */
 Err sd_card_del(char *filename) {
     Err err = 0;
     TRY_START {
diff --git a/cms/inquis/sd_card.h b/cms/inquis/sd_card.h
index 1d265c60..939f4b16 100644
--- a/cms/inquis/sd_card.h
+++ b/cms/inquis/sd_card.h
@@ -11,17 +11,113 @@
 extern FIL logFH;
 extern int isLogOpen;
 
+/**
+ * @brief Checks whether the SD card is currently mounted.
+ *
+ * This function returns an error code based on the mount state of the SD card.
+ * 
+ * @return ERR_OK if mounted, ERR_FAIL or relevant error otherwise.
+ */
 Err sd_card_is_mounted(void);
+/**
+ * @brief Mounts the SD card's filesystem.
+ *
+ * Attempts to initialize and mount the SD card if not already mounted.
+ * 
+ * @return ERR_OK on success, or an appropriate error code.
+ */
 Err sd_card_mount(void);
+/**
+ * @brief Unmounts the SD card filesystem.
+ *
+ * Safely detaches the filesystem from the SD card.
+ * 
+ * @return ERR_OK on success, or an appropriate error code.
+ */
 Err sd_card_unmount(void);
+/**
+ * @brief Opens a file on the SD card for reading and writing.
+ *
+ * If the file exists, it will be overwritten. If not, a new file is created.
+ * 
+ * @param filename The path to the file to open.
+ * @param fh Pointer to a FIL object to hold the file handle.
+ * @return ERR_OK on success, or an appropriate error code.
+ */
 Err sd_card_open_read_write(char *filename, FIL *fh);
+/**
+ * @brief Opens a file on the SD card for read-only access.
+ *
+ * The file must exist and will not be modified.
+ * 
+ * @param filename The path to the file to open.
+ * @param fh Pointer to a FIL object to hold the file handle.
+ * @return ERR_OK on success, or an appropriate error code.
+ */
 Err sd_card_open_read_only(char *filename, FIL *fh);
+/**
+ * @brief Closes an open file on the SD card.
+ *
+ * Flushes any cached data and releases the file handle.
+ * 
+ * @param fh Pointer to the open file handle to close.
+ * @return ERR_OK on success, or an appropriate error code.
+ */
 Err sd_card_close(FIL *fh);
+/**
+ * @brief Flushes a file buffer to the SD card.
+ *
+ * Ensures all buffered write operations are committed to the card.
+ * 
+ * @param fh Pointer to the file handle to flush.
+ * @return ERR_OK on success, or an appropriate error code.
+ */
 Err sd_card_flush(FIL *fh);
+/**
+ * @brief Gets the total and available space on the SD card.
+ *
+ * Retrieves disk space information, returned in kilobytes.
+ * 
+ * @param out_totalSpace Pointer to variable to receive total space.
+ * @param out_freeSpace Pointer to variable to receive free space.
+ * @return ERR_OK on success, or an appropriate error code.
+ */
 Err sd_card_get_freespace(uint32_t *out_totalSpace, uint32_t *out_freeSpace);
+/**
+ * @brief Lists the contents of the SD card's root directory.
+ *
+ * Useful for debugging and verifying file presence.
+ * 
+ * @return ERR_OK on success, or an appropriate error code.
+ */
 Err sd_card_dir(void);
+/**
+ * @brief Reads the contents of a text file into a BBStr buffer.
+ *
+ * The buffer is dynamically allocated and must be freed by the caller.
+ * 
+ * @param filename The name of the file to read.
+ * @return A BBStr pointer on success, or NULL on failure.
+ */
 BBStr *sd_card_read_file(char *filename);
+/**
+ * @brief Reads a binary file into a malloc'd memory buffer.
+ *
+ * The caller is responsible for freeing the returned buffer.
+ * 
+ * @param filename The name of the binary file to read.
+ * @param out_size Pointer to variable to receive size of buffer.
+ * @return Pointer to buffer on success, or NULL on failure.
+ */
 char *sd_card_read_file_binary(char *filename, size_t *out_size);
+/**
+ * @brief Deletes a file from the SD card.
+ *
+ * Removes the specified file from the filesystem.
+ * 
+ * @param filename The path to the file to delete.
+ * @return ERR_OK on success, or an appropriate error code.
+ */
 Err sd_card_del(char *filename);
 
 #endif
diff --git a/common/fmt.c b/common/fmt.c
index ab684bde..0e1697c3 100644
--- a/common/fmt.c
+++ b/common/fmt.c
@@ -1,834 +1,831 @@
-/*
-
-TEMP REMOVED until the state machines are sorted out between handle and cms
-
-/* @TODO NOT CLEAN */
-
-//  @author  Zack Booth Simpson
-//  @date    20 Jun 2023
-//  @brief   Formats impedance Samples into a variety of versions
-
-// **************************************************************************************
-// THEORY
-// (Why is does this module exist?)
-// (Why was some simpler option avoided?)
-// (What non-obvious vocabulary is used?)
-// (What naming conventions are used?)
-// **************************************************************************************
-
-// This module is responsible for formatting ImpSample and comments
-// into any of a number of different versioned formats.
-//
-// This module only converts ImpSample records into strings
-// and does not attempt to pass them along. See log.c for
-// the routing functions.
-//
-// Each of the formatters follow the form:
-//     Err fmt_sample_v1(ImpSample imp_sample, char *line, int max_line_len);
-//
-// That is, they accept an ImpSample record as an input and write the
-// formatted in the specified version format into the line buffer up to max_line_len
-// and return error if anything goes wrong.  The will not overwrite their line buffers.
-
-// **************************************************************************************
-// INCLUDES
-// (Use double quotes, not <>)
-// (List system includes first in alphabetic order when possible)
-// (Note when order is important)
-// **************************************************************************************
-
-#include "math.h"
-#include "stdio.h"
-#include "string.h"
-
-#include "common.h"
-#include "fmt.h"
-#include "fmt_bin.h"
-#include "loggable_state.h"
-#include "sample_err.h"
-#include "test_helpers.h"
-
-// **************************************************************************************
-// EXTERN VARIABLES
-// (Used rarely, usually imported via #include)
-// **************************************************************************************
-
-// **************************************************************************************
-// PRIVATE MACROS AND DEFINES
-// (Used rarely, usually destined for header files)
-// **************************************************************************************
-
-// **************************************************************************************
-// PRIVATE TYPEDEFS
-// (Used rarely, usually destined for header files)
-// **************************************************************************************
-
-// **************************************************************************************
-// STATIC VARIABLES
-// (Do start each with underscore)
-// **************************************************************************************
-
-static uint32_t _n_samples = 0;
-
-// **************************************************************************************
-// GLOBAL VARIABLES
-// (Do NOT start with underscore)
-// **************************************************************************************
-
-// This is a special flag that is used for validating
-// the binary format in bindump mode. It could be removed
-// in production code.
-bool dump_bin_records = false;
-
-// **************************************************************************************
-// STATIC FUNCTIONS
-// (Start each with underscore)
-// **************************************************************************************
-
-/**
- * @brief Normalize impedance magnitude for formatting.
- *
- * Converts NaNs to 0.0, caps values above a hard-coded maximum,
- * and ensures a bounded float that is safe for display formatting.
- *
- * @param mag_in_ohms Input magnitude in ohms.
- * @return Clamped and normalized magnitude.
- */
-float _normalize_mag(float mag_in_ohms) {
-    // Bound a magnitude to a range from zero to epsilon less than the hard-coded maximum.
-    // Converts nans to 0, infs to max.
-    // Returns new mag
-
-    const float MAX_MAG = 1e6f;
-
-    // Epsilon is really dependent on the number of
-    // digits we wish to show but setting up totally
-    // generic constants for that (including the format string)
-    // in C is non-trivial so it is hard coded here.
-    // Also you have to be careful because it is also
-    // a function of the float precision and so, for example,
-    // a MAX_MAG of 1e7 doesn't have the precision to show 0.1
-    const float EPS = 0.1f;
-
-    if (isnan(mag_in_ohms)) {
-        return 0.0f;
-    }
-    else if (mag_in_ohms >= MAX_MAG) {
-        return MAX_MAG - EPS;
-    }
-    else if (mag_in_ohms <= 0.0f) {
-        return 0.0f;
-    }
-    return mag_in_ohms;
-}
-
-/**
- * @brief Normalize phase angle for formatting.
- *
- * Converts radians to degrees and bounds the result to [-180, 180).
- * NaNs/Infs are set to 0.0.
- *
- * @param phase_in_radians Input phase in radians.
- * @return Normalized phase in degrees.
- */
-float _normalize_phase(float phase_in_radians) {
-    // Convert radians to degrees and bounds in range from -180 to 180
-    // Converts nans/infs to 0
-    // Returns new phase.
-
-    float p = phase_in_radians;
-
-    if (isnan(p) || isinf(p)) {
-        return 0.0f;
-    }
-
-    // CONVERT to degrees
-    const float PIF = 3.14159265359f;
-    p = p * 180.0 / PIF;
-
-    // NORMALIZE to -180 to 180
-    p = p - 360.0f * floor(p / 360.0f);
-    if (p > 180.0f) {
-        p -= 360.0;
-    }
-
-    return p;
-}
-
-// V1
-// Example: "s\t000003.0\t+090.0\n"
-// No comments allowed
-// ------------------------------------------------------------------------
-
-const int V1_MAG_FIELD_WIDTH = 8;
-const int V1_PHASE_FIELD_WIDTH = 6;
-const int V1_FIELD_WIDTH =
-    (1                        // "s"
-     + 1                      // tab
-     + V1_MAG_FIELD_WIDTH + 1 // tab
-     + V1_PHASE_FIELD_WIDTH   // phase
-     + 1                      // \n
-    );
-
-/**
- * @brief Format magnitude field for V1 sample output.
- *
- * Writes the magnitude with fixed width, zero-padded decimal format.
- *
- * @param mag Input magnitude in ohms.
- * @param out_buf Output buffer for formatted string.
- * @param buf_max_size Maximum size of the output buffer.
- * @return Error code (0 on success).
- */
-Err _v1_mag(float mag, char *out_buf, size_t buf_max_size) {
-    Err err = 0;
-    TRY_START {
-        err = string_buffer_check(out_buf, buf_max_size, V1_MAG_FIELD_WIDTH, false);
-        TRY_CHECK("_v1_mag buffer size too short");
-
-        mag = _normalize_mag(mag);
-
-        // "%0*.1f" means zero pad making it always V1_MAG_FIELD_WIDTH characters long
-        // including the "+/-" and "." and the fractional digit(s)
-        snprintf(out_buf, buf_max_size - 1, "%0*.1f", V1_MAG_FIELD_WIDTH, mag);
-
-        err = string_buffer_check(out_buf, buf_max_size, 0, false);
-        TRY_CHECK("_v1_mag buffer was overwritten");
-    }
-    TRY_END;
-
-    return err;
-}
-
-/**
- * @brief Format phase field for V1 sample output.
- *
- * Writes the phase with fixed width, signed, zero-padded decimal format.
- *
- * @param phase Input phase in radians.
- * @param out_buf Output buffer for formatted string.
- * @param buf_max_size Maximum size of the output buffer.
- * @return Error code (0 on success).
- */
-Err _v1_phase(float phase, char *out_buf, size_t buf_max_size) {
-    Err err = 0;
-    TRY_START {
-        err = string_buffer_check(out_buf, buf_max_size, V1_PHASE_FIELD_WIDTH, false);
-        TRY_CHECK("_v1_phase buffer size too short");
-
-        phase = _normalize_phase(phase);
-
-        // "%+0*.1f" means zero pad making it always V1_PHASE_FIELD_WIDTH characters long
-        // including the "+/-" and "." and the fractional digit(s)
-        snprintf(out_buf, buf_max_size - 1, "%+0*.1f", V1_PHASE_FIELD_WIDTH, phase);
-
-        err = string_buffer_check(out_buf, buf_max_size, 0, false);
-        TRY_CHECK("_v1_phase buffer was overwritten");
-    }
-    TRY_END;
-
-    return err;
-}
-
-/**
- * @brief Format Sample as V1 text string.
- *
- * Output format: "s\tMAG\tPHASE\n" with fixed-width fields.
- * No error samples or comments are supported in V1.
- *
- * @param sample Input sample to format.
- * @param state Pointer to current state (unused in V1).
- * @param out_buf Output buffer.
- * @param buf_max_size Maximum size of output buffer.
- * @return Error code.
- */
-Err _sample_v1(Sample *sample, State *state, char *out_buf, size_t buf_max_size) {
-    Err err = 0;
-    TRY_START {
-        if (sample->err != 0) {
-            // Version 1 does not print any errors
-            if (buf_max_size >= 1) {
-                out_buf[0] = 0;
-            }
-            return 0;
-        }
-
-        char magBuf[16];
-        err = _v1_mag(sample->r_load_mag_phase_adjusted.mag, magBuf, countof(magBuf));
-        TRY_CHECK("_sample_v1 _v1_mag failed");
-
-        char phaseBuf[16];
-        err = _v1_phase(sample->r_load_mag_phase_adjusted.pha, phaseBuf, countof(phaseBuf));
-        TRY_CHECK("_sample_v1 _v1_phase failed");
-
-        err = string_buffer_check(out_buf, buf_max_size, V1_FIELD_WIDTH, false);
-        TRY_CHECK("_sample_v1 buffer size too short");
-
-        snprintf(out_buf, buf_max_size - 1, "s\t%s\t%s\n", magBuf, phaseBuf);
-
-        err = string_buffer_check(out_buf, buf_max_size, 0, false);
-        TRY_CHECK("_sample_v1 buffer overwrite");
-    }
-    TRY_END;
-
-    return err;
-}
-
-/**
- * @brief No-op for V1 comment formatter.
- *
- * V1 format does not support comments; returns empty string.
- *
- * @param comment Input comment string.
- * @param out_buf Output buffer.
- * @param buf_max_size Maximum size of output buffer.
- * @return Always returns 0.
- */
-int _comment_v1(char *comment, char *out_buf, size_t buf_max_size) {
-    // No comments allowed
-    if (buf_max_size >= 1) {
-        out_buf[0] = 0;
-    }
-    return 0;
-}
-
-// V2
-// Example:
-//    "time_in_ms, corrected_mag, uncorrected_mag, phase, battery, switch_state, error_state\n"
-//    "0000037637,+000020.6,+002387.8,-002.9,02205,1,00\n"
-//    "# This is a comment"
-// ------------------------------------------------------------------------
-
-const int V2_MAG_FIELD_WIDTH = 9;
-const int V2_PHASE_FIELD_WIDTH = 6;
-const int V2_VOLTS_FIELD_WIDTH = 5;
-const int V2_SWITCH_STATE_FIELD_WIDTH = 1;
-const int V2_TIME_FIELD_WIDTH = 10;
-const int V2_SAMPLE_ERR_FIELD_WIDTH = 2;
-const int V2_SAMPLE_RAW_FIELD_WIDTH = 4 * 2; // sizeof(uint32_t) * 2 hex chars per byte
-
-Err _header_v2(char *out_buf, size_t buf_max_size) {
-    // clang-format off
-    const char *header = (
-        "time_in_ms, corrected_mag, uncorrected_mag, "
-        "phase, battery, switch_state, error_state, "
-        "rcal_mag, rcal_phase\n"
-    );
-    // clang-format on
-    const size_t header_len = strlen(header);
-
-    Err err = 0;
-    TRY_START {
-        err = string_buffer_check(out_buf, buf_max_size, header_len, false);
-        TRY_CHECK("_header_v2 buffer size too short");
-
-        strncpy(out_buf, header, header_len);
-
-        err = string_buffer_check(out_buf, buf_max_size, 0, false);
-        TRY_CHECK("_header_v2 buffer overwrite");
-    }
-    TRY_END;
-
-    return err;
-}
-
-Err _sample_v2(Sample *sample, State *state, char *out_buf, size_t buf_max_size) {
-    const int fieldWidth =
-        (V2_TIME_FIELD_WIDTH + 1 + V2_MAG_FIELD_WIDTH + 1 + V2_MAG_FIELD_WIDTH + 1 + V2_PHASE_FIELD_WIDTH + 1 +
-         V2_VOLTS_FIELD_WIDTH + 1 + V2_SWITCH_STATE_FIELD_WIDTH + 1 + V2_SAMPLE_ERR_FIELD_WIDTH + 1 +
-         V2_MAG_FIELD_WIDTH + 1 + V2_PHASE_FIELD_WIDTH + 1 + 1);
-
-    Err err = 0;
-    TRY_START {
-        err = string_buffer_check(out_buf, buf_max_size, fieldWidth, false);
-        TRY_CHECK("_sample_v2 buffer size too short");
-
-        snprintf(
-            out_buf,
-            buf_max_size - 1,
-            "%0*u,%+0*.1f,%+0*.1f,%+0*.1f,%0*d,%0*d,%0*d,%+0*.1f,%+0*.1f\n",
-            V2_TIME_FIELD_WIDTH,
-            (unsigned int)sample->time_in_ms,
-            V2_MAG_FIELD_WIDTH,
-            _normalize_mag(sample->r_load_mag_phase_adjusted.mag),
-            V2_MAG_FIELD_WIDTH,
-            _normalize_mag(sample->r_load_mag_phase.mag),
-            V2_PHASE_FIELD_WIDTH,
-            _normalize_phase(sample->r_load_mag_phase_adjusted.pha),
-            V2_VOLTS_FIELD_WIDTH,
-            (unsigned int)sample->bat_volts,
-            V2_SWITCH_STATE_FIELD_WIDTH,
-            (unsigned int)sample->user_switch_state,
-            V2_SAMPLE_ERR_FIELD_WIDTH,
-            max(0, min(99, sample->err)),
-            V2_MAG_FIELD_WIDTH,
-            _normalize_mag(sample->r_calb_mag_phase.mag),
-            V2_PHASE_FIELD_WIDTH,
-            _normalize_phase(sample->r_calb_mag_phase.pha)
-        );
-
-        err = string_buffer_check(out_buf, buf_max_size, 0, false);
-        TRY_CHECK("_sample_v2 buffer overwrite");
-    }
-    TRY_END;
-
-    return err;
-}
-
-Err _comment_v2(char *comment, char *out_buf, size_t buf_max_size) {
-    size_t comment_len = strlen(comment);
-    if (comment_len + 4 >= buf_max_size) {
-        // +4 to covert the prefix and new line.
-        return 1;
-    }
-    sprintf(out_buf, "# %s\n", comment);
-    return 0;
-}
-
-// V3
-// Example:
-//    ".....++++....p...F.."
-// No comments allowed
-// ------------------------------------------------------------------------
-
-Err _sample_v3(Sample *sample, State *state, char *out_buf, size_t buf_max_size) {
-    const float thresh_high_mag = 50000.0;
-    if (buf_max_size >= 1) {
-        char code = 0;
-        switch (sample->err) {
-            case SAMPLE_ERR_NONE:
-                code = '.';
-                if (sample->r_load_mag_phase_adjusted.mag > thresh_high_mag) {
-                    code = '+';
-                }
-                break;
-            case SAMPLE_ERR_WAKEUP_FAILED:
-                code = 'w';
-                break;
-            case SAMPLE_ERR_PASSWORD:
-                code = 'p';
-                break;
-            case SAMPLE_ERR_OVERFLOW:
-                code = 'o';
-                break;
-            case SAMPLE_ERR_COUNT_ZERO:
-                code = 'z';
-                break;
-            case SAMPLE_ERR_OUT_OF_FRAME:
-                code = 'f';
-                break;
-            case SAMPLE_ERR_INSANE_VALUE:
-                code = '!';
-                break;
-            case SAMPLE_ERR_EIGHTIES:
-                code = '8';
-                break;
-            case SAMPLE_ERR_UNLOCK_FAILED_RETRIES:
-                code = 'U';
-                break;
-            case SAMPLE_ERR_CORRUPTION:
-                code = 'C';
-                break;
-            case SAMPLE_ERR_FIFO_COUNT_MISALIGNED:
-                code = '4';
-                break;
-            default:
-                code = '?';
-                break;
-        }
-        if (buf_max_size >= 8) {
-            out_buf[0] = code;
-            out_buf[1] = 0;
-        }
-    }
-    return NOERR;
-}
-
-Err _comment_v3(char *comment, char *out_buf, size_t buf_max_size) {
-    // No comments allowed
-    if (buf_max_size >= 1) {
-        out_buf[0] = 0;
-    }
-    return NOERR;
-}
-
-// V4
-// Example:
-//    raw_mag adjusted_mag state error raw_uints
-//    "1.20e1 0 0 ffff0000 00000000 00000000 00000000\n"
-//    "# This is a comment\n"
-// ------------------------------------------------------------------------
-
-Err _sample_v4(Sample *sample, State *state, char *out_buf, size_t buf_max_size) {
-    Err err = 0;
-    TRY_START {
-        char code_buf[4] = {
-            0,
-        };
-        err = _sample_v3(sample, state, code_buf, countof(code_buf));
-        TRY_CHECK("_sample_v3");
-        snprintf(
-            out_buf,
-            buf_max_size - 1,
-            "r=%3.2e a=%3.2e e=%d s=%d %08X %08X %08X %08X\n",
-            sample->r_load_mag_phase.mag,
-            sample->r_load_mag_phase_adjusted.mag,
-            sample->err,
-            state->curr_state,
-            (unsigned int)sample->raw[0],
-            (unsigned int)sample->raw[1],
-            (unsigned int)sample->raw[2],
-            (unsigned int)sample->raw[3]
-        );
-
-        err = string_buffer_check(out_buf, buf_max_size, 0, false);
-        TRY_CHECK("_sample_v2 buffer overwrite");
-    }
-    TRY_END;
-
-    return err;
-}
-
-Err _comment_v4(char *comment, char *out_buf, size_t buf_max_size) {
-    return _comment_v2(comment, out_buf, buf_max_size);
-}
-
-// V5
-// Binary
-//    First byte: 0|1 indicate record type. 0=data, 1=comment
-//    data records are just binary writes of Sample and LoggableState
-//    comments start with 1 and are then nul-terminetd strings in
-//    padded buffer of the same size as sizeof(ImpSample). Those
-//    comments are wrapped into multiple recirds if necessary.
-// ------------------------------------------------------------------------
-
-Err _sample_v5(Sample *sample, State *state, char *out_buf, size_t buf_max_size, size_t *out_line_len) {
-    Err err = 0;
-
-    TRY_START {
-        TRY_CHECK_IS(sample->record_type == FMT_V5_SAMPLE_RECORD, "_sample_v5 reserved byte fail");
-        TRY_CHECK_IS(sample->version == SAMPLE_VERSION, "_sample_v5 version mismatch");
-        TRY_CHECK_IS(sizeof(Sample) + sizeof(LoggableState) < buf_max_size, "_sample_v5 buffer overflow");
-        memcpy(out_buf, sample, sizeof(Sample));
-
-        // State contains a lot of unnecessary fields for the log
-        // so LoggableState is only the few fields that are useful.
-        // See fmt.h
-        LoggableState abbrievated_state;
-        abbrievated_state.curr_state = state->curr_state;
-        abbrievated_state.curr_led_state = state->curr_led_state;
-        abbrievated_state.reserved1 = 0;
-        abbrievated_state.is_air = state->is_air;
-        abbrievated_state.is_blood = state->is_blood;
-        abbrievated_state.is_loimp = state->is_loimp;
-        abbrievated_state.is_hiimp = state->is_hiimp;
-        abbrievated_state.is_clot = state->is_clot;
-        abbrievated_state.is_baseline = state->is_baseline;
-        abbrievated_state.is_latch = state->is_latch;
-        abbrievated_state.reserved2 = 0;
-        abbrievated_state.now = state->now;
-        abbrievated_state.blood_baseline = state->blood_baseline;
-        abbrievated_state.sample_i = state->sample_i;
-        abbrievated_state.last_transition_sample_i = state->last_transition_sample_i;
-        abbrievated_state.last_transition_ms = state->last_transition_ms;
-
-        abbrievated_state.delayed_small_mean = state->delayed_small_mean;
-        abbrievated_state.delayed_small_range = state->delayed_small_range;
-        abbrievated_state.last_large_dot_prod = state->last_large_dot_prod;
-        abbrievated_state.last_large_max_single_point_jump = state->last_large_max_single_point_jump;
-        abbrievated_state.last_large_max = state->last_large_max;
-        abbrievated_state.last_small_mean = state->last_small_mean;
-
-        if(dump_bin_records) {
-            dump_bin_record(sample, &abbrievated_state);
-            pet_watchdog();
-        }
-
-        memcpy(&out_buf[sizeof(Sample)], &abbrievated_state, sizeof(LoggableState));
-
-        *out_line_len = sizeof(Sample) + sizeof(LoggableState);
-    }
-    TRY_END;
-
-    return err;
-}
-
-Err _comment_v5(char *comment, char *out_buf, size_t buf_max_size, size_t *out_n_xmit_bytes, size_t
-*out_n_comment_bytes) { Err err = 0; TRY_START { int comment_len = strlen(comment); int record_size = FMT_V5_RECORD_LEN;
-        *out_n_xmit_bytes = record_size;
-        TRY_CHECK_IS(record_size < buf_max_size, "_sample_v5 buf_max_size too small");
-
-        // comment_len is the number of bytes consumed of the message which is potentially
-        // smaller than the record_size since we need to account for the 1 reserverd byte
-        // and another for nul-termination.
-        size_t comment_keep_len = min(comment_len, record_size - 2);
-
-        memset(out_buf, 0, record_size);  // Paranoid clearing of buffer
-        out_buf[0] = FMT_V5_COMMENT_RECORD;  // See docs above. This indicates a comment record
-
-        memcpy(&out_buf[1], comment, comment_keep_len);
-        out_buf[comment_keep_len + 1] = 0;  // +1 because of the reserved start byte
-
-        *out_n_comment_bytes = comment_keep_len;
-    }
-    TRY_END;
-
-    return err;
-}
-
-// V6
-// Identical to V3 except that it also prints comments
-// ------------------------------------------------------------------------
-
-int _sample_v6(Sample *sample, State *state, char *out_buf, size_t buf_max_size) {
-    return _sample_v3(sample, state, out_buf, buf_max_size);
-}
-
-int _comment_v6(char *comment, char *out_buf, size_t buf_max_size) {
-    return _comment_v2(comment, out_buf, buf_max_size);
-}
-
-// V7
-// Debugging
-// last sample, max jump
-// ------------------------------------------------------------------------
-
-const int V7_TIME_FIELD_WIDTH = 8;
-const int V7_STATE_I_FIELD_WIDTH = 1;
-const int V7_STATE_NAME_FIELD_WIDTH = 7;
-const int V7_MAG_FIELD_WIDTH = 6;
-const int V7_LED_STATE_I_FIELD_WIDTH = 1;
-const int V7_LED_STATE_NAME_FIELD_WIDTH = 5;
-
-int _sample_v7(Sample *sample, State *state, char *out_buf, size_t buf_max_size) {
-    Err err = 0;
-    out_buf[0] = 0;
-    TRY_START {
-        sprintf(out_buf, "%d %d\n", (int)(sample->r_load_mag_phase_adjusted.mag),
-state->last_large_max_single_point_jump); err = string_buffer_check(out_buf, buf_max_size, 0, false);
-        TRY_CHECK("_sample_v7 buffer overwrite");
-    }
-    TRY_END;
-
-    return err;
-}
-
-int _comment_v7(char *comment, char *out_buf, size_t buf_max_size) {
-    return _comment_v2(comment, out_buf, buf_max_size);
-}
-
-// V8
-// LoggableState State debugging
-// feature vector, state name
-// ------------------------------------------------------------------------
-
-int _sample_v8(Sample *sample, State *state, char *out_buf, size_t buf_max_size) {
-    Err err = 0;
-    out_buf[0] = 0;
-    TRY_START {
-        char *dst = out_buf;
-
-        sprintf(dst, "%08u ", (unsigned)sample->time_in_ms);
-        dst += 9;
-
-        *dst++ = state->is_air   ? 'A' : 'a';
-        *dst++ = ' ';
-        *dst++ = state->is_blood ? 'B' : 'b';
-        *dst++ = ' ';
-        *dst++ = state->is_loimp ? 'S' : 's'; // S = short
-        *dst++ = ' ';
-        *dst++ = state->is_hiimp ? 'O' : 'o'; // O = open
-        *dst++ = ' ';
-        *dst++ = state->is_clot  ? 'C' : 'c';
-        *dst++ = ' ';
-        *dst++ = state->is_latch ? 'L' : 'l';
-        *dst++ = ' ';
-        //sprintf(dst, "%+09d %+09d %+09d %08u ", state->sample_mags[0], state->last_large_dot_prod,
-state->last_large_max_single_point_jump, state->blood_baseline); sprintf(dst, "%+09d %08u ", state->sample_mags[0],
-state->blood_baseline); dst += strlen(dst); char *name = state_name(state->curr_state); int len = strlen(name);
-        memcpy(dst, name, len);
-        dst += len;
-        *dst++ = ' ';
-        name = led_state_name(state->curr_led_state);
-        len = strlen(name);
-        memcpy(dst, name, len);
-        dst += len;
-
-        *dst++ = '\n';
-        *dst++ = 0;
-
-        err = string_buffer_check(out_buf, buf_max_size, 0, false);
-        TRY_CHECK("_sample_v8 buffer overwrite");
-    }
-    TRY_END;
-
-    return err;
-}
-
-int _comment_v8(char *comment, char *out_buf, size_t buf_max_size) {
-    return _comment_v2(comment, out_buf, buf_max_size);
-}
-
-// **************************************************************************************
-// GLOBAL FUNCTIONS
-// (Do NOT start with underscore)
-// **************************************************************************************
-
-Err fmt_sample(int version, Sample *sample, State *state, char *out_buf, size_t buf_max_size, size_t *out_line_len) {
-    Err err = 0;
-    if (buf_max_size >= 1) {
-        out_buf[0] = 0;
-    }
-    *out_line_len = 0;
-    bool use_strlen = false;
-    _n_samples ++;
-
-    switch (version) {
-        case 0:
-            return 0;
-        case 1:
-            err = _sample_v1(sample, state, out_buf, buf_max_size);
-            use_strlen = true;
-            break;
-        case 2:
-            err = _sample_v2(sample, state, out_buf, buf_max_size);
-            use_strlen = true;
-            break;
-        case 3:
-            err = _sample_v3(sample, state, out_buf, buf_max_size);
-            use_strlen = true;
-            break;
-        case 4:
-            err = _sample_v4(sample, state, out_buf, buf_max_size);
-            use_strlen = true;
-            break;
-        case 5:
-            err = _sample_v5(sample, state, out_buf, buf_max_size, out_line_len);
-            use_strlen = false;
-            break;
-        case 6:
-            err = _sample_v6(sample, state, out_buf, buf_max_size);
-            use_strlen = true;
-            break;
-        case 7:
-            // Reduce the noise by printing only some samples in this mode
-            // Put 1 here when not debugging
-            if(1 || _n_samples % 20 == 0) {
-                err = _sample_v7(sample, state, out_buf, buf_max_size);
-                use_strlen = true;
-            }
-            break;
-        case 8:
-            err = _sample_v8(sample, state, out_buf, buf_max_size);
-            use_strlen = true;
-            break;
-        default:
-            return 1;
-    }
-    if (use_strlen) {
-        *out_line_len = strlen(out_buf);
-    }
-#if TESTING_ENABLED == 1
-    if(test_integration_variable(&inttest_inject_fmt_error)) {
-        printf("INT_TEST: Injecting inttest_inject_fmt_error\n");
-        err = 1;
-    }
-#endif
-
-    return err;
-}
-
-Err fmt_comment(int version, char *comment, char *out_buf, size_t buf_max_size, size_t *out_n_xmit_bytes, size_t
-*out_n_comment_bytes) {
-    // *out_n_xmit_bytes: the size of the packet to be written to the device
-    // *out_n_comment_bytes:
-    //    The number of bytes of the comment string that will be written.
-    //    Might be less than strlen(comment) in the case that the comment is longer than available format allows.
-    Err err = 0;
-    if (buf_max_size >= 1) {
-        out_buf[0] = 0;
-    }
-    *out_n_xmit_bytes = 0;
-    *out_n_comment_bytes = 0;
-    bool use_strlen = false;
-    switch (version) {
-        case 0:
-            return 0;
-        case 1:
-            err = _comment_v1(comment, out_buf, buf_max_size);
-            use_strlen = true;
-            break;
-        case 2:
-            err = _comment_v2(comment, out_buf, buf_max_size);
-            use_strlen = true;
-            break;
-        case 3:
-            err = _comment_v3(comment, out_buf, buf_max_size);
-            use_strlen = true;
-            break;
-        case 4:
-            err = _comment_v4(comment, out_buf, buf_max_size);
-            use_strlen = true;
-            break;
-        case 5:
-            err = _comment_v5(comment, out_buf, buf_max_size, out_n_xmit_bytes, out_n_comment_bytes);
-            use_strlen = false;
-            break;
-        case 6:
-            err = _comment_v6(comment, out_buf, buf_max_size);
-            use_strlen = true;
-            break;
-        case 7:
-            err = _comment_v7(comment, out_buf, buf_max_size);
-            use_strlen = true;
-            break;
-        case 8:
-            err = _comment_v8(comment, out_buf, buf_max_size);
-            use_strlen = true;
-            break;
-        default:
-            return 1;
-    }
-    if (use_strlen) {
-        *out_n_xmit_bytes = strlen(out_buf);
-        *out_n_comment_bytes = *out_n_xmit_bytes;
-    }
-
-    return err;
-}
-
-void fmt_header(int version, char *out_buf, int buf_max_size) {
-    if (buf_max_size >= 1) {
-        out_buf[0] = 0;
-    }
-    switch (version) {
-        case 2:
-            _header_v2(out_buf, buf_max_size);
-    }
-}
-
-char *fmt_ext(int version) {
-    switch (version) {
-        case 0:
-            return ".txt";
-        case 1:
-            return ".txt";
-        case 2:
-            return ".csv";
-        case 3:
-            return ".txt";
-        case 4:
-            return ".txt";
-        case 5:
-            return ".bin";
-        case 6:
-            return ".txt";
-        case 7:
-            return ".txt";
-        case 8:
-            return ".txt";
-        default:
-            return ".txt";
-    }
-}
-*/
\ No newline at end of file
+// TEMP REMOVED until the state machines are sorted out between handle and cms
+
+// @TODO NOT CLEAN 
+
+// //  @author  Zack Booth Simpson
+// //  @date    20 Jun 2023
+// //  @brief   Formats impedance Samples into a variety of versions
+
+// // **************************************************************************************
+// // THEORY
+// // (Why is does this module exist?)
+// // (Why was some simpler option avoided?)
+// // (What non-obvious vocabulary is used?)
+// // (What naming conventions are used?)
+// // **************************************************************************************
+
+// // This module is responsible for formatting ImpSample and comments
+// // into any of a number of different versioned formats.
+// //
+// // This module only converts ImpSample records into strings
+// // and does not attempt to pass them along. See log.c for
+// // the routing functions.
+// //
+// // Each of the formatters follow the form:
+// //     Err fmt_sample_v1(ImpSample imp_sample, char *line, int max_line_len);
+// //
+// // That is, they accept an ImpSample record as an input and write the
+// // formatted in the specified version format into the line buffer up to max_line_len
+// // and return error if anything goes wrong.  The will not overwrite their line buffers.
+
+// // **************************************************************************************
+// // INCLUDES
+// // (Use double quotes, not <>)
+// // (List system includes first in alphabetic order when possible)
+// // (Note when order is important)
+// // **************************************************************************************
+
+// #include "math.h"
+// #include "stdio.h"
+// #include "string.h"
+
+// #include "common.h"
+// #include "fmt.h"
+// #include "fmt_bin.h"
+// #include "loggable_state.h"
+// #include "sample_err.h"
+// #include "test_helpers.h"
+
+// // **************************************************************************************
+// // EXTERN VARIABLES
+// // (Used rarely, usually imported via #include)
+// // **************************************************************************************
+
+// // **************************************************************************************
+// // PRIVATE MACROS AND DEFINES
+// // (Used rarely, usually destined for header files)
+// // **************************************************************************************
+
+// // **************************************************************************************
+// // PRIVATE TYPEDEFS
+// // (Used rarely, usually destined for header files)
+// // **************************************************************************************
+
+// // **************************************************************************************
+// // STATIC VARIABLES
+// // (Do start each with underscore)
+// // **************************************************************************************
+
+// static uint32_t _n_samples = 0;
+
+// // **************************************************************************************
+// // GLOBAL VARIABLES
+// // (Do NOT start with underscore)
+// // **************************************************************************************
+
+// // This is a special flag that is used for validating
+// // the binary format in bindump mode. It could be removed
+// // in production code.
+// bool dump_bin_records = false;
+
+// // **************************************************************************************
+// // STATIC FUNCTIONS
+// // (Start each with underscore)
+// // **************************************************************************************
+
+// /**
+//  * @brief Normalize impedance magnitude for formatting.
+//  *
+//  * Converts NaNs to 0.0, caps values above a hard-coded maximum,
+//  * and ensures a bounded float that is safe for display formatting.
+//  *
+//  * @param mag_in_ohms Input magnitude in ohms.
+//  * @return Clamped and normalized magnitude.
+//  */
+// float _normalize_mag(float mag_in_ohms) {
+//     // Bound a magnitude to a range from zero to epsilon less than the hard-coded maximum.
+//     // Converts nans to 0, infs to max.
+//     // Returns new mag
+
+//     const float MAX_MAG = 1e6f;
+
+//     // Epsilon is really dependent on the number of
+//     // digits we wish to show but setting up totally
+//     // generic constants for that (including the format string)
+//     // in C is non-trivial so it is hard coded here.
+//     // Also you have to be careful because it is also
+//     // a function of the float precision and so, for example,
+//     // a MAX_MAG of 1e7 doesn't have the precision to show 0.1
+//     const float EPS = 0.1f;
+
+//     if (isnan(mag_in_ohms)) {
+//         return 0.0f;
+//     }
+//     else if (mag_in_ohms >= MAX_MAG) {
+//         return MAX_MAG - EPS;
+//     }
+//     else if (mag_in_ohms <= 0.0f) {
+//         return 0.0f;
+//     }
+//     return mag_in_ohms;
+// }
+
+// /**
+//  * @brief Normalize phase angle for formatting.
+//  *
+//  * Converts radians to degrees and bounds the result to [-180, 180).
+//  * NaNs/Infs are set to 0.0.
+//  *
+//  * @param phase_in_radians Input phase in radians.
+//  * @return Normalized phase in degrees.
+//  */
+// float _normalize_phase(float phase_in_radians) {
+//     // Convert radians to degrees and bounds in range from -180 to 180
+//     // Converts nans/infs to 0
+//     // Returns new phase.
+
+//     float p = phase_in_radians;
+
+//     if (isnan(p) || isinf(p)) {
+//         return 0.0f;
+//     }
+
+//     // CONVERT to degrees
+//     const float PIF = 3.14159265359f;
+//     p = p * 180.0 / PIF;
+
+//     // NORMALIZE to -180 to 180
+//     p = p - 360.0f * floor(p / 360.0f);
+//     if (p > 180.0f) {
+//         p -= 360.0;
+//     }
+
+//     return p;
+// }
+
+// // V1
+// // Example: "s\t000003.0\t+090.0\n"
+// // No comments allowed
+// // ------------------------------------------------------------------------
+
+// const int V1_MAG_FIELD_WIDTH = 8;
+// const int V1_PHASE_FIELD_WIDTH = 6;
+// const int V1_FIELD_WIDTH =
+//     (1                        // "s"
+//      + 1                      // tab
+//      + V1_MAG_FIELD_WIDTH + 1 // tab
+//      + V1_PHASE_FIELD_WIDTH   // phase
+//      + 1                      // \n
+//     );
+
+// /**
+//  * @brief Format magnitude field for V1 sample output.
+//  *
+//  * Writes the magnitude with fixed width, zero-padded decimal format.
+//  *
+//  * @param mag Input magnitude in ohms.
+//  * @param out_buf Output buffer for formatted string.
+//  * @param buf_max_size Maximum size of the output buffer.
+//  * @return Error code (0 on success).
+//  */
+// Err _v1_mag(float mag, char *out_buf, size_t buf_max_size) {
+//     Err err = 0;
+//     TRY_START {
+//         err = string_buffer_check(out_buf, buf_max_size, V1_MAG_FIELD_WIDTH, false);
+//         TRY_CHECK("_v1_mag buffer size too short");
+
+//         mag = _normalize_mag(mag);
+
+//         // "%0*.1f" means zero pad making it always V1_MAG_FIELD_WIDTH characters long
+//         // including the "+/-" and "." and the fractional digit(s)
+//         snprintf(out_buf, buf_max_size - 1, "%0*.1f", V1_MAG_FIELD_WIDTH, mag);
+
+//         err = string_buffer_check(out_buf, buf_max_size, 0, false);
+//         TRY_CHECK("_v1_mag buffer was overwritten");
+//     }
+//     TRY_END;
+
+//     return err;
+// }
+
+// /**
+//  * @brief Format phase field for V1 sample output.
+//  *
+//  * Writes the phase with fixed width, signed, zero-padded decimal format.
+//  *
+//  * @param phase Input phase in radians.
+//  * @param out_buf Output buffer for formatted string.
+//  * @param buf_max_size Maximum size of the output buffer.
+//  * @return Error code (0 on success).
+//  */
+// Err _v1_phase(float phase, char *out_buf, size_t buf_max_size) {
+//     Err err = 0;
+//     TRY_START {
+//         err = string_buffer_check(out_buf, buf_max_size, V1_PHASE_FIELD_WIDTH, false);
+//         TRY_CHECK("_v1_phase buffer size too short");
+
+//         phase = _normalize_phase(phase);
+
+//         // "%+0*.1f" means zero pad making it always V1_PHASE_FIELD_WIDTH characters long
+//         // including the "+/-" and "." and the fractional digit(s)
+//         snprintf(out_buf, buf_max_size - 1, "%+0*.1f", V1_PHASE_FIELD_WIDTH, phase);
+
+//         err = string_buffer_check(out_buf, buf_max_size, 0, false);
+//         TRY_CHECK("_v1_phase buffer was overwritten");
+//     }
+//     TRY_END;
+
+//     return err;
+// }
+
+// /**
+//  * @brief Format Sample as V1 text string.
+//  *
+//  * Output format: "s\tMAG\tPHASE\n" with fixed-width fields.
+//  * No error samples or comments are supported in V1.
+//  *
+//  * @param sample Input sample to format.
+//  * @param state Pointer to current state (unused in V1).
+//  * @param out_buf Output buffer.
+//  * @param buf_max_size Maximum size of output buffer.
+//  * @return Error code.
+//  */
+// Err _sample_v1(Sample *sample, State *state, char *out_buf, size_t buf_max_size) {
+//     Err err = 0;
+//     TRY_START {
+//         if (sample->err != 0) {
+//             // Version 1 does not print any errors
+//             if (buf_max_size >= 1) {
+//                 out_buf[0] = 0;
+//             }
+//             return 0;
+//         }
+
+//         char magBuf[16];
+//         err = _v1_mag(sample->r_load_mag_phase_adjusted.mag, magBuf, countof(magBuf));
+//         TRY_CHECK("_sample_v1 _v1_mag failed");
+
+//         char phaseBuf[16];
+//         err = _v1_phase(sample->r_load_mag_phase_adjusted.pha, phaseBuf, countof(phaseBuf));
+//         TRY_CHECK("_sample_v1 _v1_phase failed");
+
+//         err = string_buffer_check(out_buf, buf_max_size, V1_FIELD_WIDTH, false);
+//         TRY_CHECK("_sample_v1 buffer size too short");
+
+//         snprintf(out_buf, buf_max_size - 1, "s\t%s\t%s\n", magBuf, phaseBuf);
+
+//         err = string_buffer_check(out_buf, buf_max_size, 0, false);
+//         TRY_CHECK("_sample_v1 buffer overwrite");
+//     }
+//     TRY_END;
+
+//     return err;
+// }
+
+// /**
+//  * @brief No-op for V1 comment formatter.
+//  *
+//  * V1 format does not support comments; returns empty string.
+//  *
+//  * @param comment Input comment string.
+//  * @param out_buf Output buffer.
+//  * @param buf_max_size Maximum size of output buffer.
+//  * @return Always returns 0.
+//  */
+// int _comment_v1(char *comment, char *out_buf, size_t buf_max_size) {
+//     // No comments allowed
+//     if (buf_max_size >= 1) {
+//         out_buf[0] = 0;
+//     }
+//     return 0;
+// }
+
+// // V2
+// // Example:
+// //    "time_in_ms, corrected_mag, uncorrected_mag, phase, battery, switch_state, error_state\n"
+// //    "0000037637,+000020.6,+002387.8,-002.9,02205,1,00\n"
+// //    "# This is a comment"
+// // ------------------------------------------------------------------------
+
+// const int V2_MAG_FIELD_WIDTH = 9;
+// const int V2_PHASE_FIELD_WIDTH = 6;
+// const int V2_VOLTS_FIELD_WIDTH = 5;
+// const int V2_SWITCH_STATE_FIELD_WIDTH = 1;
+// const int V2_TIME_FIELD_WIDTH = 10;
+// const int V2_SAMPLE_ERR_FIELD_WIDTH = 2;
+// const int V2_SAMPLE_RAW_FIELD_WIDTH = 4 * 2; // sizeof(uint32_t) * 2 hex chars per byte
+
+// Err _header_v2(char *out_buf, size_t buf_max_size) {
+//     // clang-format off
+//     const char *header = (
+//         "time_in_ms, corrected_mag, uncorrected_mag, "
+//         "phase, battery, switch_state, error_state, "
+//         "rcal_mag, rcal_phase\n"
+//     );
+//     // clang-format on
+//     const size_t header_len = strlen(header);
+
+//     Err err = 0;
+//     TRY_START {
+//         err = string_buffer_check(out_buf, buf_max_size, header_len, false);
+//         TRY_CHECK("_header_v2 buffer size too short");
+
+//         strncpy(out_buf, header, header_len);
+
+//         err = string_buffer_check(out_buf, buf_max_size, 0, false);
+//         TRY_CHECK("_header_v2 buffer overwrite");
+//     }
+//     TRY_END;
+
+//     return err;
+// }
+
+// Err _sample_v2(Sample *sample, State *state, char *out_buf, size_t buf_max_size) {
+//     const int fieldWidth =
+//         (V2_TIME_FIELD_WIDTH + 1 + V2_MAG_FIELD_WIDTH + 1 + V2_MAG_FIELD_WIDTH + 1 + V2_PHASE_FIELD_WIDTH + 1 +
+//          V2_VOLTS_FIELD_WIDTH + 1 + V2_SWITCH_STATE_FIELD_WIDTH + 1 + V2_SAMPLE_ERR_FIELD_WIDTH + 1 +
+//          V2_MAG_FIELD_WIDTH + 1 + V2_PHASE_FIELD_WIDTH + 1 + 1);
+
+//     Err err = 0;
+//     TRY_START {
+//         err = string_buffer_check(out_buf, buf_max_size, fieldWidth, false);
+//         TRY_CHECK("_sample_v2 buffer size too short");
+
+//         snprintf(
+//             out_buf,
+//             buf_max_size - 1,
+//             "%0*u,%+0*.1f,%+0*.1f,%+0*.1f,%0*d,%0*d,%0*d,%+0*.1f,%+0*.1f\n",
+//             V2_TIME_FIELD_WIDTH,
+//             (unsigned int)sample->time_in_ms,
+//             V2_MAG_FIELD_WIDTH,
+//             _normalize_mag(sample->r_load_mag_phase_adjusted.mag),
+//             V2_MAG_FIELD_WIDTH,
+//             _normalize_mag(sample->r_load_mag_phase.mag),
+//             V2_PHASE_FIELD_WIDTH,
+//             _normalize_phase(sample->r_load_mag_phase_adjusted.pha),
+//             V2_VOLTS_FIELD_WIDTH,
+//             (unsigned int)sample->bat_volts,
+//             V2_SWITCH_STATE_FIELD_WIDTH,
+//             (unsigned int)sample->user_switch_state,
+//             V2_SAMPLE_ERR_FIELD_WIDTH,
+//             max(0, min(99, sample->err)),
+//             V2_MAG_FIELD_WIDTH,
+//             _normalize_mag(sample->r_calb_mag_phase.mag),
+//             V2_PHASE_FIELD_WIDTH,
+//             _normalize_phase(sample->r_calb_mag_phase.pha)
+//         );
+
+//         err = string_buffer_check(out_buf, buf_max_size, 0, false);
+//         TRY_CHECK("_sample_v2 buffer overwrite");
+//     }
+//     TRY_END;
+
+//     return err;
+// }
+
+// Err _comment_v2(char *comment, char *out_buf, size_t buf_max_size) {
+//     size_t comment_len = strlen(comment);
+//     if (comment_len + 4 >= buf_max_size) {
+//         // +4 to covert the prefix and new line.
+//         return 1;
+//     }
+//     sprintf(out_buf, "# %s\n", comment);
+//     return 0;
+// }
+
+// // V3
+// // Example:
+// //    ".....++++....p...F.."
+// // No comments allowed
+// // ------------------------------------------------------------------------
+
+// Err _sample_v3(Sample *sample, State *state, char *out_buf, size_t buf_max_size) {
+//     const float thresh_high_mag = 50000.0;
+//     if (buf_max_size >= 1) {
+//         char code = 0;
+//         switch (sample->err) {
+//             case SAMPLE_ERR_NONE:
+//                 code = '.';
+//                 if (sample->r_load_mag_phase_adjusted.mag > thresh_high_mag) {
+//                     code = '+';
+//                 }
+//                 break;
+//             case SAMPLE_ERR_WAKEUP_FAILED:
+//                 code = 'w';
+//                 break;
+//             case SAMPLE_ERR_PASSWORD:
+//                 code = 'p';
+//                 break;
+//             case SAMPLE_ERR_OVERFLOW:
+//                 code = 'o';
+//                 break;
+//             case SAMPLE_ERR_COUNT_ZERO:
+//                 code = 'z';
+//                 break;
+//             case SAMPLE_ERR_OUT_OF_FRAME:
+//                 code = 'f';
+//                 break;
+//             case SAMPLE_ERR_INSANE_VALUE:
+//                 code = '!';
+//                 break;
+//             case SAMPLE_ERR_EIGHTIES:
+//                 code = '8';
+//                 break;
+//             case SAMPLE_ERR_UNLOCK_FAILED_RETRIES:
+//                 code = 'U';
+//                 break;
+//             case SAMPLE_ERR_CORRUPTION:
+//                 code = 'C';
+//                 break;
+//             case SAMPLE_ERR_FIFO_COUNT_MISALIGNED:
+//                 code = '4';
+//                 break;
+//             default:
+//                 code = '?';
+//                 break;
+//         }
+//         if (buf_max_size >= 8) {
+//             out_buf[0] = code;
+//             out_buf[1] = 0;
+//         }
+//     }
+//     return NOERR;
+// }
+
+// Err _comment_v3(char *comment, char *out_buf, size_t buf_max_size) {
+//     // No comments allowed
+//     if (buf_max_size >= 1) {
+//         out_buf[0] = 0;
+//     }
+//     return NOERR;
+// }
+
+// // V4
+// // Example:
+// //    raw_mag adjusted_mag state error raw_uints
+// //    "1.20e1 0 0 ffff0000 00000000 00000000 00000000\n"
+// //    "# This is a comment\n"
+// // ------------------------------------------------------------------------
+
+// Err _sample_v4(Sample *sample, State *state, char *out_buf, size_t buf_max_size) {
+//     Err err = 0;
+//     TRY_START {
+//         char code_buf[4] = {
+//             0,
+//         };
+//         err = _sample_v3(sample, state, code_buf, countof(code_buf));
+//         TRY_CHECK("_sample_v3");
+//         snprintf(
+//             out_buf,
+//             buf_max_size - 1,
+//             "r=%3.2e a=%3.2e e=%d s=%d %08X %08X %08X %08X\n",
+//             sample->r_load_mag_phase.mag,
+//             sample->r_load_mag_phase_adjusted.mag,
+//             sample->err,
+//             state->curr_state,
+//             (unsigned int)sample->raw[0],
+//             (unsigned int)sample->raw[1],
+//             (unsigned int)sample->raw[2],
+//             (unsigned int)sample->raw[3]
+//         );
+
+//         err = string_buffer_check(out_buf, buf_max_size, 0, false);
+//         TRY_CHECK("_sample_v2 buffer overwrite");
+//     }
+//     TRY_END;
+
+//     return err;
+// }
+
+// Err _comment_v4(char *comment, char *out_buf, size_t buf_max_size) {
+//     return _comment_v2(comment, out_buf, buf_max_size);
+// }
+
+// // V5
+// // Binary
+// //    First byte: 0|1 indicate record type. 0=data, 1=comment
+// //    data records are just binary writes of Sample and LoggableState
+// //    comments start with 1 and are then nul-terminetd strings in
+// //    padded buffer of the same size as sizeof(ImpSample). Those
+// //    comments are wrapped into multiple recirds if necessary.
+// // ------------------------------------------------------------------------
+
+// Err _sample_v5(Sample *sample, State *state, char *out_buf, size_t buf_max_size, size_t *out_line_len) {
+//     Err err = 0;
+
+//     TRY_START {
+//         TRY_CHECK_IS(sample->record_type == FMT_V5_SAMPLE_RECORD, "_sample_v5 reserved byte fail");
+//         TRY_CHECK_IS(sample->version == SAMPLE_VERSION, "_sample_v5 version mismatch");
+//         TRY_CHECK_IS(sizeof(Sample) + sizeof(LoggableState) < buf_max_size, "_sample_v5 buffer overflow");
+//         memcpy(out_buf, sample, sizeof(Sample));
+
+//         // State contains a lot of unnecessary fields for the log
+//         // so LoggableState is only the few fields that are useful.
+//         // See fmt.h
+//         LoggableState abbrievated_state;
+//         abbrievated_state.curr_state = state->curr_state;
+//         abbrievated_state.curr_led_state = state->curr_led_state;
+//         abbrievated_state.reserved1 = 0;
+//         abbrievated_state.is_air = state->is_air;
+//         abbrievated_state.is_blood = state->is_blood;
+//         abbrievated_state.is_loimp = state->is_loimp;
+//         abbrievated_state.is_hiimp = state->is_hiimp;
+//         abbrievated_state.is_clot = state->is_clot;
+//         abbrievated_state.is_baseline = state->is_baseline;
+//         abbrievated_state.is_latch = state->is_latch;
+//         abbrievated_state.reserved2 = 0;
+//         abbrievated_state.now = state->now;
+//         abbrievated_state.blood_baseline = state->blood_baseline;
+//         abbrievated_state.sample_i = state->sample_i;
+//         abbrievated_state.last_transition_sample_i = state->last_transition_sample_i;
+//         abbrievated_state.last_transition_ms = state->last_transition_ms;
+
+//         abbrievated_state.delayed_small_mean = state->delayed_small_mean;
+//         abbrievated_state.delayed_small_range = state->delayed_small_range;
+//         abbrievated_state.last_large_dot_prod = state->last_large_dot_prod;
+//         abbrievated_state.last_large_max_single_point_jump = state->last_large_max_single_point_jump;
+//         abbrievated_state.last_large_max = state->last_large_max;
+//         abbrievated_state.last_small_mean = state->last_small_mean;
+
+//         if(dump_bin_records) {
+//             dump_bin_record(sample, &abbrievated_state);
+//             pet_watchdog();
+//         }
+
+//         memcpy(&out_buf[sizeof(Sample)], &abbrievated_state, sizeof(LoggableState));
+
+//         *out_line_len = sizeof(Sample) + sizeof(LoggableState);
+//     }
+//     TRY_END;
+
+//     return err;
+// }
+
+// Err _comment_v5(char *comment, char *out_buf, size_t buf_max_size, size_t *out_n_xmit_bytes, size_t
+// *out_n_comment_bytes) { Err err = 0; TRY_START { int comment_len = strlen(comment); int record_size = FMT_V5_RECORD_LEN;
+//         *out_n_xmit_bytes = record_size;
+//         TRY_CHECK_IS(record_size < buf_max_size, "_sample_v5 buf_max_size too small");
+
+//         // comment_len is the number of bytes consumed of the message which is potentially
+//         // smaller than the record_size since we need to account for the 1 reserverd byte
+//         // and another for nul-termination.
+//         size_t comment_keep_len = min(comment_len, record_size - 2);
+
+//         memset(out_buf, 0, record_size);  // Paranoid clearing of buffer
+//         out_buf[0] = FMT_V5_COMMENT_RECORD;  // See docs above. This indicates a comment record
+
+//         memcpy(&out_buf[1], comment, comment_keep_len);
+//         out_buf[comment_keep_len + 1] = 0;  // +1 because of the reserved start byte
+
+//         *out_n_comment_bytes = comment_keep_len;
+//     }
+//     TRY_END;
+
+//     return err;
+// }
+
+// // V6
+// // Identical to V3 except that it also prints comments
+// // ------------------------------------------------------------------------
+
+// int _sample_v6(Sample *sample, State *state, char *out_buf, size_t buf_max_size) {
+//     return _sample_v3(sample, state, out_buf, buf_max_size);
+// }
+
+// int _comment_v6(char *comment, char *out_buf, size_t buf_max_size) {
+//     return _comment_v2(comment, out_buf, buf_max_size);
+// }
+
+// // V7
+// // Debugging
+// // last sample, max jump
+// // ------------------------------------------------------------------------
+
+// const int V7_TIME_FIELD_WIDTH = 8;
+// const int V7_STATE_I_FIELD_WIDTH = 1;
+// const int V7_STATE_NAME_FIELD_WIDTH = 7;
+// const int V7_MAG_FIELD_WIDTH = 6;
+// const int V7_LED_STATE_I_FIELD_WIDTH = 1;
+// const int V7_LED_STATE_NAME_FIELD_WIDTH = 5;
+
+// int _sample_v7(Sample *sample, State *state, char *out_buf, size_t buf_max_size) {
+//     Err err = 0;
+//     out_buf[0] = 0;
+//     TRY_START {
+//         sprintf(out_buf, "%d %d\n", (int)(sample->r_load_mag_phase_adjusted.mag),
+// state->last_large_max_single_point_jump); err = string_buffer_check(out_buf, buf_max_size, 0, false);
+//         TRY_CHECK("_sample_v7 buffer overwrite");
+//     }
+//     TRY_END;
+
+//     return err;
+// }
+
+// int _comment_v7(char *comment, char *out_buf, size_t buf_max_size) {
+//     return _comment_v2(comment, out_buf, buf_max_size);
+// }
+
+// // V8
+// // LoggableState State debugging
+// // feature vector, state name
+// // ------------------------------------------------------------------------
+
+// int _sample_v8(Sample *sample, State *state, char *out_buf, size_t buf_max_size) {
+//     Err err = 0;
+//     out_buf[0] = 0;
+//     TRY_START {
+//         char *dst = out_buf;
+
+//         sprintf(dst, "%08u ", (unsigned)sample->time_in_ms);
+//         dst += 9;
+
+//         *dst++ = state->is_air   ? 'A' : 'a';
+//         *dst++ = ' ';
+//         *dst++ = state->is_blood ? 'B' : 'b';
+//         *dst++ = ' ';
+//         *dst++ = state->is_loimp ? 'S' : 's'; // S = short
+//         *dst++ = ' ';
+//         *dst++ = state->is_hiimp ? 'O' : 'o'; // O = open
+//         *dst++ = ' ';
+//         *dst++ = state->is_clot  ? 'C' : 'c';
+//         *dst++ = ' ';
+//         *dst++ = state->is_latch ? 'L' : 'l';
+//         *dst++ = ' ';
+//         //sprintf(dst, "%+09d %+09d %+09d %08u ", state->sample_mags[0], state->last_large_dot_prod,
+// state->last_large_max_single_point_jump, state->blood_baseline); sprintf(dst, "%+09d %08u ", state->sample_mags[0],
+// state->blood_baseline); dst += strlen(dst); char *name = state_name(state->curr_state); int len = strlen(name);
+//         memcpy(dst, name, len);
+//         dst += len;
+//         *dst++ = ' ';
+//         name = led_state_name(state->curr_led_state);
+//         len = strlen(name);
+//         memcpy(dst, name, len);
+//         dst += len;
+
+//         *dst++ = '\n';
+//         *dst++ = 0;
+
+//         err = string_buffer_check(out_buf, buf_max_size, 0, false);
+//         TRY_CHECK("_sample_v8 buffer overwrite");
+//     }
+//     TRY_END;
+
+//     return err;
+// }
+
+// int _comment_v8(char *comment, char *out_buf, size_t buf_max_size) {
+//     return _comment_v2(comment, out_buf, buf_max_size);
+// }
+
+// // **************************************************************************************
+// // GLOBAL FUNCTIONS
+// // (Do NOT start with underscore)
+// // **************************************************************************************
+
+// Err fmt_sample(int version, Sample *sample, State *state, char *out_buf, size_t buf_max_size, size_t *out_line_len) {
+//     Err err = 0;
+//     if (buf_max_size >= 1) {
+//         out_buf[0] = 0;
+//     }
+//     *out_line_len = 0;
+//     bool use_strlen = false;
+//     _n_samples ++;
+
+//     switch (version) {
+//         case 0:
+//             return 0;
+//         case 1:
+//             err = _sample_v1(sample, state, out_buf, buf_max_size);
+//             use_strlen = true;
+//             break;
+//         case 2:
+//             err = _sample_v2(sample, state, out_buf, buf_max_size);
+//             use_strlen = true;
+//             break;
+//         case 3:
+//             err = _sample_v3(sample, state, out_buf, buf_max_size);
+//             use_strlen = true;
+//             break;
+//         case 4:
+//             err = _sample_v4(sample, state, out_buf, buf_max_size);
+//             use_strlen = true;
+//             break;
+//         case 5:
+//             err = _sample_v5(sample, state, out_buf, buf_max_size, out_line_len);
+//             use_strlen = false;
+//             break;
+//         case 6:
+//             err = _sample_v6(sample, state, out_buf, buf_max_size);
+//             use_strlen = true;
+//             break;
+//         case 7:
+//             // Reduce the noise by printing only some samples in this mode
+//             // Put 1 here when not debugging
+//             if(1 || _n_samples % 20 == 0) {
+//                 err = _sample_v7(sample, state, out_buf, buf_max_size);
+//                 use_strlen = true;
+//             }
+//             break;
+//         case 8:
+//             err = _sample_v8(sample, state, out_buf, buf_max_size);
+//             use_strlen = true;
+//             break;
+//         default:
+//             return 1;
+//     }
+//     if (use_strlen) {
+//         *out_line_len = strlen(out_buf);
+//     }
+// #if TESTING_ENABLED == 1
+//     if(test_integration_variable(&inttest_inject_fmt_error)) {
+//         printf("INT_TEST: Injecting inttest_inject_fmt_error\n");
+//         err = 1;
+//     }
+// #endif
+
+//     return err;
+// }
+
+// Err fmt_comment(int version, char *comment, char *out_buf, size_t buf_max_size, size_t *out_n_xmit_bytes, size_t
+// *out_n_comment_bytes) {
+//     // *out_n_xmit_bytes: the size of the packet to be written to the device
+//     // *out_n_comment_bytes:
+//     //    The number of bytes of the comment string that will be written.
+//     //    Might be less than strlen(comment) in the case that the comment is longer than available format allows.
+//     Err err = 0;
+//     if (buf_max_size >= 1) {
+//         out_buf[0] = 0;
+//     }
+//     *out_n_xmit_bytes = 0;
+//     *out_n_comment_bytes = 0;
+//     bool use_strlen = false;
+//     switch (version) {
+//         case 0:
+//             return 0;
+//         case 1:
+//             err = _comment_v1(comment, out_buf, buf_max_size);
+//             use_strlen = true;
+//             break;
+//         case 2:
+//             err = _comment_v2(comment, out_buf, buf_max_size);
+//             use_strlen = true;
+//             break;
+//         case 3:
+//             err = _comment_v3(comment, out_buf, buf_max_size);
+//             use_strlen = true;
+//             break;
+//         case 4:
+//             err = _comment_v4(comment, out_buf, buf_max_size);
+//             use_strlen = true;
+//             break;
+//         case 5:
+//             err = _comment_v5(comment, out_buf, buf_max_size, out_n_xmit_bytes, out_n_comment_bytes);
+//             use_strlen = false;
+//             break;
+//         case 6:
+//             err = _comment_v6(comment, out_buf, buf_max_size);
+//             use_strlen = true;
+//             break;
+//         case 7:
+//             err = _comment_v7(comment, out_buf, buf_max_size);
+//             use_strlen = true;
+//             break;
+//         case 8:
+//             err = _comment_v8(comment, out_buf, buf_max_size);
+//             use_strlen = true;
+//             break;
+//         default:
+//             return 1;
+//     }
+//     if (use_strlen) {
+//         *out_n_xmit_bytes = strlen(out_buf);
+//         *out_n_comment_bytes = *out_n_xmit_bytes;
+//     }
+
+//     return err;
+// }
+
+// void fmt_header(int version, char *out_buf, int buf_max_size) {
+//     if (buf_max_size >= 1) {
+//         out_buf[0] = 0;
+//     }
+//     switch (version) {
+//         case 2:
+//             _header_v2(out_buf, buf_max_size);
+//     }
+// }
+
+// char *fmt_ext(int version) {
+//     switch (version) {
+//         case 0:
+//             return ".txt";
+//         case 1:
+//             return ".txt";
+//         case 2:
+//             return ".csv";
+//         case 3:
+//             return ".txt";
+//         case 4:
+//             return ".txt";
+//         case 5:
+//             return ".bin";
+//         case 6:
+//             return ".txt";
+//         case 7:
+//             return ".txt";
+//         case 8:
+//             return ".txt";
+//         default:
+//             return ".txt";
+//     }
+// }

491755f5ae24cb4cf072e4933167e96653667e65
Author: Neekon Saadat <neekonsu@gmail.com>
Date: Mon Jul 14 15:56:49 2025
Subject: Doxygen integration complete, outputs Latex and HTML searchable documentation of annotated code, including referencer and referencee lists.

diff --git a/Doxyfile b/Doxyfile
index 590edc44..84b1f45f 100644
--- a/Doxyfile
+++ b/Doxyfile
@@ -42,39 +42,39 @@ DOXYFILE_ENCODING      = UTF-8
 # title of most generated pages and in a few other places.
 # The default value is: My Project.
 
-PROJECT_NAME           = "My Project"
+PROJECT_NAME           = "INQUIS GEN 3 DOCUMENTATION"
 
 # The PROJECT_NUMBER tag can be used to enter a project or revision number. This
 # could be handy for archiving the generated documentation or if some version
 # control system is used.
 
-PROJECT_NUMBER         =
+PROJECT_NUMBER         = 3
 
 # Using the PROJECT_BRIEF tag one can provide an optional one line description
 # for a project that appears at the top of each page and should give viewers a
 # quick idea about the purpose of the project. Keep the description short.
 
-PROJECT_BRIEF          =
+PROJECT_BRIEF          = "DOCUMENTATION OF INQUIS GEN 3 SOURCECODE"
 
 # With the PROJECT_LOGO tag one can specify a logo or an icon that is included
 # in the documentation. The maximum height of the logo should not exceed 55
 # pixels and the maximum width should not exceed 200 pixels. Doxygen will copy
 # the logo to the output directory.
 
-PROJECT_LOGO           =
+PROJECT_LOGO           = ./Inquis_3_0_GUI/favicon.ico
 
 # With the PROJECT_ICON tag one can specify an icon that is included in the tabs
 # when the HTML document is shown. Doxygen will copy the logo to the output
 # directory.
 
-PROJECT_ICON           =
+PROJECT_ICON           = ./Inquis_3_0_GUI/favicon.ico
 
 # The OUTPUT_DIRECTORY tag is used to specify the (relative or absolute) path
 # into which the generated documentation will be written. If a relative path is
 # entered, it will be relative to the location where Doxygen was started. If
 # left blank the current directory will be used.
 
-OUTPUT_DIRECTORY       =
+OUTPUT_DIRECTORY       = ./html
 
 # If the CREATE_SUBDIRS tag is set to YES then Doxygen will create up to 4096
 # sub-directories (in 2 levels) under the output directory of each output format
@@ -85,7 +85,7 @@ OUTPUT_DIRECTORY       =
 # control the number of sub-directories.
 # The default value is: NO.
 
-CREATE_SUBDIRS         = NO
+CREATE_SUBDIRS         = YES
 
 # Controls the number of sub-directories that will be created when
 # CREATE_SUBDIRS tag is set to YES. Level 0 represents 16 directories, and every
@@ -163,7 +163,7 @@ ABBREVIATE_BRIEF       = "The $name class" \
 # description.
 # The default value is: NO.
 
-ALWAYS_DETAILED_SEC    = NO
+ALWAYS_DETAILED_SEC    = YES
 
 # If the INLINE_INHERITED_MEMB tag is set to YES, Doxygen will show all
 # inherited members of a class in the documentation of that class as if those
@@ -171,7 +171,7 @@ ALWAYS_DETAILED_SEC    = NO
 # operators of the base classes will not be shown.
 # The default value is: NO.
 
-INLINE_INHERITED_MEMB  = NO
+INLINE_INHERITED_MEMB  = YES
 
 # If the FULL_PATH_NAMES tag is set to YES, Doxygen will prepend the full path
 # before files name in the file list and in the header files. If set to NO the
@@ -1237,14 +1237,14 @@ FORTRAN_COMMENT_AFTER  = 72
 # also VERBATIM_HEADERS is set to NO.
 # The default value is: NO.
 
-SOURCE_BROWSER         = NO
+SOURCE_BROWSER         = YES
 
 # Setting the INLINE_SOURCES tag to YES will include the body of functions,
 # multi-line macros, enums or list initialized variables directly into the
 # documentation.
 # The default value is: NO.
 
-INLINE_SOURCES         = NO
+INLINE_SOURCES         = YES
 
 # Setting the STRIP_CODE_COMMENTS tag to YES will instruct Doxygen to hide any
 # special comment blocks from generated source code fragments. Normal C, C++ and
@@ -1257,13 +1257,13 @@ STRIP_CODE_COMMENTS    = YES
 # entity all documented functions referencing it will be listed.
 # The default value is: NO.
 
-REFERENCED_BY_RELATION = NO
+REFERENCED_BY_RELATION = YES
 
 # If the REFERENCES_RELATION tag is set to YES then for each documented function
 # all documented entities called/used by that function will be listed.
 # The default value is: NO.
 
-REFERENCES_RELATION    = NO
+REFERENCES_RELATION    = YES
 
 # If the REFERENCES_LINK_SOURCE tag is set to YES and SOURCE_BROWSER tag is set
 # to YES then the hyperlinks from functions in REFERENCES_RELATION and
@@ -1787,7 +1787,7 @@ PAGE_OUTLINE_PANEL     = YES
 # The default value is: NO.
 # This tag requires that the tag GENERATE_HTML is set to YES.
 
-FULL_SIDEBAR           = NO
+FULL_SIDEBAR           = YES
 
 # The ENUM_VALUES_PER_LINE tag can be used to set the number of enum values that
 # Doxygen will group on one line in the generated HTML documentation.

618d11b6424c9088d906d1c4aba11cb594acaa73
Author: Neekon Saadat <neekonsu@gmail.com>
Date: Mon Jul 14 14:24:46 2025
Subject: Finished documenting common.

diff --git a/REMARKS.md b/REMARKS.md
index d3bcd7b6..17426c8e 100644
--- a/REMARKS.md
+++ b/REMARKS.md
@@ -1 +1,7 @@
-GLOVES MUST COME OFF LEAVING RND LAB, HANDS MUST BE WASHED
\ No newline at end of file
+GLOVES MUST COME OFF LEAVING RND LAB, HANDS MUST BE WASHED
+
+
+# TASKS
+
+Create pipeline for scrubbing and bundling gen 3 data
+Design database format and 
\ No newline at end of file
diff --git a/common/bbstr.c b/common/bbstr.c
index a51bfbef..5b891d65 100644
--- a/common/bbstr.c
+++ b/common/bbstr.c
@@ -36,7 +36,7 @@
 // PRIVATE TYPEDEFS
 // (Used rarely, usually destined for header files)
 // **************************************************************************************
-
+    
 // **************************************************************************************
 // STATIC VARIABLES
 // (Do start each with underscore)
@@ -61,6 +61,16 @@ int bbstrnode_global_ref_count = 0;
 // (Do NOT start with underscore)
 // **************************************************************************************
 
+/**
+ * @brief Create a new BBStr string object.
+ *
+ * Allocates a new BBStr structure with a copy of the given string (if provided)
+ * or an empty buffer of the specified length.
+ *
+ * @param s Source string to copy from, or NULL to create an empty string.
+ * @param len Length of the string to copy; use -1 to auto-calculate from s.
+ * @return Pointer to the newly created BBStr.
+ */
 BBStr *bbstr_new(char *s, int len) {
     // Create a new bbstr from an existing string or allocate empty.
     // If len < 0 (BBSTR_COPY) then it will use strlen.
@@ -93,6 +103,13 @@ BBStr *bbstr_new(char *s, int len) {
     return bbstr;
 }
 
+/**
+ * @brief Decrement reference and free BBStr if unused.
+ *
+ * Frees memory if the BBStr reference count reaches zero.
+ *
+ * @param bbstr Pointer to BBStr to delete.
+ */
 void bbstr_del(BBStr *bbstr) {
     // Delete a bbstr, decremening the reference count.
     // and deallocating if the reference is zero.
@@ -108,6 +125,12 @@ void bbstr_del(BBStr *bbstr) {
     }
 }
 
+/**
+ * @brief Increment the reference count of a BBStr.
+ *
+ * @param bbstr Pointer to BBStr.
+ * @return The same BBStr pointer with incremented reference.
+ */
 BBStr *bbstr_ref(BBStr *bbstr) {
     // Increment the reference count on a bbstr.
 
@@ -115,6 +138,12 @@ BBStr *bbstr_ref(BBStr *bbstr) {
     return bbstr;
 }
 
+/**
+ * @brief Create a malloc'd C string copy of a BBStr.
+ *
+ * @param bstr BBStr object to copy.
+ * @return Newly allocated null-terminated string.
+ */
 char *bbstr_malloc_copy(BBStr *bstr) {
     // Return a malloced copy of a bbstr.
     // This is a converter that hands code
@@ -127,6 +156,12 @@ char *bbstr_malloc_copy(BBStr *bstr) {
     return buf;
 }
 
+/**
+ * @brief Trim whitespace from both ends of a BBStr.
+ *
+ * @param bbstr Input BBStr to trim.
+ * @return A new BBStr with whitespace removed from ends.
+ */
 BBStr *bbstr_trim(BBStr *bbstr) {
     // Return a new bbstr that has whitspace trimmed on both ends.
 
@@ -144,6 +179,13 @@ BBStr *bbstr_trim(BBStr *bbstr) {
     return bbstr_new(lft, len);
 }
 
+/**
+ * @brief Get the first n characters of a BBStr.
+ *
+ * @param bbstr Input BBStr.
+ * @param n Maximum number of characters to extract.
+ * @return A new BBStr with up to n characters from the left.
+ */
 BBStr *bbstr_left(BBStr *bbstr, unsigned int n) {
     char *lft = bbstr->str;
     int len = 0;
@@ -152,6 +194,11 @@ BBStr *bbstr_left(BBStr *bbstr, unsigned int n) {
     return bbstr_new(lft, len);
 }
 
+/**
+ * @brief Create a new empty BBStrNode list.
+ *
+ * @return Pointer to a new BBStrNode with no string attached.
+ */
 BBStrNode *bbstr_list_new() {
     // Create a new (empy) list of strings.
 
@@ -163,6 +210,14 @@ BBStrNode *bbstr_list_new() {
     return new_bbstr_node;
 }
 
+/**
+ * @brief Append a BBStr to a BBStrNode list.
+ *
+ * @param list The list to append to, or NULL to start a new list.
+ * @param bbstr The BBStr to add.
+ * @param is_owner If true, sets ref_count=1 and takes ownership.
+ * @return Pointer to the new node containing the added BBStr.
+ */
 BBStrNode *bbstr_list_add(BBStrNode *list, BBStr *bbstr, int is_owner) {
     // Create a new list node for a bbstr and link it to the end of the list.
     // If list is NULL it will create a new list.
@@ -208,6 +263,12 @@ BBStrNode *bbstr_list_add(BBStrNode *list, BBStr *bbstr, int is_owner) {
     return new;
 }
 
+/**
+ * @brief Delete a single BBStrNode from the list.
+ *
+ * @param bbstr_node Node to delete.
+ * @param prev_node Previous node in the list for re-linking.
+ */
 void bbstr_list_del_node(BBStrNode *bbstr_node, BBStrNode *prev_node) {
     if (bbstr_node != NULL) {
         BBStrNode *next = bbstr_node->next;
@@ -220,6 +281,13 @@ void bbstr_list_del_node(BBStrNode *bbstr_node, BBStrNode *prev_node) {
     }
 }
 
+/**
+ * @brief Delete an entire BBStrNode list.
+ *
+ * Frees all nodes and decrements references to BBStr objects.
+ *
+ * @param bbstr_node Head of the list to delete.
+ */
 void bbstr_list_del(BBStrNode *bbstr_node) {
     // Delete an entire list.
     // Decrements references to the strings and frees nodes.
@@ -231,6 +299,13 @@ void bbstr_list_del(BBStrNode *bbstr_node) {
     }
 }
 
+/**
+ * @brief Delete nodes from list where BBStr matches given string.
+ *
+ * @param head Head of list.
+ * @param to_match Null-terminated string to match.
+ * @return Updated head pointer after deletions.
+ */
 BBStrNode *bbstr_list_del_matches(BBStrNode *head, char *to_match) {
     // Delete items where strcmp(match, node->str) == 0
     // Returns new head (which might or might not change).
@@ -257,6 +332,12 @@ BBStrNode *bbstr_list_del_matches(BBStrNode *head, char *to_match) {
     return new_head;
 }
 
+/**
+ * @brief Count number of non-null BBStr entries in a list.
+ *
+ * @param list BBStrNode list to count.
+ * @return Number of BBStr entries in list.
+ */
 int bbstr_list_count(BBStrNode *list) {
     // Return the number of elements in the list.
 
@@ -275,6 +356,14 @@ int bbstr_list_count(BBStrNode *list) {
     return count;
 }
 
+/**
+ * @brief Get the i-th BBStr string from a list or return default.
+ *
+ * @param list BBStrNode list.
+ * @param i Zero-based index.
+ * @param default_ Default string to return if index not found.
+ * @return C string from i-th BBStr, or default_ if out of bounds.
+ */
 char *bbstr_list_get(BBStrNode *list, int i, char *default_) {
     // Return the i-th element of the list as a (char *)
     // or the supplied default if not found.
@@ -286,6 +375,13 @@ char *bbstr_list_get(BBStrNode *list, int i, char *default_) {
     return default_;
 }
 
+/**
+ * @brief Get the i-th BBStr object from a list.
+ *
+ * @param list BBStrNode list.
+ * @param i Zero-based index.
+ * @return BBStr pointer at index or NULL if not found.
+ */
 BBStr *bbstr_list_get_bstr(BBStrNode *list, int i) {
     // Return the i-th element of the list as a (BBStr *)
     // or NULL if not found.
@@ -302,6 +398,14 @@ BBStr *bbstr_list_get_bstr(BBStrNode *list, int i) {
     return NULL;
 }
 
+/**
+ * @brief Split a BBStr into a list using delimiter.
+ *
+ * @param bbstr Input BBStr to split.
+ * @param delimiter Character to split on.
+ * @param should_trim If BBSTR_TRIM, trims each split part.
+ * @return Head of new BBStrNode list containing parts.
+ */
 BBStrNode *bbstr_split(BBStr *bbstr, char delimiter, int should_trim) {
     // Split a bbstr into a list by the delim and optionally trim the parts.
 
@@ -331,6 +435,13 @@ BBStrNode *bbstr_split(BBStr *bbstr, char delimiter, int should_trim) {
     return head;
 }
 
+/**
+ * @brief Join a list of BBStr objects with a delimiter.
+ *
+ * @param head Head of BBStrNode list.
+ * @param delimiter Delimiter character to insert between strings.
+ * @return A new BBStr representing the joined string.
+ */
 BBStr *bbstr_join(BBStrNode *head, char delimiter) {
     // Join a list of strings together as a new bbstr with delimiter.
 
diff --git a/common/bbstr.h b/common/bbstr.h
index 33aa080e..2af4f7a8 100644
--- a/common/bbstr.h
+++ b/common/bbstr.h
@@ -141,52 +141,147 @@ extern int bbstrnode_global_ref_count;
 // (Should NOT start with underscore)
 // **************************************************************************************
 
-// Create a new bbstr from an existing string or allocate empty.
+/**
+ * @brief Create a new BBStr string object.
+ *
+ * Allocates and returns a BBStr struct. If a string is provided,
+ * a copy is made (when len == BBSTR_COPY), otherwise a string of fixed length is allocated.
+ *
+ * @param s Source string or NULL.
+ * @param len Length of string or BBSTR_COPY.
+ * @return Pointer to newly created BBStr.
+ */
 BBStr *bbstr_new(char *s, int len);
 
-// Delete a bbstr, decremening the reference count.
+/**
+ * @brief Delete a BBStr by decrementing its reference count.
+ *
+ * Frees memory only when reference count reaches zero.
+ *
+ * @param bbstr Pointer to BBStr to delete.
+ */
 void bbstr_del(BBStr *bbstr);
 
-// Increment the reference count on a bbstr.
+/**
+ * @brief Increment the reference count on a BBStr.
+ *
+ * @param bbstr Pointer to BBStr to retain.
+ * @return Same BBStr pointer with incremented ref_count.
+ */
 BBStr *bbstr_ref(BBStr *bbstr);
 
-// Return a malloced copy of a bbstr.
+/**
+ * @brief Create a heap-allocated null-terminated string copy of a BBStr.
+ *
+ * @param bstr Pointer to BBStr to copy.
+ * @return Newly allocated C string.
+ */
 char *bbstr_malloc_copy(BBStr *bstr);
 
-// Return a new bbstr that has whitspace trimmed on both ends.
+/**
+ * @brief Trim whitespace from both ends of the given BBStr.
+ *
+ * @param bbstr Input BBStr to trim.
+ * @return New BBStr with leading/trailing whitespace removed.
+ */
 BBStr *bbstr_trim(BBStr *bbstr);
 
-// Return a new bbstr is up to the left n characters.
+/**
+ * @brief Extract up to the first n characters of a BBStr.
+ *
+ * @param bbstr Input BBStr.
+ * @param n Number of characters to include.
+ * @return New BBStr with up to n characters from the start.
+ */
 BBStr *bbstr_left(BBStr *bbstr, unsigned int n);
 
-// Create a new (empy) list of strings.
+/**
+ * @brief Create a new empty BBStrNode list.
+ *
+ * @return Pointer to a new list node with no BBStr assigned.
+ */
 BBStrNode *bbstr_list_new();
 
-// Create a new list node for a bbstr and link it to the end of the list.
+/**
+ * @brief Add a BBStr to a BBStrNode list.
+ *
+ * @param list Existing list to add to (can be NULL).
+ * @param bbstr BBStr to insert.
+ * @param is_owner If true, takes ownership of the BBStr.
+ * @return Pointer to the new node.
+ */
 BBStrNode *bbstr_list_add(BBStrNode *list, BBStr *bbstr, int is_owner);
 
-// Delete one element of a list given prevous (assumes traversing)
+/**
+ * @brief Delete a single node from the BBStrNode list.
+ *
+ * @param bbstr_node Node to delete.
+ * @param prev_node Previous node (for relinking), or NULL if head.
+ */
 void bbstr_list_del_node(BBStrNode *bbstr_node, BBStrNode *prev_node);
 
-// Delete an entire list.
+/**
+ * @brief Delete an entire BBStrNode list.
+ *
+ * Frees all nodes and adjusts reference counts.
+ *
+ * @param bbstr_node Head of the list to delete.
+ */
 void bbstr_list_del(BBStrNode *bbstr_node);
 
-// Delete items where strcmp(match, node->str) == 0
+/**
+ * @brief Delete list nodes where the BBStr string matches the given input.
+ *
+ * @param head Head of the list.
+ * @param to_match C string to match against.
+ * @return Updated head of list after deletions.
+ */
 BBStrNode *bbstr_list_del_matches(BBStrNode *head, char *to_match);
 
-// Return the number of elements in the list.
+/**
+ * @brief Count the number of BBStr entries in a list.
+ *
+ * @param list Head of BBStrNode list.
+ * @return Number of non-null entries.
+ */
 int bbstr_list_count(BBStrNode *list);
 
-// Return the i-th element of the list as a (char *)
+/**
+ * @brief Get the i-th string from a BBStrNode list.
+ *
+ * @param list List to index.
+ * @param i Zero-based index.
+ * @param default_ Default return value if out of bounds.
+ * @return Pointer to C string or default_.
+ */
 char *bbstr_list_get(BBStrNode *list, int i, char *default_);
 
-// Return the i-th element of the list as a (BBStr *)
+/**
+ * @brief Get the i-th BBStr object from a list.
+ *
+ * @param list BBStrNode list.
+ * @param i Index to retrieve.
+ * @return Pointer to BBStr or NULL if not found.
+ */
 BBStr *bbstr_list_get_bstr(BBStrNode *list, int i);
 
-// Split a bbstr into a list by the delim and optionally trim the parts.
+/**
+ * @brief Split a BBStr into a BBStrNode list based on delimiter.
+ *
+ * @param bbstr Input BBStr to split.
+ * @param delimiter Character delimiter to split on.
+ * @param should_trim Whether to trim whitespace from parts.
+ * @return Head of BBStrNode list.
+ */
 BBStrNode *bbstr_split(BBStr *bbstr, char delimiter, int should_trim);
 
-// Join a list of strings together as a new bbstr with delimiter.
+/**
+ * @brief Join a list of BBStrs with a delimiter into a new BBStr.
+ *
+ * @param head Head of list to join.
+ * @param delimiter Character to place between entries.
+ * @return Newly allocated BBStr.
+ */
 BBStr *bbstr_join(BBStrNode *head, char delimiter);
 
 #endif
diff --git a/common/cli_helpers.c b/common/cli_helpers.c
index ecdbde4a..dcd1db18 100644
--- a/common/cli_helpers.c
+++ b/common/cli_helpers.c
@@ -58,6 +58,17 @@
 // (Do NOT start with underscore)
 // **************************************************************************************
 
+/**
+ * @brief Splits a command string into whitespace-separated arguments.
+ *
+ * Parses a command string by whitespace into individual arguments.
+ * Modifies the input string in-place by inserting null terminators.
+ *
+ * @param command The input command string to parse (modified in-place).
+ * @param out_args Output array of pointers to parsed argument strings.
+ * @param max_args Maximum number of arguments to parse.
+ * @return Number of arguments successfully parsed.
+ */
 int cli_split_args(char *command, char **out_args, int max_args) {
     // Split a string by whitespace; eg: "foo bar 123" -> out_args: ["foo", "bar", "123"]
     // Writes up to max_args into out_args and returns number of split args
@@ -90,6 +101,17 @@ int cli_split_args(char *command, char **out_args, int max_args) {
     return arg_i;
 }
 
+/**
+ * @brief Parses a GPIO pin string like "A5" into GPIO block and pin number.
+ *
+ * Converts a string of format [A-G][0-15] into a GPIO_TypeDef block pointer and pin number.
+ * Supports lowercase block letters by converting them to uppercase.
+ *
+ * @param arg The string representation of the GPIO pin (e.g., "B3").
+ * @param block Output pointer to the corresponding GPIO_TypeDef block.
+ * @param pin Output pin number.
+ * @return NOERR (0) on success, -1 on invalid input.
+ */
 Err cli_parse_gpio_pin_string(char *arg, GPIO_TypeDef **block, uint16_t *pin) {
     // Convert a string like "A5" to the correct GPIO block
     // and pin number. Return 0 on success.
diff --git a/common/cli_helpers.h b/common/cli_helpers.h
index 23264fc0..ee2af1e9 100644
--- a/common/cli_helpers.h
+++ b/common/cli_helpers.h
@@ -58,7 +58,28 @@ typedef void (*CmdFuncPtr)(int argc, char **argv);
 // (Should NOT start with underscore)
 // **************************************************************************************
 
+/**
+ * @brief Splits a command string into arguments by whitespace.
+ *
+ * Parses an input command string into whitespace-delimited arguments.
+ * The original string is modified in-place with null terminators.
+ *
+ * @param command The input string to be split (modified in-place).
+ * @param out_args Array of char pointers to hold resulting arguments.
+ * @param max_args Maximum number of arguments to extract.
+ * @return Number of arguments parsed.
+ */
 int cli_split_args(char *command, char **out_args, int max_args);
+/**
+ * @brief Parses a GPIO pin string into block and pin number.
+ *
+ * Accepts a string of format like "A5" and extracts the corresponding GPIO block and pin.
+ *
+ * @param arg Input string representing GPIO pin (e.g., "C13").
+ * @param block Output pointer to the resolved GPIO_TypeDef block.
+ * @param pin Output variable for the GPIO pin number.
+ * @return NOERR on success, or an error code on failure.
+ */
 Err cli_parse_gpio_pin_string(char *arg, GPIO_TypeDef **block, uint16_t *pin);
 
 #endif
diff --git a/common/comm.c b/common/comm.c
index 4eaa074b..a1dd7f99 100644
--- a/common/comm.c
+++ b/common/comm.c
@@ -71,6 +71,13 @@ uint32_t recv_done_count = 0;
 // (Start each with underscore)
 // **************************************************************************************
 
+/**
+ * @brief Waits after UART IDLE event to allow DMA transfer to complete.
+ *
+ * Ensures enough delay after an IDLE interrupt for DMA transfer to finish
+ * so that frame processing does not occur prematurely, which could lead to
+ * CRC errors or packet loss.
+ */
 void _receive_idle_wait_for_dma() {
     // When the IDLE interrupt fires the DMA is typically not done transferring.
 
@@ -104,6 +111,13 @@ void _receive_idle_wait_for_dma() {
 
 // TODO: Clean up all these errors and add integration tests 
 
+/**
+ * @brief Callback for DMA error interrupts.
+ *
+ * Logs DMA error flags for debugging purposes.
+ *
+ * @param hdma Pointer to DMA handle where the error occurred.
+ */
 void HAL_DMA_ErrorCallback(DMA_HandleTypeDef *hdma) {
     printf("HAL_DMA_ErrorCallback\n");
     if (__HAL_DMA_GET_FLAG(hdma, DMA_FLAG_TC6)) {
@@ -120,6 +134,14 @@ void HAL_DMA_ErrorCallback(DMA_HandleTypeDef *hdma) {
     }
 }
 
+/**
+ * @brief Callback for UART error interrupts.
+ *
+ * Handles UART overrun, framing, noise, and other errors. Attempts recovery by
+ * restarting reception or flushing buffers.
+ *
+ * @param huart Pointer to UART handle where the error occurred.
+ */
 void HAL_UART_ErrorCallback(UART_HandleTypeDef *huart) {
     printf("HAL_UART_ErrorCallback: ");
 
@@ -223,6 +245,14 @@ void HAL_UART_ErrorCallback(UART_HandleTypeDef *huart) {
     comm_enable_reception();
 }
 
+/**
+ * @brief UART transmission complete callback.
+ *
+ * Called when DMA transmission is complete. Enables reception and triggers
+ * next receive call.
+ *
+ * @param huart Pointer to UART handle that finished transmitting.
+ */
 void HAL_UART_TxCpltCallback(UART_HandleTypeDef *huart) {
     // Called by the HAL when a transmission is complete.
     // This is in the context of an interrupt.
@@ -237,6 +267,13 @@ void HAL_UART_TxCpltCallback(UART_HandleTypeDef *huart) {
 }
 
 #if ! defined(CRIT_SECT_TEST) && ! defined(ATOMIC_INC_TEST)
+/**
+ * @brief Timer interrupt callback for elapsed period.
+ *
+ * Transmits packets after a delay to simulate reply timing.
+ *
+ * @param htim Timer handle which triggered the callback.
+ */
 void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim) {
     // After a bit of delay we can now send the reply.
     if (htim->Instance == TIM2) {
@@ -245,6 +282,15 @@ void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim) {
 }
 #endif
 
+/**
+ * @brief UART receive event callback for IDLE detection.
+ *
+ * Handles frame reception using DMA and verifies CRC. Decodes valid packets into
+ * the receive FIFO and optionally schedules a reply using a timer.
+ *
+ * @param huart UART handle that received data.
+ * @param size Number of bytes received.
+ */
 void HAL_UARTEx_RxEventCallback(UART_HandleTypeDef *huart, uint16_t size) {
     if (huart->ErrorCode != 0 ) {
         // TODO Proper error handling
@@ -330,6 +376,13 @@ void HAL_UARTEx_RxEventCallback(UART_HandleTypeDef *huart, uint16_t size) {
 // Global functions
 // ----------------------------------------------------------------------------------------------
 
+/**
+ * @brief Initializes communication module.
+ *
+ * Sets up CRC, FIFOs, UART hardware, and starts initial receive operation.
+ *
+ * @param comm_reply_callback Callback for packet reply handling.
+ */
 void comm_init(CommReplyCallback comm_reply_callback) {
     _comm_reply_callback = comm_reply_callback;
     crc32_init();
@@ -343,6 +396,13 @@ void comm_init(CommReplyCallback comm_reply_callback) {
     comm_recv_packets();
 }
 
+/**
+ * @brief Starts one-shot timer for reply scheduling.
+ *
+ * Configures and starts TIM2 with the specified period in milliseconds.
+ *
+ * @param period_ms Time period in milliseconds.
+ */
 void comm_timer_start(uint32_t period_ms) {
     // When the period_ms is less than 2 the timer doesn't work.
     // There's go to be some genral solution to that but I don't relaly
@@ -374,20 +434,36 @@ void comm_timer_start(uint32_t period_ms) {
     inquis_assert(err == 0);
 }
 
+/**
+ * @brief Enables DE line for RS485 transmission.
+ */
 void comm_enable_transmission() {
     HAL_GPIO_WritePin(COMM_DE_GPIO_Port, COMM_DE_Pin, GPIO_PIN_SET);
 }
 
+/**
+ * @brief Enables DE line for RS485 reception.
+ */
 void comm_enable_reception() {
     HAL_GPIO_WritePin(COMM_DE_GPIO_Port, COMM_DE_Pin, GPIO_PIN_RESET);
 }
 
+/**
+ * @brief Starts UART DMA receive-to-idle operation.
+ *
+ * Prepares UART for receiving data using DMA until an IDLE event is detected.
+ */
 void comm_recv_packets() {
     // Go into receive mode. When the serial lines goes Idle we will have received a frame.
     comm_enable_reception();
     HAL_UARTEx_ReceiveToIdle_DMA(&huart2, (uint8_t *)_recv_buffer, sizeof(_recv_buffer));
 }
 
+/**
+ * @brief Transmits packets in FIFO via UART using DMA.
+ *
+ * Encodes all available packets into a single frame with CRC and starts DMA transmission.
+ */
 void comm_xmit_packets() {
     // Copy all of the xmit packets in the FIFO into a single xmit_buffer, compute CRC, frame and start DMA xmit.
     int n_avail = fifo_n_avail(&xmit_fifo);
diff --git a/common/comm.h b/common/comm.h
index d0269412..4fb7dbbe 100644
--- a/common/comm.h
+++ b/common/comm.h
@@ -25,15 +25,32 @@
 // TYPEDEFS
 // **************************************************************************************
 
+/**
+ * @brief Callback type for handling received packets.
+ *
+ * The function takes a pointer to a Packet structure and processes it as a reply.
+ */
 typedef void (*CommReplyCallback)(Packet *);
 
 // **************************************************************************************
 // EXPORTED VARIABLES
 // **************************************************************************************
 
+/**
+ * @brief FIFO buffer for outgoing packets to be transmitted.
+ */
 extern FIFO xmit_fifo;
+/**
+ * @brief FIFO buffer for incoming received packets.
+ */
 extern FIFO recv_fifo;
+/**
+ * @brief Counter tracking completed transmissions.
+ */
 extern uint32_t xmit_done_count;
+/**
+ * @brief Counter tracking completed receptions.
+ */
 extern uint32_t recv_done_count;
 
 // **************************************************************************************
@@ -45,11 +62,35 @@ extern uint32_t recv_done_count;
 // (Should NOT start with underscore)
 // **************************************************************************************
 
+/**
+ * @brief Initializes communication interfaces and state.
+ *
+ * Sets up UART, FIFOs, and registers the packet reply callback.
+ *
+ * @param comm_reply_callback Function pointer to packet reply handler.
+ */
 void comm_init(CommReplyCallback comm_reply_callback);
+/**
+ * @brief Starts a one-shot timer for scheduling transmission delay.
+ *
+ * @param period_ms Delay in milliseconds before transmission.
+ */
 void comm_timer_start(uint32_t period_ms);
+/**
+ * @brief Enables transmission mode (e.g., RS-485 DE high).
+ */
 void comm_enable_transmission();
+/**
+ * @brief Enables reception mode (e.g., RS-485 DE low).
+ */
 void comm_enable_reception();
+/**
+ * @brief Initiates UART DMA-based reception and enables IDLE interrupt.
+ */
 void comm_recv_packets();
+/**
+ * @brief Transmits all packets in the transmit FIFO using DMA.
+ */
 void comm_xmit_packets();
 
 #endif
diff --git a/common/common.c b/common/common.c
index 5e847509..bdac05a8 100644
--- a/common/common.c
+++ b/common/common.c
@@ -81,6 +81,16 @@ int try_scope_error_handler_was_run_line = 0;
 // (Do NOT start with underscore)
 // **************************************************************************************
 
+/**
+ * @brief Error handler used by TRY macros for testing and logging.
+ *
+ * Emits debug messages and optionally tracks error details for testing purposes.
+ *
+ * @param msg   Description of the failed operation.
+ * @param err   Error code returned.
+ * @param file  Source file where the error occurred.
+ * @param line  Line number where the error occurred.
+ */
 void try_scope_error_handler(char *msg, Err err, char *file, int line) {
 #if TESTING_ENABLED == 1
     if (tests_running) {
@@ -97,11 +107,19 @@ void try_scope_error_handler(char *msg, Err err, char *file, int line) {
     emit_debug("Try-Catch Error: '%s' failed with code: %d @%s:%d\n", msg, err, file, line);
 }
 
+/**
+ * @brief Refreshes the hardware watchdog timer to prevent reset.
+ */
 void pet_watchdog() {
     extern IWDG_HandleTypeDef hiwdg;
     HAL_IWDG_Refresh(&hiwdg);
 }
 
+/**
+ * @brief Sleeps for the specified number of milliseconds while petting the watchdog.
+ *
+ * @param ms Duration in milliseconds.
+ */
 void sleep_ms(int ms) {
     // Sleep and pet the watchdog every 100ms
     while (ms > 0) {
@@ -112,21 +130,39 @@ void sleep_ms(int ms) {
     }
 }
 
+/**
+ * @brief Returns the current system time in milliseconds since boot.
+ */
 TimeMS get_time_ms() {
     // This is wrapped to avoid inclusion of the entire HAL headers into the state headers.
     return (TimeMS)HAL_GetTick();
 }
 
+/**
+ * @brief Sets the offset used for synchronized time calculations.
+ *
+ * @param time_difference_ms Offset to subtract from system time.
+ */
 void set_time_difference_ms(int time_difference_ms) {
     _time_difference_ms = time_difference_ms;
 }
 
+/**
+ * @brief Returns adjusted time with offset applied.
+ *
+ * Do not use for timers, as time may go backward.
+ */
 TimeMS get_sync_time_ms() {
     // TODO: This wil have an adjustable offset which might allow time to go backwards
     // so do not use as a timer.
     return get_time_ms() - _time_difference_ms;
 }
 
+/**
+ * @brief Halts program execution, continuously pets the watchdog.
+ *
+ * @param msg Optional message to emit before halting.
+ */
 void halt(char *msg) {
     // TODO Emit message to BOTH stdout and to SD Card streams
     if (msg) {
@@ -148,6 +184,17 @@ void halt(char *msg) {
     }
 }
 
+/**
+ * @brief Validates string buffer boundaries for safe writes and checks.
+ *
+ * Ensures pre-write and post-write constraints to prevent overflows.
+ *
+ * @param dst Destination buffer pointer.
+ * @param dst_buf_size Size of the destination buffer.
+ * @param n_chars Number of characters expected to write, or 0 to validate with strlen.
+ * @param stop_on_fail If true, halts execution on error.
+ * @return 0 if successful, or nonzero error code.
+ */
 int string_buffer_check(char *dst, int dst_buf_size, int n_chars, int stop_on_fail) {
     /*
     This function is for the "Buffer manipulation paranoia level 10" pattern
@@ -246,6 +293,10 @@ volatile unsigned int *SCB_DEMCR = (volatile unsigned int *)0xE000EDFC;
 volatile unsigned int *ITM_TER = (volatile unsigned int *)0xE0000E00;
 volatile unsigned int *ITM_TCR = (volatile unsigned int *)0xE0000E80;
 static int Debug_ITMDebug = 0;
+
+/**
+ * @brief Enables CPU cycle counter (DWT_CYCCNT) for profiling.
+ */
 void enable_timing() {
     if ((*SCB_DHCSR & 1) && (*ITM_TER & 1)) {
         Debug_ITMDebug = 1;
@@ -257,13 +308,19 @@ void enable_timing() {
     *DWT_CONTROL |= 1;     // enable the counter
 }
 
-// DWT_CYCCNT rolls over quickly so the following profiling calls are meant to be used only
-// in tight-loops where there is no chance that it rolls over more than once between _start and _stop
-
+/**
+ * @brief Stores the current DWT cycle count in out_tick.
+ */
 void get_tick(unsigned *out_tick) {
     *out_tick = *DWT_CYCCNT;
 }
 
+/**
+ * @brief Computes elapsed CPU cycles since start_tick.
+ *
+ * @param start_tick The initial tick count.
+ * @return Elapsed tick count, accounting for wraparound.
+ */
 unsigned get_tick_elapsed(unsigned start_tick) {
     unsigned stop_tick;
     get_tick(&stop_tick);
@@ -274,17 +331,36 @@ unsigned get_tick_elapsed(unsigned start_tick) {
     return stop_tick - start_tick;
 }
 
+/**
+ * @brief Converts CPU ticks to seconds.
+ *
+ * @param ticks Number of ticks.
+ * @return Duration in seconds.
+ */
 float ticks_to_seconds(unsigned ticks) {
     // Based on experiment, his clock runs at about 32,310,000 ticks per second
     unsigned int mils = ticks / 32310;
     return (float)mils / 1000.f;
 }
 
+/**
+ * @brief Converts CPU ticks to milliseconds.
+ *
+ * @param ticks Number of ticks.
+ * @return Duration in milliseconds.
+ */
 TimeMS ticks_to_ms(unsigned ticks) {
     // Based on experiment, his clock runs at about 32,310,000 ticks per second
     return (TimeMS)ticks / 32310;
 }
 
+/**
+ * @brief Fails with an assert and halts while petting the watchdog.
+ *
+ * @param msg Assertion message.
+ * @param file Source file name.
+ * @param line Line number of failure.
+ */
 void inquis_assert_failed(char *msg, char *file, int line) {
     // We use a custom version of assert here instead of the
     // standard C assert because we do not want to exit but
@@ -294,6 +370,12 @@ void inquis_assert_failed(char *msg, char *file, int line) {
     halt(buf);
 }
 
+/**
+ * @brief Prints a hexadecimal and ASCII representation of memory.
+ *
+ * @param _ptr Pointer to memory.
+ * @param n_bytes Number of bytes to dump.
+ */
 void hex_dump(void *_ptr, uint32_t n_bytes) {
     int i, j;
     int last_line_start_i = 0;
@@ -331,6 +413,9 @@ void hex_dump(void *_ptr, uint32_t n_bytes) {
     }
 }
 
+/**
+ * @brief Asserts that there is sufficient free stack space.
+ */
 void stack_check() {
     // The value of __sbrk_heap_end wil be wrong until a single malloc is called
     // extern uint8_t _estack; // Defines the bottom of the stack (which is higher in memory as the stack grows down)
@@ -341,6 +426,11 @@ void stack_check() {
     inquis_assert(stack_free_space > 512);
 }
 
+/**
+ * @brief Returns number of bytes of free heap space.
+ *
+ * @return Approximate heap space in bytes.
+ */
 int get_heap_free() {
     extern char _end; // Start of the heap
     extern char _estack; // End of the stack
@@ -348,6 +438,13 @@ int get_heap_free() {
     return (int)&_estack - (int)heap_end; // Difference between stack and heap
 }
 
+/**
+ * @brief Attempts to acquire an exclusive software lock with retry support.
+ *
+ * @param crit_sect_lock_ptr Pointer to the lock variable.
+ * @param retries Maximum number of retries before failure.
+ * @return True if lock acquired, false otherwise.
+ */
 bool crit_sect_acquire_lock(volatile uint32_t *crit_sect_lock_ptr, int retries) {
     while (1) {
         if (__LDREXW(crit_sect_lock_ptr) == 0) {        // Check if the lock is free
@@ -365,11 +462,22 @@ bool crit_sect_acquire_lock(volatile uint32_t *crit_sect_lock_ptr, int retries)
     return true;
 }
 
+/**
+ * @brief Releases a previously acquired software lock.
+ *
+ * @param crit_sect_lock_ptr Pointer to the lock variable.
+ */
 void crit_sect_release_lock(volatile uint32_t *crit_sect_lock_ptr) {
     __DMB();                 // Memory barrier to ensure all writes are completed
     *crit_sect_lock_ptr = 0; // Release the lock
 }
 
+/**
+ * @brief Verifies expected counts of allocated BBStrs and BBStrNodes.
+ *
+ * @param n_expected_bbstrs Expected BBStr object count.
+ * @param n_expected_bbstr_nodes Expected BBStrNode object count.
+ */
 void check_str_allocates(int n_expected_bbstrs, int n_expected_bbstr_nodes) {
     // To avoid/diagnose memory-leaks it is handy to
     // assert a known state of the BBStr's counters.
@@ -377,10 +485,25 @@ void check_str_allocates(int n_expected_bbstrs, int n_expected_bbstr_nodes) {
     inquis_assert(bbstrnode_global_ref_count == n_expected_bbstr_nodes);
 }
 
+/**
+ * @brief Returns true if a timer has elapsed since its start time.
+ *
+ * @param now Current time.
+ * @param timer Start time of the timer.
+ * @param duration Time duration to compare.
+ * @return True if the duration has passed.
+ */
 bool timer_elapsed(TimeMS now, TimeMS timer, TimeMS duration) {
     return (timer > 0 && now - timer > duration);
 }
 
+/**
+ * @brief Starts or resets a timer based on a predicate condition.
+ *
+ * @param predicate If true, latch the time.
+ * @param now Current time.
+ * @param timer Pointer to timer value.
+ */
 void timer_latch(bool predicate, TimeMS now, TimeMS *timer) {
     if(predicate) {
         if(*timer == 0) {
@@ -391,4 +514,3 @@ void timer_latch(bool predicate, TimeMS now, TimeMS *timer) {
         *timer = 0;
     }
 }
-
diff --git a/common/common.h b/common/common.h
index e78df9c3..49420263 100644
--- a/common/common.h
+++ b/common/common.h
@@ -87,13 +87,25 @@
 // TYPEDEFS
 // **************************************************************************************
 
+/**
+ * @typedef Err
+ * @brief Alias for integer error codes used throughout the system.
+ */
 typedef int Err;
+
+/**
+ * @typedef TimeMS
+ * @brief Unsigned 32-bit millisecond timestamp since system start.
+ */
 typedef uint32_t TimeMS;
 
 // **************************************************************************************
 // EXPORTED VARIABLES
 // **************************************************************************************
 
+/**
+ * @brief Pointer to build or firmware version string.
+ */
 extern char *version;
 
 // **************************************************************************************
@@ -101,36 +113,124 @@ extern char *version;
 // (Should NOT start with underscore)
 // **************************************************************************************
 
+/**
+ * @brief Refreshes the watchdog timer to prevent system reset.
+ */
 void pet_watchdog();
 
+/**
+ * @brief Sleeps for a specified duration while continuing to pet the watchdog.
+ *
+ * @param ms Duration in milliseconds.
+ */
 void sleep_ms(int ms);
+
+/**
+ * @brief Gets the current system uptime in milliseconds.
+ *
+ * @return Current time in milliseconds since startup.
+ */
 TimeMS get_time_ms();
+
+/**
+ * @brief Applies a time offset to synchronize system time with another source.
+ *
+ * @param time_difference_ms Time difference in milliseconds.
+ */
 void set_time_difference_ms(int time_difference_ms);
+
+/**
+ * @brief Gets the synchronized system time using the applied offset.
+ *
+ * @return Adjusted timestamp.
+ */
 TimeMS get_sync_time_ms();
 
+/**
+ * @brief Default handler for TRY macro error logging and diagnostics.
+ */
 void try_scope_error_handler(char *msg, Err err, char *file, int line);
+
+/**
+ * @brief Assertion failure handler that halts while continuing watchdog refresh.
+ */
 void inquis_assert_failed(char *msg, char *file, int line);
+
+/**
+ * @brief Halts program execution indefinitely, printing a message and petting the watchdog.
+ */
 void halt(char *msg);
 
+/**
+ * @brief Checks that a string buffer write is within safe bounds.
+ *
+ * @return 0 on success, non-zero on error.
+ */
 int string_buffer_check(char *dst, int dst_buf_size, int n_chars, int stop_on_fail);
 
+/**
+ * @brief Enables DWT cycle counter for performance profiling.
+ */
 void enable_timing();
+
+/**
+ * @brief Reads current tick value from cycle counter.
+ */
 void get_tick(unsigned *out_tick);
+
+/**
+ * @brief Returns elapsed cycles since a given tick value.
+ */
 unsigned get_tick_elapsed(unsigned start_tick);
+
+/**
+ * @brief Converts ticks to seconds based on calibrated frequency.
+ */
 float ticks_to_seconds(unsigned ticks);
+
+/**
+ * @brief Converts ticks to milliseconds.
+ */
 TimeMS ticks_to_ms(unsigned ticks);
 
+/**
+ * @brief Prints a hex and ASCII dump of a memory region.
+ */
 void hex_dump(void *ptr, uint32_t n_bytes);
 
+/**
+ * @brief Checks for minimum free stack space and asserts if too low.
+ */
 void stack_check();
+
+/**
+ * @brief Returns approximate available heap space.
+ */
 int get_heap_free();
 
+/**
+ * @brief Attempts to acquire a software-based critical section lock.
+ */
 bool crit_sect_acquire_lock(volatile uint32_t *crit_sect_lock_ptr, int retries);
+
+/**
+ * @brief Releases a critical section lock previously acquired.
+ */
 void crit_sect_release_lock(volatile uint32_t *crit_sect_lock_ptr);
 
+/**
+ * @brief Verifies string and node allocations match expected values.
+ */
 void check_str_allocates(int n_expected_bbstrs, int n_expected_bbstr_nodes);
 
+/**
+ * @brief Returns true if the given duration has elapsed since the timer started.
+ */
 bool timer_elapsed(TimeMS now, TimeMS timer, TimeMS duration);
+
+/**
+ * @brief Latches a time value if a predicate is true.
+ */
 void timer_latch(bool predicate, TimeMS now, TimeMS *timer);
 
 
diff --git a/common/config.c b/common/config.c
index af56c076..dc48a56f 100644
--- a/common/config.c
+++ b/common/config.c
@@ -186,6 +186,12 @@ char *_default_config_file_static_str = (
 #include "default_config.txt"
 );
 
+/**
+ * @brief Removes comment lines (starting with '//' or '#') from the configuration input.
+ *
+ * @param head Linked list of config lines.
+ * @return Cleaned list with comment lines removed.
+ */
 BBStrNode *_strip_comments(BBStrNode *head) {
     // Delete the lines that are comments
     // Returns new head (which might or might not change).
@@ -221,6 +227,14 @@ BBStrNode *_strip_comments(BBStrNode *head) {
     return new_head;
 }
 
+/**
+ * @brief Parses a BBStr-formatted config file into a Config struct.
+ *
+ * @param config_file_contents Configuration text as a BBStr.
+ * @param out_config Pointer to a Config struct to populate.
+ * @param check_all_fields_present If true, validates that all fields are assigned.
+ * @return 0 on success; error code or line number on failure.
+ */
 Err _parse_config_file(BBStr *config_file_contents, Config *out_config, bool check_all_fields_present) {
     // In case of error, it returns the line number (starting at 1)
 
@@ -313,6 +327,14 @@ Err _parse_config_file(BBStr *config_file_contents, Config *out_config, bool che
 // (Do NOT start with underscore)
 // **************************************************************************************
 
+/**
+ * @brief Assigns a value to a config field by key name.
+ *
+ * @param key Configuration parameter name.
+ * @param val Integer value to set.
+ * @param out_config Pointer to Config structure.
+ * @return Index of the field updated, or -1 if key is not found.
+ */
 int set_field_key_val(char *key, int val, Config *out_config) {
     // Poke a value into the structure by name.
     // Return the field number or -1 if not found.
@@ -330,6 +352,11 @@ int set_field_key_val(char *key, int val, Config *out_config) {
     return -1;
 }
 
+/**
+ * @brief Returns a default Config instance parsed from static config text.
+ *
+ * @return Pointer to a statically cached Config structure.
+ */
 Config *default_config() {
     // used especially for testing
     static Config default_config;
@@ -348,6 +375,14 @@ Config *default_config() {
     return &default_config;
 }
 
+/**
+ * @brief Loads and parses a Config object from file contents.
+ *
+ * Falls back to default_config() if parsing fails.
+ *
+ * @param config_file_contents BBStr containing the contents of a config file.
+ * @return Pointer to a Config structure.
+ */
 Config *load_config(BBStr *config_file_contents) {
     Config *ret_config = NULL;
 
@@ -379,6 +414,12 @@ Config *load_config(BBStr *config_file_contents) {
 //     inquis_assert(bbstr_global_ref_count == 0);
 // }
 
+/**
+ * @brief Serializes a Config object into a list of key=value lines.
+ *
+ * @param config Pointer to the Config structure to serialize.
+ * @return Linked list of BBStr lines representing the config.
+ */
 BBStrNode *dump_config_as_lines(Config *config) {
     char buf[256];
     BBStrNode *head = bbstr_list_new();
@@ -393,6 +434,11 @@ BBStrNode *dump_config_as_lines(Config *config) {
     return head;
 }
 
+/**
+ * @brief Logs all fields in a Config struct to the logging system.
+ *
+ * @param config Pointer to the Config structure to log.
+ */
 void dump_config_to_log(Config *config) {
     // Log the config values
     BBStrNode *lines = dump_config_as_lines(config);
diff --git a/common/config.h b/common/config.h
index a90efdb5..97fa1852 100644
--- a/common/config.h
+++ b/common/config.h
@@ -24,11 +24,20 @@
 // TYPEDEFS
 // **************************************************************************************
 
+/**
+ * @struct Config
+ * @brief Holds all configurable parameters for CMS and handle behavior.
+ *
+ * These values are loaded from a configuration file and define system behavior,
+ * thresholds, timing, LED colors, calibration values, and test rig settings.
+ * All fields must be integers. Modifications require changes in config.c:_config_names
+ * and default_config.txt.
+ */
 typedef struct {
     // DO NOT change this without updating config.c:_config_names!
     // and default_config.txt also.
 
-    // This MUST be all ints! See _set_field_key_val()
+    // This MUST be all ints! See _set_field_key_val() @TODO NOT CLEAN, USE INTERFACE TO ASSERT TYPES
 
     int cath_24F_imp_scale_factor_times_100;
     int cath_16F_imp_scale_factor_times_100;
@@ -159,6 +168,9 @@ typedef struct {
 // EXPORTED VARIABLES
 // **************************************************************************************
 
+/**
+ * @brief Filename of the default configuration file.
+ */
 extern char *default_config_filename;
 
 // **************************************************************************************
@@ -167,7 +179,21 @@ extern char *default_config_filename;
 
 #if TESTING_ENABLED == 1
 
+/**
+ * @brief Parses configuration from a BBStr buffer with field validation.
+ *
+ * @param bbstr Input buffer containing configuration data.
+ * @param out_config Output configuration structure.
+ * @param check_all_fields_present If true, requires all fields to be set.
+ * @return Error code.
+ */
 Err _parse_config_file(BBStr *bbstr, Config *out_config, bool check_all_fields_present);
+/**
+ * @brief Removes comments from a linked list of config lines.
+ *
+ * @param list Input linked list with potential comments.
+ * @return Cleaned list with comments stripped.
+ */
 BBStrNode *_strip_comments(BBStrNode *list);
 
 #endif
@@ -177,10 +203,40 @@ BBStrNode *_strip_comments(BBStrNode *list);
 // (Should NOT start with underscore)
 // **************************************************************************************
 
+/**
+ * @brief Sets a specific field in the Config struct given a key and value.
+ *
+ * @param key The name of the config parameter to set.
+ * @param val The integer value to assign to the parameter.
+ * @param out_config Pointer to the config structure to update.
+ * @return 0 on success, -1 on failure (e.g. key not found).
+ */
 int set_field_key_val(char *key, int val, Config *out_config);
+/**
+ * @brief Allocates and returns a default configuration structure.
+ *
+ * @return Pointer to a Config struct populated with default values.
+ */
 Config *default_config();
+/**
+ * @brief Parses configuration from file contents into a Config struct.
+ *
+ * @param config_file_contents Parsed text lines from the configuration file.
+ * @return Pointer to a Config struct, or NULL on error.
+ */
 Config *load_config(BBStr *config_file_contents);
+/**
+ * @brief Converts the given config into a list of key-value text lines.
+ *
+ * @param config Pointer to a Config structure.
+ * @return Linked list of lines representing the configuration.
+ */
 BBStrNode *dump_config_as_lines(Config *config);
+/**
+ * @brief Logs the current configuration parameters.
+ *
+ * @param config Pointer to the Config structure to log.
+ */
 void dump_config_to_log(Config *config);
 
 #endif
diff --git a/common/crc.c b/common/crc.c
index f47dd90a..f02abe63 100644
--- a/common/crc.c
+++ b/common/crc.c
@@ -58,6 +58,12 @@ uint32_t _crc32_table[256];
 // (Do NOT start with underscore)
 // **************************************************************************************
 
+/**
+ * @brief Initializes the CRC-32 lookup table.
+ *
+ * Precomputes a 256-entry table using the standard polynomial (0xEDB88320)
+ * to speed up CRC-32 calculation at runtime.
+ */
 void crc32_init() {
     uint32_t crc;
     for (uint32_t i = 0; i < 256; i++) {
@@ -74,6 +80,16 @@ void crc32_init() {
     }
 }
 
+/**
+ * @brief Computes CRC-32 checksum over a data buffer.
+ *
+ * Uses a precomputed lookup table for efficient CRC calculation.
+ *
+ * @param data Pointer to the data buffer to checksum.
+ * @param length Number of bytes to process.
+ * @param crc Initial CRC value (typically 0xFFFFFFFF).
+ * @return The final CRC-32 value after applying the standard final XOR.
+ */
 uint32_t crc32_calc(uint8_t *data, size_t length, uint32_t crc) {
     while (length--) {
         uint8_t byte = *data++;
diff --git a/common/default_config.txt b/common/default_config.txt
index b9fec806..73b730e7 100644
--- a/common/default_config.txt
+++ b/common/default_config.txt
@@ -1,5 +1,5 @@
 R"#(#
-# The first line must be EXACTLY as it appears above
+# The first line must be EXACTLY as it appears above TODO NOT CLEAN
 
 cath_24F_imp_scale_factor_times_100 = 100
 cath_16F_imp_scale_factor_times_100 = 70
diff --git a/common/defines.h b/common/defines.h
index db8ed185..cf1798b8 100644
--- a/common/defines.h
+++ b/common/defines.h
@@ -1,3 +1,4 @@
 // Modified by inquis_gen_3_0/build.sh
+/* @TODO NOT CLEAN */
 #define EMC 0
 #define TIP_SIZE 24
diff --git a/common/devices.c b/common/devices.c
index fe0d2a98..c24bf085 100644
--- a/common/devices.c
+++ b/common/devices.c
@@ -71,6 +71,11 @@ const int _switch_debounce_ms = 2;
 // (Do NOT start with underscore)
 // **************************************************************************************
 
+/**
+ * @brief Blinks the bright green lamp LED a specified number of times for debugging.
+ *
+ * @param n Number of times to blink the LED.
+ */
 void blink_debug_leds(int n) {
     // Blink the bright green lamp LED for debugging purposes.
     // Uses a static blink_count so that it always alternates.
@@ -83,11 +88,19 @@ void blink_debug_leds(int n) {
     }
 }
 
+/**
+ * @brief Sets the dim green debug LED on or off.
+ *
+ * @param state Non-zero to turn on, zero to turn off.
+ */
 void set_green_led(int state) {
     // Set the dim green debug led (not the lamp)
     HAL_GPIO_WritePin(MCU_DEBUG_LED_G_GPIO_Port, MCU_DEBUG_LED_G_Pin, state);
 }
 
+/**
+ * @brief Restarts the microcontroller unit (currently unused and commented out).
+ */
 void restart_mcu() {
     // HAL_GPIO_WritePin(SHDN_REGS_GPIO_Port, SHDN_REGS_Pin, 1);
     // sleep_ms(1);
@@ -97,6 +110,13 @@ void restart_mcu() {
     // }
 }
 
+/**
+ * @brief Reads pressure from the Honeywell MPRLS sensor and converts to mmHg.
+ *
+ * Maintains a simple state machine to request and retrieve sensor data.
+ * @param print_debugging If true, prints raw sensor values and error codes.
+ * @return Last successfully read pressure value in mmHg.
+ */
 int read_pressure(bool print_debugging) {
     // Return pressure in mmHg.
 
@@ -209,6 +229,12 @@ int read_pressure(bool print_debugging) {
 // Later it might turn out that we need more complex interrupt-based logic if we're
 // polling slower than the debounce speed but that logic feels more complex and probably unnecessary.
 
+/**
+ * @brief Gets the debounced state of a switch.
+ *
+ * @param switch_id Enum value indicating which switch to query.
+ * @return True if the switch is currently active, false otherwise.
+ */
 bool switch_get_state(SwitchID switch_id) {
     int curr_switch_state = -1;
     if (switch_id == SWITCH_ID_ASPIRATE) {
@@ -245,6 +271,13 @@ bool switch_get_state(SwitchID switch_id) {
 
 #if EMC_TEST == 1
 
+/**
+ * @brief Samples pressure and checks for signal deviation for EMC testing.
+ *
+ * Compares current and prior windowed means and pressure range to detect irregularities.
+ * @return True if pressure variation exceeds defined thresholds.
+ */
+
 bool emc_pressure_sample() {
 #define HALF_N_SAMPS (50)
 #define N_SAMPS (HALF_N_SAMPS * 2)
diff --git a/common/devices.h b/common/devices.h
index 953e75fb..f957d06e 100644
--- a/common/devices.h
+++ b/common/devices.h
@@ -24,6 +24,12 @@
 // TYPEDEFS
 // **************************************************************************************
 
+/**
+ * @enum SwitchID
+ * @brief Identifiers for physical switches or buttons on the device.
+ *
+ * Used to reference specific hardware switches in software.
+ */
 typedef enum {
     SWITCH_ID_ASPIRATE = 0,
     SWITCH_ID_MANUAL,
@@ -40,15 +46,59 @@ typedef enum {
 // (Should NOT start with underscore)
 // **************************************************************************************
 
+/**
+ * @brief Blinks the debug LEDs a specified number of times.
+ *
+ * @param n Number of times to blink the LEDs.
+ */
 void blink_debug_leds(int n);
+
+/**
+ * @brief Restarts the microcontroller unit (MCU).
+ */
 void restart_mcu();
+
+/**
+ * @brief Sets the state of the red LED.
+ *
+ * @param state Non-zero to turn on, zero to turn off.
+ */
 void set_red_led(int state);
+
+/**
+ * @brief Sets the state of the green LED.
+ *
+ * @param state Non-zero to turn on, zero to turn off.
+ */
 void set_green_led(int state);
+
+/**
+ * @brief Reads pressure sensor value.
+ *
+ * @param print_debugging If true, prints debug information.
+ * @return The current pressure sensor reading.
+ */
 int read_pressure(bool print_debugging);
+
+/**
+ * @brief Gets the state of a given switch.
+ *
+ * @param switch_id The switch to read.
+ * @return True if the switch is active, false otherwise.
+ */
 bool switch_get_state(SwitchID switch_id);
 
 #if EMC_TEST == 1
+/**
+ * @brief Continuously generates an audio tone for EMC testing.
+ */
 void audio_tone_continuous();
+
+/**
+ * @brief Samples pressure for EMC testing.
+ *
+ * @return True if sampling succeeded, false otherwise.
+ */
 bool emc_pressure_sample();
 #endif
 
diff --git a/common/emc.h b/common/emc.h
index cca6aa23..23d276a3 100644
--- a/common/emc.h
+++ b/common/emc.h
@@ -28,6 +28,12 @@
 // TYPEDEFS
 // **************************************************************************************
 
+/**
+ * @struct Monitor
+ * @brief Stores a fixed number of recent sample values and their associated timestamps.
+ *
+ * Used for EMC signal monitoring, retaining up to N_MONITOR_SAMPLES_MAX entries.
+ */
 typedef struct {
     int n_samples;
     float samples[N_MONITOR_SAMPLES_MAX];
@@ -56,9 +62,35 @@ extern bool emc_syringe_error;
 // (Should NOT start with underscore)
 // **************************************************************************************
 
+/**
+ * @brief Adds a new sample to the monitor, replacing the oldest if capacity is reached.
+ *
+ * @param monitor Pointer to a Monitor structure.
+ * @param sample  The sample value to add.
+ */
 void monitor_sample_add(Monitor *monitor, float sample);
+
+/**
+ * @brief Counts the number of samples collected since a given time.
+ *
+ * @param monitor     Pointer to a Monitor structure.
+ * @param time_ago_ms Time threshold in milliseconds.
+ * @return Number of samples recorded since the specified time.
+ */
 int monitor_count_since(Monitor *monitor, int time_ago_ms);
+
+/**
+ * @brief Executes the main EMC testing logic.
+ *
+ * Should be called periodically to evaluate system EMC status.
+ */
 void emc_manager();
+
+/**
+ * @brief Logs an EMC error message to the system trace.
+ *
+ * @param msg The error message string to trace.
+ */
 void emc_error_trace(char *msg);
 
 #endif
\ No newline at end of file
diff --git a/common/fifo.c b/common/fifo.c
index d112f193..91b44859 100644
--- a/common/fifo.c
+++ b/common/fifo.c
@@ -60,6 +60,14 @@
 // (Do NOT start with underscore)
 // **************************************************************************************
 
+/**
+ * @brief Initialize a FIFO structure and write DEADBEEF guards.
+ *
+ * Clears internal counters and memory, and places 0xDEADBEEF at the
+ * end of each packet for overflow detection.
+ *
+ * @param fifo Pointer to FIFO structure to initialize.
+ */
 void fifo_init(FIFO *fifo) {
     memset(fifo, 0, sizeof(FIFO));
 
@@ -87,6 +95,15 @@ Err fifo_check(FIFO *fifo) {
     return 0;
 }
 
+/**
+ * @brief Acquire a writable packet pointer from the FIFO.
+ *
+ * Attempts to lock the write interface and return a pointer to the next
+ * writable packet. Returns NULL if there is insufficient space or locking fails.
+ *
+ * @param fifo Pointer to FIFO structure.
+ * @return Pointer to writable Packet, or NULL on failure.
+ */
 Packet *fifo_writ_get_ptr(FIFO *fifo) {
     // Return the pointer to the next free packet in the FIFO
     // Return NULL in case of overflow (there being less than 2 free packets)
@@ -115,6 +132,13 @@ Packet *fifo_writ_get_ptr(FIFO *fifo) {
     return NULL;
 }
 
+/**
+ * @brief Mark the current write operation as complete.
+ *
+ * Increments internal write counters and releases the write lock.
+ *
+ * @param fifo Pointer to FIFO structure.
+ */
 void fifo_writ_done(FIFO *fifo) {
     inquis_assert(fifo->writ_lock);
 
@@ -129,6 +153,16 @@ void fifo_writ_done(FIFO *fifo) {
     crit_sect_release_lock(&fifo->writ_lock);
 }
 
+/**
+ * @brief Acquire a readable packet pointer from the FIFO.
+ *
+ * Attempts to lock the read interface and return the i-th readable packet.
+ * Returns NULL if there are not enough packets available or locking fails.
+ *
+ * @param fifo Pointer to FIFO structure.
+ * @param i Offset from current read index.
+ * @return Pointer to readable Packet, or NULL on failure.
+ */
 Packet *fifo_read_get_ptr(FIFO *fifo, int i) {
     // Return the pointer to the (next + i) packet to read if any.
     // Return NULL in case of underflow (there being no packets to read)
@@ -155,6 +189,13 @@ Packet *fifo_read_get_ptr(FIFO *fifo, int i) {
     return NULL;
 }
 
+/**
+ * @brief Mark the current read operation as complete.
+ *
+ * Increments internal read counters and releases the read lock.
+ *
+ * @param fifo Pointer to FIFO structure.
+ */
 void fifo_read_done(FIFO *fifo) {
     inquis_assert(fifo->read_lock);
 
@@ -172,10 +213,25 @@ void fifo_read_done(FIFO *fifo) {
     crit_sect_release_lock(&fifo->read_lock);
 }
 
+/**
+ * @brief Return number of packets currently in the FIFO.
+ *
+ * Computes the difference between write and read counters.
+ *
+ * @param fifo Pointer to FIFO structure.
+ * @return Number of packets currently available to read.
+ */
 uint32_t fifo_n_avail(FIFO *fifo) {
     return fifo->n_writs - fifo->n_reads;
 }
 
+/**
+ * @brief Print the contents and status of the specified FIFO.
+ *
+ * Supports printing either the receive or transmit FIFO state and memory contents.
+ *
+ * @param which Character string beginning with 'r' or 'x' to specify FIFO type.
+ */
 void fifo_dump(char *which) {
     extern FIFO recv_fifo;
     extern FIFO xmit_fifo;
diff --git a/common/fmt.c b/common/fmt.c
index d1aae3fa..ab684bde 100644
--- a/common/fmt.c
+++ b/common/fmt.c
@@ -85,6 +85,15 @@ bool dump_bin_records = false;
 // (Start each with underscore)
 // **************************************************************************************
 
+/**
+ * @brief Normalize impedance magnitude for formatting.
+ *
+ * Converts NaNs to 0.0, caps values above a hard-coded maximum,
+ * and ensures a bounded float that is safe for display formatting.
+ *
+ * @param mag_in_ohms Input magnitude in ohms.
+ * @return Clamped and normalized magnitude.
+ */
 float _normalize_mag(float mag_in_ohms) {
     // Bound a magnitude to a range from zero to epsilon less than the hard-coded maximum.
     // Converts nans to 0, infs to max.
@@ -113,6 +122,15 @@ float _normalize_mag(float mag_in_ohms) {
     return mag_in_ohms;
 }
 
+/**
+ * @brief Normalize phase angle for formatting.
+ *
+ * Converts radians to degrees and bounds the result to [-180, 180).
+ * NaNs/Infs are set to 0.0.
+ *
+ * @param phase_in_radians Input phase in radians.
+ * @return Normalized phase in degrees.
+ */
 float _normalize_phase(float phase_in_radians) {
     // Convert radians to degrees and bounds in range from -180 to 180
     // Converts nans/infs to 0
@@ -152,6 +170,16 @@ const int V1_FIELD_WIDTH =
      + 1                      // \n
     );
 
+/**
+ * @brief Format magnitude field for V1 sample output.
+ *
+ * Writes the magnitude with fixed width, zero-padded decimal format.
+ *
+ * @param mag Input magnitude in ohms.
+ * @param out_buf Output buffer for formatted string.
+ * @param buf_max_size Maximum size of the output buffer.
+ * @return Error code (0 on success).
+ */
 Err _v1_mag(float mag, char *out_buf, size_t buf_max_size) {
     Err err = 0;
     TRY_START {
@@ -172,6 +200,16 @@ Err _v1_mag(float mag, char *out_buf, size_t buf_max_size) {
     return err;
 }
 
+/**
+ * @brief Format phase field for V1 sample output.
+ *
+ * Writes the phase with fixed width, signed, zero-padded decimal format.
+ *
+ * @param phase Input phase in radians.
+ * @param out_buf Output buffer for formatted string.
+ * @param buf_max_size Maximum size of the output buffer.
+ * @return Error code (0 on success).
+ */
 Err _v1_phase(float phase, char *out_buf, size_t buf_max_size) {
     Err err = 0;
     TRY_START {
@@ -192,6 +230,18 @@ Err _v1_phase(float phase, char *out_buf, size_t buf_max_size) {
     return err;
 }
 
+/**
+ * @brief Format Sample as V1 text string.
+ *
+ * Output format: "s\tMAG\tPHASE\n" with fixed-width fields.
+ * No error samples or comments are supported in V1.
+ *
+ * @param sample Input sample to format.
+ * @param state Pointer to current state (unused in V1).
+ * @param out_buf Output buffer.
+ * @param buf_max_size Maximum size of output buffer.
+ * @return Error code.
+ */
 Err _sample_v1(Sample *sample, State *state, char *out_buf, size_t buf_max_size) {
     Err err = 0;
     TRY_START {
@@ -224,6 +274,16 @@ Err _sample_v1(Sample *sample, State *state, char *out_buf, size_t buf_max_size)
     return err;
 }
 
+/**
+ * @brief No-op for V1 comment formatter.
+ *
+ * V1 format does not support comments; returns empty string.
+ *
+ * @param comment Input comment string.
+ * @param out_buf Output buffer.
+ * @param buf_max_size Maximum size of output buffer.
+ * @return Always returns 0.
+ */
 int _comment_v1(char *comment, char *out_buf, size_t buf_max_size) {
     // No comments allowed
     if (buf_max_size >= 1) {

89e677248d62820f302f0c029af73bbb46573b7b
Author: Neekon Saadat <neekonsu@gmail.com>
Date: Mon Jul 14 12:40:43 2025
Subject: Half way through documenting all functions and stucts/enums

diff --git a/.clang-format b/.clang-format
index 3fd92623..8de7cf8e 100644
--- a/.clang-format
+++ b/.clang-format
@@ -27,4 +27,6 @@ BraceWrapping:
 # ColumnLimit: 0
 # IndentPPDirectives: BeforeHash
 
+# REMARKS: NEW SOP NEEDED FOR CODESTYLE, DOCSTRINGS, LINTER, AND UNIT TESTS. UNIT TESTS FOR ALL CORE FUNCTIONS, STATES (IN ADDITION TO AD HOC SIMULATION ON PAST DATA).
+# REMARKS: SOP AND QUIZ CREATION ACCELERATES ONBOARDING OF NEW ENGINEERS, OPENS POSSIBILITY OF AUTODOCUMENTATION, FACILITATES REGULATORY AUDITS
 ...
diff --git a/common/emc.c b/common/emc.c
index 7e32034e..c958129b 100644
--- a/common/emc.c
+++ b/common/emc.c
@@ -70,6 +70,14 @@ bool emc_syringe_error = false;
 // (Do NOT start with underscore)
 // **************************************************************************************
 
+/**
+ * @brief Add a sample to the monitor's circular buffer.
+ *
+ * Stores the sample and its timestamp, incrementing the total sample count.
+ *
+ * @param monitor Pointer to Monitor struct.
+ * @param sample New floating-point sample to record.
+ */
 void monitor_sample_add(Monitor *monitor, float sample) {
     int i = monitor->n_samples % N_MONITOR_SAMPLES_MAX;
     monitor->samples[i] = sample;
@@ -77,6 +85,15 @@ void monitor_sample_add(Monitor *monitor, float sample) {
     monitor->n_samples++;
 }
 
+/**
+ * @brief Count how many monitor samples are recent.
+ *
+ * Returns the number of samples taken within the past time_ago_ms milliseconds.
+ *
+ * @param monitor Pointer to Monitor struct.
+ * @param time_ago_ms Time window in milliseconds to count back from now.
+ * @return Number of recent samples in the window.
+ */
 int monitor_count_since(Monitor *monitor, int time_ago_ms) {
     TimeMS now = get_time_ms();
     int count = 0;
@@ -88,6 +105,12 @@ int monitor_count_since(Monitor *monitor, int time_ago_ms) {
     return count;
 }
 
+/**
+ * @brief Convert EMC error flags into visible RGB states.
+ *
+ * Called repeatedly during EMC tests to translate current error conditions
+ * into LED feedback and maintain heartbeat timing.
+ */
 void emc_manager() {
     // This is called repeated during EMC tests by both the Handle and CMS
     // Its job is to convert any of the error flags into a visible RGB state
@@ -172,6 +195,13 @@ void emc_manager() {
     _error_state = err_state;
 }
 
+/**
+ * @brief Emit an EMC error message once per second.
+ *
+ * Prints a static string message only if it has changed or 1 second has passed.
+ *
+ * @param msg Static error string to print.
+ */
 void emc_error_trace(char *msg) {
     static TimeMS last_error_time_ms = 0;
     static char *last_error_msg = NULL;
diff --git a/common/fifo.c b/common/fifo.c
index 5e3316b8..d112f193 100644
--- a/common/fifo.c
+++ b/common/fifo.c
@@ -69,6 +69,15 @@ void fifo_init(FIFO *fifo) {
     }
 }
 
+/**
+ * @brief Verify FIFO memory integrity by checking DEADBEEF guards.
+ *
+ * Ensures each packet ends with a 0xDEADBEEF marker. Returns non-zero
+ * if any packet shows memory corruption.
+ *
+ * @param fifo FIFO instance to validate.
+ * @return 0 if all guards are intact, 1 if corruption detected.
+ */
 Err fifo_check(FIFO *fifo) {
     for (int i = 0; i < N_FIFO_PACKETS; i++) {
         if (*(uint32_t *)&fifo->packets[i][PACKET_SIZE] != 0xDEADBEEF) {
diff --git a/common/fifo.h b/common/fifo.h
index c6a35d15..f6cec245 100644
--- a/common/fifo.h
+++ b/common/fifo.h
@@ -33,6 +33,12 @@
 // TYPEDEFS
 // **************************************************************************************
 
+/**
+ * @brief Circular buffer for packet exchange between microcontrollers.
+ *
+ * Manages a fixed-size FIFO queue of raw packet memory blocks, supporting
+ * concurrent read/write indices with basic locking. Used for CMS/handle communication.
+ */
 typedef struct _FIFO {
     uint32_t read_lock;
     uint32_t writ_lock;
@@ -56,13 +62,72 @@ typedef struct _FIFO {
 // (Should NOT start with underscore)
 // **************************************************************************************
 
+/**
+ * @brief Initialize a FIFO instance.
+ *
+ * Zeros all fields and prepares internal state for reading and writing.
+ *
+ * @param fifo Pointer to the FIFO to initialize.
+ */
 void fifo_init(FIFO *fifo);
+/**
+ * @brief Get a pointer to the next writable packet slot.
+ *
+ * Returns a pointer to a memory block in the FIFO for writing a new packet.
+ * Must call fifo_writ_done() after writing is finished.
+ *
+ * @param fifo FIFO instance.
+ * @return Pointer to writable packet slot, or NULL if full.
+ */
 Packet *fifo_writ_get_ptr(FIFO *fifo);
+/**
+ * @brief Mark current write slot as ready for reading.
+ *
+ * Advances the write index and increments write count.
+ *
+ * @param fifo FIFO instance.
+ */
 void fifo_writ_done(FIFO *fifo);
+/**
+ * @brief Get pointer to the ith readable packet.
+ *
+ * Provides access to a packet that has been written but not yet read.
+ *
+ * @param fifo FIFO instance.
+ * @param i Index of readable packet to access.
+ * @return Pointer to readable packet or NULL if unavailable.
+ */
 Packet *fifo_read_get_ptr(FIFO *fifo, int i);
+/**
+ * @brief Mark the oldest unread packet as consumed.
+ *
+ * Advances the read index and increments the read count.
+ *
+ * @param fifo FIFO instance.
+ */
 void fifo_read_done(FIFO *fifo);
+/**
+ * @brief Return the number of packets currently available to read.
+ *
+ * @param fifo FIFO instance.
+ * @return Number of unread packets in the queue.
+ */
 uint32_t fifo_n_avail(FIFO *fifo);
+/**
+ * @brief Scan and activate all DEADBEEF-tagged packets in FIFO.
+ *
+ * Validates packet integrity in FIFO memory and reinitializes if needed.
+ *
+ * @param fifo FIFO instance.
+ */
 void fifo_activate_packets(FIFO *fifo);
+/**
+ * @brief Print contents of FIFO for debugging.
+ *
+ * Dumps internal indices and optionally packet headers or data.
+ *
+ * @param which Label or source string for log context.
+ */
 void fifo_dump(char *which);
 
 #endif
diff --git a/common/fmt.c b/common/fmt.c
index f929cbdb..d1aae3fa 100644
--- a/common/fmt.c
+++ b/common/fmt.c
@@ -2,6 +2,8 @@
 
 TEMP REMOVED until the state machines are sorted out between handle and cms
 
+/* @TODO NOT CLEAN */
+
 //  @author  Zack Booth Simpson
 //  @date    20 Jun 2023
 //  @brief   Formats impedance Samples into a variety of versions
diff --git a/common/led_driver.c b/common/led_driver.c
index 034bc786..fc300d69 100644
--- a/common/led_driver.c
+++ b/common/led_driver.c
@@ -103,6 +103,13 @@ void _rgb_led_set_channel(int led_i, int channel_i, uint8_t val) {
 // (Do NOT start with underscore)
 // **************************************************************************************
 
+/**
+ * @brief Initialize the RGB LED driver.
+ *
+ * Resets and configures both front and rear LED controllers.
+ * Clears output channels, disables LEDs, and waits post-reset.
+ * Must be called once before setting LED colors.
+ */
 void rgb_led_init() {
     // Channel enable. 00rrggbb enable : 00010101
 
@@ -147,6 +154,17 @@ void rgb_led_init() {
     
 };
 
+/**
+ * @brief Set RGB values for the specified LED.
+ *
+ * Converts 8-bit RGB values to hardware scale, manages LED enable,
+ * and writes to hardware if values change.
+ *
+ * @param led_i LED index (0 = front, 1 = rear, 2 = both).
+ * @param r Red value (0–255).
+ * @param g Green value (0–255).
+ * @param b Blue value (0–255).
+ */
 void rgb_led_set(int led_i, uint8_t r, uint8_t g, uint8_t b) {
     inquis_assert(0 <= led_i && led_i <= 2);
     if (led_i == LED_BOTH) {
@@ -194,6 +212,13 @@ void rgb_led_set(int led_i, uint8_t r, uint8_t g, uint8_t b) {
     }
 }
 
+/**
+ * @brief Set both RGB LEDs from a packed 32-bit value.
+ *
+ * Extracts RGB components from 0xRRGGBBxx format and applies them.
+ *
+ * @param rgb Packed RGB value, top three bytes are red, green, blue.
+ */
 void rgb_led_set_both_from_int(uint32_t rgb) {
     int r = (rgb & 0xff000000) >> 24;
     int g = (rgb & 0x00ff0000) >> 16;
diff --git a/common/led_driver.h b/common/led_driver.h
index ba0fcf67..36d90523 100644
--- a/common/led_driver.h
+++ b/common/led_driver.h
@@ -37,8 +37,31 @@
 // (Should NOT start with underscore)
 // **************************************************************************************
 
+/**
+ * @brief Initialize RGB LED hardware.
+ *
+ * Configures hardware settings required for RGB LED control.
+ * Should be called once during system initialization.
+ */
 void rgb_led_init();
+/**
+ * @brief Set individual RGB LED color.
+ *
+ * Updates the specified LED's red, green, and blue intensity levels.
+ *
+ * @param led_i Index of the LED (LED_0 or LED_1).
+ * @param r Red component (0–255).
+ * @param g Green component (0–255).
+ * @param b Blue component (0–255).
+ */
 void rgb_led_set(int led_i, uint8_t r, uint8_t g, uint8_t b);
+/**
+ * @brief Set both RGB LEDs using a packed 32-bit RGB value.
+ *
+ * Applies the same RGB value to both LEDs. Useful for unified color effects.
+ *
+ * @param rgb Packed 0x00RRGGBB color value.
+ */
 void rgb_led_set_both_from_int(uint32_t rgb);
 
 #endif
diff --git a/common/lights.c b/common/lights.c
index cbc7d649..c23f86e6 100644
--- a/common/lights.c
+++ b/common/lights.c
@@ -2,7 +2,7 @@
 //  @date    17 Jan 2025
 //  @brief   Define light styles and handle flashing, etc
 
-// **************************************************************************************
+// ************************************************************************************** TODO
 // THEORY
 // (Why is does this module exist?)
 // (Why was some simpler option avoided?)
@@ -10,7 +10,7 @@
 // (What naming conventions are used?)
 // **************************************************************************************
 
-// **************************************************************************************
+// ************************************************************************************** TODO
 // INCLUDES
 // (Use double quotes, not <>)
 // (List system includes first in alphabetic order when possible)
@@ -22,30 +22,30 @@
 #include "lights.h"
 #include "led_driver.h"
 
-// **************************************************************************************
+// ************************************************************************************** TODO REMOVE
 // EXTERN VARIABLES
 // (Used rarely, usually imported via #include)
 // **************************************************************************************
 
-// **************************************************************************************
+// ************************************************************************************** TODO REMOVE
 // PRIVATE MACROS AND DEFINES
 // (Used rarely, usually destined for header files)
 // **************************************************************************************
 
-// **************************************************************************************
+// ************************************************************************************** TODO REMOVE
 // PRIVATE TYPEDEFS
 // (Used rarely, usually destined for header files)
 // **************************************************************************************
 
-// **************************************************************************************
+// ************************************************************************************** TODO REMOVE
 // STATIC VARIABLES
 // (Do start each with underscore)
 // **************************************************************************************
-
-static LightVal _curr_light_val = LIGHT_OFF;
-static bool _curr_light_on = true;
-static uint32_t _light_val_to_rgb_lut[LIGHT_N_VALS] = { 0, };
-bool _is_flashing = false;
+/* TODO: THE BELOW STATIC DEFINITIONS VIOLATE ABSTRACTION BARRIER, UNSAFE */
+static LightVal _curr_light_val = LIGHT_OFF; // TODO wrap into state, avoid explicit peripheral manipulation outside state -> major debug hole potential
+static bool _curr_light_on = true; // TODO large name overlap, needs to change, and prev remark about direct manipulation outside state.
+static uint32_t _light_val_to_rgb_lut[LIGHT_N_VALS] = { 0, }; // static variable, initialization is redundant
+bool _is_flashing = false; // TODO NOT DECLARED STATIC BUT IN STATIC SECTION ||| same suggestion, should not be manipulated globally, or document intent to initialize to defaults in this block
 
 // **************************************************************************************
 // GLOBAL VARIABLES
@@ -57,6 +57,12 @@ bool _is_flashing = false;
 // (Start each with underscore)
 // **************************************************************************************
 
+/**
+ * @brief Dump current RGB values from the light lookup table.
+ *
+ * Prints all entries in the _light_val_to_rgb_lut to stdout for debugging.
+ * Internal utility for inspecting loaded configuration values.
+ */
 void _dump_light_lut() {
     for(int i = 0; i < LIGHT_N_VALS; i++) {
         printf("Light %d: %08lX\n", i, _light_val_to_rgb_lut[i]);
@@ -70,10 +76,17 @@ void _dump_light_lut() {
 
 // #define RGB(r, g, b) (((r) << 16) | ((g) << 8) | (b))
 
-
+/**
+ * @brief Load light RGB values from system configuration.
+ *
+ * Populates the internal lookup table with RGB values for each LightVal
+ * enum based on the current system's configuration (CMS or HANDLE).
+ *
+ * @param config Pointer to the configuration struct with RGB values.
+ */
 void lights_load_rgb_vals_from_config(Config *config) {
 
-    #if defined(SUBSYSTEM_CMS)
+    #if defined(SUBSYSTEM_CMS) /* TODO should be implemented as compiler flag instead of IFDEF, harder to track and debug with IFDEF */
         _light_val_to_rgb_lut[LIGHT_OFF] = config->cms_light_off_rgb;
         _light_val_to_rgb_lut[LIGHT_CONNECTING] = config->cms_light_connecting_rgb;
         _light_val_to_rgb_lut[LIGHT_CMS_ERROR] = config->cms_light_cms_error_rgb;
@@ -88,7 +101,7 @@ void lights_load_rgb_vals_from_config(Config *config) {
         _light_val_to_rgb_lut[LIGHT_CLOGGED] = config->cms_light_clogged_rgb;
         _light_val_to_rgb_lut[LIGHT_LID_REMOVED] = config->cms_light_lid_removed_rgb;
         _light_val_to_rgb_lut[LIGHT_OUT_OF_CO2] = config->cms_light_out_of_co2_rgb;
-    #elif defined(SUBSYSTEM_HANDLE)
+    #elif defined(SUBSYSTEM_HANDLE) /* ALL OF THIS LOGIC SHOULD BE LOADED FROM HEADER, NOT IN SOURCE */
         _light_val_to_rgb_lut[LIGHT_OFF] = config->han_light_off_rgb;
         _light_val_to_rgb_lut[LIGHT_CONNECTING] = config->han_light_connecting_rgb;  // Note that this is for refe. only. Acutal value is hard coded in light_init()
         _light_val_to_rgb_lut[LIGHT_CMS_ERROR] = config->han_light_cms_error_rgb;
@@ -104,27 +117,46 @@ void lights_load_rgb_vals_from_config(Config *config) {
         _light_val_to_rgb_lut[LIGHT_LID_REMOVED] = config->han_light_lid_removed_rgb;
         _light_val_to_rgb_lut[LIGHT_OUT_OF_CO2] = config->han_light_out_of_co2_rgb;
     #else
-        #error("No subsystem defined: must be either CMS or HANDLE")
+        #error("No subsystem defined: must be either CMS or HANDLE") /* TODO: THIS ERROR SHOULD BE THROWN AT COMPILETIME/ENTRY, NOT IN SOURCE!! DANGEROUS IF CAPABLE OF COMPILING WITHOUT DEFINITION OF SUBSYSTEM */
     #endif
 
     _light_val_to_rgb_lut[LIGHT_TEST_RIG_BUTTON_PRESSED] = config->test_rig_light_button_pressed;
     _light_val_to_rgb_lut[LIGHT_TEST_RIG_LOW_PRESSURE] = config->test_rig_light_low_pressure;
     _light_val_to_rgb_lut[LIGHT_TEST_RIG_DISCONNECTED] = config->test_rig_light_disconnected;
 }
-
+/**
+ * @brief Initialize the light system with default state.
+ *
+ * Sets the initial light to flashing green (LIGHT_CONNECTING) before
+ * configuration is loaded. Intended to show startup state.
+ */
 void light_init() {
     // The initial lights are hard-coded to flashing-gren because the config is not yet loaded
     // This is the han_light_connecting_rgb hard-coded
     _light_val_to_rgb_lut[LIGHT_CONNECTING] = 0xffffff00;
     lights_set(LIGHT_CONNECTING);
 }
-
+/**
+ * @brief Convert a LightVal to its configured RGB+flash encoding.
+ *
+ * Returns the corresponding 32-bit RGB (and flashing) value from the lookup table.
+ *
+ * @param light_val The LightVal enum to convert.
+ * @return uint32_t Encoded RGB value.
+ */
 uint32_t _light_value_to_rgb(LightVal light_val) {
     inquis_assert(light_val >= 0 && light_val < LIGHT_N_VALS);
     return _light_val_to_rgb_lut[light_val];
 }
 
-
+/**
+ * @brief Set the active light state.
+ *
+ * Updates the current light and flashing state based on the specified LightVal.
+ * Ignores if val == LIGHT_REMAIN. Updates LED hardware as needed.
+ *
+ * @param val The LightVal to set.
+ */
 void lights_set(LightVal val) {
     if(val != _curr_light_val && val != LIGHT_REMAIN) {
         // Change the light
@@ -134,7 +166,14 @@ void lights_set(LightVal val) {
         rgb_led_set_both_from_int(rgbf);
     }
 }
-
+/**
+ * @brief Maintain flashing behavior for current light.
+ *
+ * Called periodically to toggle flashing lights on/off based on timing and the
+ * current RGB value's flash flag. Controls LED hardware state.
+ *
+ * @param flash_half_period_in_ms Duration of half-period for flashing.
+ */
 void lights_flash_update(int flash_half_period_in_ms) {
     // Maintain the state of the flashing light
     uint32_t rgbf = _light_val_to_rgb_lut[_curr_light_val];
diff --git a/common/lights.h b/common/lights.h
index 259fac68..d8990494 100644
--- a/common/lights.h
+++ b/common/lights.h
@@ -62,9 +62,37 @@ typedef enum {
 // (Should NOT start with underscore)
 // **************************************************************************************
 
+/**
+ * @brief Load RGB LED values from configuration.
+ *
+ * Populates internal lookup table mapping LightVal enums to RGB values
+ * based on the current system configuration.
+ *
+ * @param config Pointer to configuration data structure.
+ */
 void lights_load_rgb_vals_from_config(Config *config);
+/**
+ * @brief Set the current active light state.
+ *
+ * Updates RGB LED state based on the given LightVal.
+ *
+ * @param val The LightVal representing the desired light state.
+ */
 void lights_set(LightVal val);
+/**
+ * @brief Manage flashing state updates for LEDs.
+ *
+ * Should be called periodically to toggle flashing LEDs on or off
+ * depending on the configured half-period.
+ *
+ * @param flash_half_period_in_ms Flash half-period in milliseconds.
+ */
 void lights_flash_update(int flash_half_period_in_ms);
+/**
+ * @brief Initialize light system with startup state.
+ *
+ * Typically sets the LED to a connecting state until config is loaded.
+ */
 void light_init();
 
 #endif
diff --git a/common/log.c b/common/log.c
index 0bd52949..6cfc5a51 100644
--- a/common/log.c
+++ b/common/log.c
@@ -70,12 +70,27 @@ static WriterFuncPtr _writer_func_ptr = _default_writer_func;
 // (Do NOT start with underscore)
 // **************************************************************************************
 
+/**
+ * @brief Set the log writer function.
+ *
+ * Allows redirection of where log data is written (e.g., file, buffer).
+ *
+ * @param writer_func_ptr Pointer to a writer function accepting log data.
+ * @return The original writer function pointer.
+ */
 WriterFuncPtr log_set_writer_func(WriterFuncPtr writer_func_ptr) {
     WriterFuncPtr orig_writer_func_ptr = _writer_func_ptr;
     _writer_func_ptr = writer_func_ptr;
     return orig_writer_func_ptr;
 }
 
+/**
+ * @brief Emit a binary log record containing current system state.
+ *
+ * Sets record code and CRC before dispatching via writer function.
+ *
+ * @param log_state_record Pointer to a StateRecord to populate and emit.
+ */
 void emit_log_state_record(StateRecord *log_state_record) {
     log_state_record->code = LOG_STATE_RECORD_CODE;
     log_state_record->crc = crc32_calc(
@@ -86,6 +101,14 @@ void emit_log_state_record(StateRecord *log_state_record) {
     _writer_func_ptr(log_state_record, sizeof(StateRecord), false);
 }
 
+/**
+ * @brief Emit an error log message only once.
+ *
+ * Avoids repeated logging of identical static messages. Tracks unique
+ * pointer values to detect duplicates.
+ *
+ * @param msg Pointer to a static error message string.
+ */
 void emit_log_error_once(char *msg) {
     // Log msg as an error but only once in case it repeats
     // Assumes that msg is a static string pointer
@@ -104,6 +127,13 @@ void emit_log_error_once(char *msg) {
     emit_log_comment_record(msg);
 }
 
+/**
+ * @brief Emit one or more comment records to the log.
+ *
+ * Splits long comments across multiple binary records as needed.
+ *
+ * @param comment Null-terminated string to emit (may span records).
+ */
 void emit_log_comment_record(char *comment) {
     if (! comment) {
         return;
@@ -138,6 +168,14 @@ void emit_log_comment_record(char *comment) {
     }
 }
 
+/**
+ * @brief Emit impedance data records to the log.
+ *
+ * Breaks up PrsMagPhaSample data into multiple binary packets as needed.
+ *
+ * @param prsmagpha_samples Pointer to array of samples.
+ * @param n_samples Number of samples in the array.
+ */
 void emit_log_impedance_records(PrsMagPhaSample *prsmagpha_samples, size_t n_samples) {
     inquis_assert(sizeof(StateRecord) == sizeof(HanDataRecord));
     size_t n_remain = n_samples;
@@ -162,6 +200,14 @@ void emit_log_impedance_records(PrsMagPhaSample *prsmagpha_samples, size_t n_sam
     }
 }
 
+/**
+ * @brief Emit a formatted debug message.
+ *
+ * Formats a debug string and emits it using the writer function, tagged as debug.
+ *
+ * @param fmt Format string (like printf).
+ * @param ... Variable arguments.
+ */
 void emit_debug(char *fmt, ...) {
     va_list args;
     va_start(args, fmt);
diff --git a/common/log.h b/common/log.h
index a0275cd0..b65a0dd6 100644
--- a/common/log.h
+++ b/common/log.h
@@ -126,11 +126,61 @@ typedef void (*WriterFuncPtr)(const void *ptr, size_t size, bool is_debug);
 // (Should NOT start with underscore)
 // **************************************************************************************
 
+/**
+ * @brief Set the log writer function.
+ *
+ * Registers a custom function for handling log record output.
+ *
+ * @param writer_func_ptr Pointer to writer function taking data, size, and debug flag.
+ * @return The previous writer function pointer.
+ */
 WriterFuncPtr log_set_writer_func(WriterFuncPtr writer_func_ptr);
+
+/**
+ * @brief Emit a system state log record.
+ *
+ * Writes a binary StateRecord with CRC and log code via the writer function.
+ *
+ * @param log_state_record Pointer to populated StateRecord.
+ */
 void emit_log_state_record(StateRecord *log_state_record);
+
+/**
+ * @brief Emit a comment record to the log.
+ *
+ * Sends the provided comment string in one or more binary CommentRecords.
+ *
+ * @param comment Null-terminated comment string.
+ */
 void emit_log_comment_record(char *comment);
+
+/**
+ * @brief Emit impedance data records.
+ *
+ * Encodes and transmits impedance samples in binary format.
+ *
+ * @param prsmagpha_samples Pointer to array of impedance samples.
+ * @param n_samples Number of valid samples to log.
+ */
 void emit_log_impedance_records(PrsMagPhaSample *prsmagpha_samples, size_t n_samples);
+
+/**
+ * @brief Emit a formatted debug message.
+ *
+ * Formats and logs a debug string using the configured writer.
+ *
+ * @param fmt Format string (printf-style).
+ * @param ... Variable arguments for formatting.
+ */
 void emit_debug(char *fmt, ...);
+
+/**
+ * @brief Emit a static error message once.
+ *
+ * Ensures the same static error message is not logged repeatedly.
+ *
+ * @param msg Pointer to static error string.
+ */
 void emit_log_error_once(char *msg);
 
 
diff --git a/common/packet.c b/common/packet.c
index 0d6874e4..6c89284a 100644
--- a/common/packet.c
+++ b/common/packet.c
@@ -58,6 +58,16 @@
 // (Do NOT start with underscore)
 // **************************************************************************************
 
+
+/**
+ * @brief Dump contents of a packet for debugging.
+ *
+ * Prints the packet type, metadata, and associated fields based on the
+ * specific packet type. Supports all known packet variants defined in
+ * the PACKET_TYPE_ID enum.
+ *
+ * @param packet Pointer to a generic Packet to decode and print.
+ */
 void packet_dump(Packet *packet) {
     static char *packet_type_names[] = {
         "NONE",
diff --git a/common/packet.h b/common/packet.h
index e396edd5..c7b765d7 100644
--- a/common/packet.h
+++ b/common/packet.h
@@ -23,6 +23,12 @@
 // TYPEDEFS
 // **************************************************************************************
 
+/**
+ * @brief Enum for identifying packet types in the system.
+ *
+ * Distinguishes message types exchanged between the CMS and the handle.
+ * Order must match packet_dump() logic. Do not reorder without updating it.
+ */
 typedef enum {
     // DO NOT change without also updating packet_dump()
     PACKET_TYPE_ID_NONE = 0,
@@ -41,12 +47,24 @@ typedef enum {
     PACKET_TYPE_ID_N_IDS,
 } PacketTypeId;
 
+/**
+ * @brief Frame structure containing one or more packets.
+ *
+ * Used for transmitting multiple packets together with CRC protection.
+ * The CRC is computed over the entire frame with the crc field zeroed.
+ */
 typedef struct {
     uint32_t crc; // Includes this header (this crc field is set to zero before the crc is calculated)
     uint32_t n_packets;
     uint8_t packets[];
 } Frame;
 
+/**
+ * @brief Base structure for all packets.
+ *
+ * All specific packet types begin with this header, which includes the total
+ * size and packet type identifier.
+ */
 typedef struct {
     uint32_t n_bytes; // Includes this header
     uint32_t type_id;
@@ -56,12 +74,18 @@ typedef struct {
 // From CMS to Handle
 // --------------------------------------------
 
+/**
+ * @brief Packet sent from CMS to update the handle’s light state.
+ */
 typedef struct {
     Packet packet;
     uint32_t cms_serial_i;
     uint32_t light_val;
 } UpdateHandlePacket;
 
+/**
+ * @brief Packet sent from CMS to update the handle’s configuration.
+ */
 typedef struct {
     Packet packet;
     uint32_t config_size;
@@ -71,6 +95,9 @@ typedef struct {
     uint32_t config_serial_i;
 } UpdateConfigPacket;
 
+/**
+ * @brief Packet sent from CMS requesting an echo response from handle.
+ */
 typedef struct {
     Packet packet;
     uint32_t cms_serial_i;
@@ -80,6 +107,9 @@ typedef struct {
 // From Handle to CMS
 // --------------------------------------------
 
+/**
+ * @brief Packet sent from handle to CMS containing status telemetry.
+ */
 typedef struct {
     Packet packet;
     uint32_t handle_state;
@@ -99,6 +129,9 @@ typedef struct {
     uint32_t config_serial_i;
 } HandleStatusPacket;
 
+/**
+ * @brief Packet sent from handle to CMS with impedance samples.
+ */
 typedef struct {
     Packet packet;
     uint32_t n_samples;
@@ -106,12 +139,18 @@ typedef struct {
     PrsMagPhaSample prsmagpha_samples[];
 } SamplesPacket;
 
+/**
+ * @brief Echo response packet from handle to CMS.
+ */
 typedef struct {
     Packet packet;
     uint32_t cms_serial_i;
     uint32_t code;
 } EchoReplyPacket;
 
+/**
+ * @brief Packet confirming handle has received and parsed configuration.
+ */
 typedef struct {
     Packet packet;
     uint32_t config_crc;
@@ -133,6 +172,13 @@ typedef struct {
 // (Should NOT start with underscore)
 // **************************************************************************************
 
+/**
+ * @brief Dump the contents of a packet to stdout.
+ *
+ * Decodes and prints packet fields based on the packet type.
+ *
+ * @param packet Pointer to the packet to inspect.
+ */
 void packet_dump(Packet *packet);
 
 #endif
diff --git a/common/retarget.c b/common/retarget.c
index 18bc1453..8a0bb5c5 100644
--- a/common/retarget.c
+++ b/common/retarget.c
@@ -176,6 +176,14 @@ HAL_StatusTypeDef _uart_await(
 // (Do NOT start with underscore)
 // **************************************************************************************
 
+/**
+ * @brief Initialize stdio retargeting to UART.
+ *
+ * Sets the global UART handle and disables stdout buffering so that output
+ * is sent immediately. Enables printf/putchar over serial.
+ *
+ * @param huart Pointer to initialized UART handle.
+ */
 void retarget_init(UART_HandleTypeDef *huart) {
     printf("%p\n", huart);
     _gHuart = huart;
@@ -185,6 +193,15 @@ void retarget_init(UART_HandleTypeDef *huart) {
     setvbuf(stdout, NULL, _IONBF, 0);
 }
 
+/**
+ * @brief Non-blocking line input from UART.
+ *
+ * Reads characters from UART input buffer and accumulates them into a static
+ * line buffer. Returns a completed command string (ending in '\r') or NULL
+ * if no full line is available yet.
+ *
+ * @return Pointer to complete line string, or NULL if not ready.
+ */
 char *nonblocking_line_input() {
     // Returns a the command if \r\n or NULL if
     // command not complete (ie: non-blocking)
@@ -255,6 +272,14 @@ char *nonblocking_line_input() {
     return ret;
 }
 
+/**
+ * @brief Non-blocking single character input from UART.
+ *
+ * Attempts to read one character from UART input if available. Returns the
+ * character if present or 0 if no input is pending.
+ *
+ * @return A character from UART, or 0 if none received.
+ */
 char nonblocking_char_input() {
     // Returns a character or zero if nothing is pending
     char ret = 0;
diff --git a/common/retarget.h b/common/retarget.h
index 283aa564..c94c625e 100644
--- a/common/retarget.h
+++ b/common/retarget.h
@@ -31,8 +31,19 @@
 // (Should NOT start with underscore)
 // **************************************************************************************
 
+
+/**
+ * @brief Initialize stdio retargeting for UART output.
+ *
+ * Sets up the UART handle used for printf and related functions.
+ * Disables stdout buffering for immediate output.
+ *
+ * @param huart Pointer to UART handle.
+ */
 void retarget_init(UART_HandleTypeDef *huart);
 
+
+// These override system-level stdio functions to enable UART redirection
 // Note these MUST start with underscores because they
 // replace stdio implementations of the same functions.
 int _isatty(int fd);
@@ -42,7 +53,24 @@ int _lseek(int fd, int ptr, int dir);
 int _read(int fd, char *ptr, int len);
 int _fstat(int fd, struct stat *st);
 
+
+/**
+ * @brief Read a full line from UART input without blocking.
+ *
+ * Accumulates characters until a carriage return ('\r') is received.
+ * Returns the line as a static buffer, or NULL if incomplete.
+ *
+ * @return Pointer to complete line or NULL if not ready.
+ */
 char *nonblocking_line_input();
+
+/**
+ * @brief Read one character from UART input without blocking.
+ *
+ * Returns the next character if available, or 0 if none present.
+ *
+ * @return A single character, or 0 if no input.
+ */
 char nonblocking_char_input();
 
 #endif
diff --git a/common/sample_err.h b/common/sample_err.h
index 15a32220..e276c4c8 100644
--- a/common/sample_err.h
+++ b/common/sample_err.h
@@ -11,6 +11,12 @@
 // (Note when order is important)
 // **************************************************************************************
 
+/**
+ * @brief Error codes for validating Sample acquisition.
+ *
+ * Each code indicates a specific failure mode in reading or parsing
+ * data from the sample FIFO or sensor interface.
+ */
 // **************************************************************************************
 // MACROS AND DEFINES
 // **************************************************************************************
@@ -35,6 +41,11 @@
 // TYPEDEFS
 // **************************************************************************************
 
+/**
+ * @brief Alias for sample error code type.
+ *
+ * Used to represent values from the SAMPLE_ERR_* enum-like macros.
+ */
 typedef int SampleErr;
 
 // **************************************************************************************
diff --git a/common/sample_type.h b/common/sample_type.h
index 58111994..c1fd3182 100644
--- a/common/sample_type.h
+++ b/common/sample_type.h
@@ -30,15 +30,23 @@
 // TYPEDEFS
 // **************************************************************************************
 
-typedef uint32_t ImpRaw[4];
-typedef uint32_t BatVolts;
-typedef uint32_t TimeInMS;
-
+/**
+ * @brief Represents a magnitude and phase pair.
+ *
+ * Used for impedance measurements and calibration values.
+ */
 typedef struct {
     float mag;
     float pha;
 } MagPhase;
 
+/**
+ * @brief Full data structure representing a single sample record.
+ *
+ * Contains raw impedance data, processed magnitude/phase values,
+ * battery voltage, timestamp, user switch state, and error codes.
+ * Used in binary logging and transmitted as SampleRecords.
+ */
 typedef struct {
     uint8_t record_type;                // Size=1. Must be zero to differentate these records from comments
     uint8_t version;                    // Size=1. Increment whenever this structure changes
@@ -54,6 +62,12 @@ typedef struct {
     TimeInMS time_in_ms;                // Size=4.
 } Sample;
 
+/**
+ * @brief Compact impedance sample with pressure and compressed mag/pha.
+ *
+ * Used for transmitting multiple samples efficiently from the handle.
+ * Includes pressure, encoded impedance index/error, and 16-bit mag/pha.
+ */
 typedef struct {
     uint32_t pressure;
     uint32_t i_and_err;
diff --git a/common/state_defs.c b/common/state_defs.c
index 342caa80..ee9af7b7 100644
--- a/common/state_defs.c
+++ b/common/state_defs.c
@@ -44,6 +44,12 @@
 // (Do NOT start with underscore)
 // **************************************************************************************
 
+/**
+ * @brief Full names for CMS piston state values.
+ *
+ * Maps each PistonStateVal enum to its corresponding descriptive string.
+ * Must match order of PistonStateVal in cms_state.h.
+ */
 char *cms_piston_state_val_names[] = {
     // Do not change witout also changing PistonStateVal in cms_state.h
     "00_START",
@@ -64,6 +70,12 @@ char *cms_piston_state_val_names[] = {
     "92_SYSTEM_ERROR",
 };
 
+/**
+ * @brief Abbreviated names for CMS piston state values.
+ *
+ * Short string identifiers for UI/logging corresponding to PistonStateVal.
+ * Must match order of cms_piston_state_val_names.
+ */
 char *cms_piston_state_val_abbr[] = {
     // Do not change witout also changing the above
     "00_START",
@@ -84,6 +96,12 @@ char *cms_piston_state_val_abbr[] = {
     "92_SYS_ERR",
 };
 
+/**
+ * @brief Full names for CMS LED state values.
+ *
+ * Maps each LedStateVal to a descriptive label string.
+ * Must be kept in sync with LedStateVal in cms_state.h.
+ */
 char *cms_led_state_val_names[] = {
     // Do not change witout also changing LedStateVal in cms_state.h
     "000_START",
@@ -104,6 +122,12 @@ char *cms_led_state_val_names[] = {
     "900_VACUUM_STATE_CYCLE",
 };
 
+/**
+ * @brief Abbreviated names for CMS LED state values.
+ *
+ * Used for compact representations of LED states in logs or UI.
+ * Must match order of cms_led_state_val_names.
+ */
 char *cms_led_state_val_abbr[] = {
     // Do not change witout also changing LedStateVal in cms_state.h
     "000_START",
@@ -124,6 +148,11 @@ char *cms_led_state_val_abbr[] = {
     "900_VAC_CYC"
 };
 
+/**
+ * @brief Full names for audio state values.
+ *
+ * Labels representing each AudioStateVal enum for diagnostics or UI.
+ */
 char *audio_state_val_names[] = {
     "00000_START",
     "10000_LOAD_SOUNDS",
@@ -134,6 +163,11 @@ char *audio_state_val_names[] = {
     "40002_BLEED_PATH_SOUND",
 };
 
+/**
+ * @brief Abbreviated names for audio state values.
+ *
+ * Shorter string identifiers used in debugging output or summaries.
+ */
 char *audio_state_val_abbr[] = {
     "00000_STRT",
     "10000_LOAD",
@@ -144,6 +178,11 @@ char *audio_state_val_abbr[] = {
     "40002_BLED",
 };
 
+/**
+ * @brief Full names for light state values.
+ *
+ * Human-readable strings mapping to LightVal enum values.
+ */
 char *light_val_names[] = {
     "LIGHT_OFF",
     "LIGHT_CONNECTING",
@@ -164,6 +203,11 @@ char *light_val_names[] = {
     "LIGHT_TEST_RIG_DISCONNECTED",
 };
 
+/**
+ * @brief Abbreviated names for light state values.
+ *
+ * Compact labels used for LightVal enum entries in debug/log output.
+ */
 char *light_val_abbr[] = {
     "OFF",
     "CONECT",
@@ -184,6 +228,12 @@ char *light_val_abbr[] = {
     "RIG_DISCON",
 };
 
+/**
+ * @brief Full names for handle impedance state values.
+ *
+ * Maps enum values in HanImpStateVal to full string names.
+ * Must align with state_defs.h.
+ */
 char *han_imp_state_val_names[] = {
     // Do not change this without reconciling with string table in state_defs.h
     "0_UNKNOWN",
@@ -194,6 +244,11 @@ char *han_imp_state_val_names[] = {
     "5_OPEN_CIRCUIT",
 };
 
+/**
+ * @brief Abbreviated names for handle impedance state values.
+ *
+ * Shortened labels for HanImpStateVal used in logs or user display.
+ */
 char *han_imp_state_val_abbr[] = {
     // Do not change this without reconciling with string table in state_defs.h
     "0_UNK",
@@ -204,6 +259,11 @@ char *han_imp_state_val_abbr[] = {
     "5_OPEN",
 };
 
+/**
+ * @brief Full names for handle state values.
+ *
+ * Maps HandleStateVal to descriptive labels. Must stay synced with han_state_defs.c.
+ */
 char *han_state_val_names[] = {
     // Do not change this without reconciling with string table in han_state_defs.c
     "0000_START",
@@ -219,6 +279,11 @@ char *han_state_val_names[] = {
     "6002_WALL_LATCH_DELAY",
 };
 
+/**
+ * @brief Abbreviated names for handle state values.
+ *
+ * Compact versions of handle state strings used in logs and debug output.
+ */
 char *han_state_val_abbr[] = {
     // Do not change this without reconciling with string table in han_state_defs.c
     "0000_STRT",
diff --git a/common/state_defs.h b/common/state_defs.h
index b62470cf..804b4632 100644
--- a/common/state_defs.h
+++ b/common/state_defs.h
@@ -22,6 +22,12 @@
 // TYPEDEFS
 // **************************************************************************************
 
+/**
+ * @brief Enumerates all CMS piston motion and error states.
+ *
+ * Each state represents a phase of motion or fault condition in the piston system.
+ * Do not reorder without updating associated name/abbr tables in cms_state.c.
+ */
 typedef enum {
     // Do not change witout also changing cms_piston_state_val_names & cms_piston_state_val_abbr in cms_state.c
     PISTON_STATE_REMAIN = -1,
@@ -44,6 +50,12 @@ typedef enum {
     PISTON_STATE_N_STATES,
 } PistonStateVal;
 
+/**
+ * @brief Enumerates all CMS LED display states.
+ *
+ * Reflects system status and transitions shown via RGB lights.
+ * Must match naming tables in state_defs.c.
+ */
 typedef enum {
     // Do not change this without reconciling with cms_led_state_val_names & cms_led_state_val_abbr in state_defs.c
     LED_STATE_REMAIN = -1,
@@ -66,6 +78,12 @@ typedef enum {
     LED_N_STATES,
 } LedStateVal;
 
+/**
+ * @brief Enumerates all CMS audio states.
+ *
+ * Defines audio cues for system phases like clot detection or bleed path.
+ * Do not reorder without updating string tables in state_defs.c.
+ */
 typedef enum {
     // Do not change this without reconciling with string table in state_defs.c
     AUDIO_STATE_REMAIN = -1,
@@ -79,6 +97,12 @@ typedef enum {
     AUDIO_STATE_N_STATES,
 } AudioStateVal;
 
+/**
+ * @brief Enumerates impedance classification states for the handle.
+ *
+ * Used to classify impedance readings into physiological states.
+ * Synced with han_imp_state_val_names in state_defs.c.
+ */
 typedef enum {
     // Do not change this without reconciling with string table han_imp_state_val_names in state_defs.c
     HAN_IMP_STATE_0_UNKNOWN = 0,
@@ -89,6 +113,12 @@ typedef enum {
     HAN_IMP_STATE_5_OPEN_CIRCUIT,
 } HanImpStateVal;
 
+/**
+ * @brief Enumerates top-level state machine values for the handle.
+ *
+ * Controls the handle's overall operating mode, from connection to aspiration.
+ * Must align with name tables in han_state_defs.c.
+ */
 typedef enum {
     // Do not change this without reconciling with string table in han_state_defs.c
     HAN_STATE_REMAIN = -1,
diff --git a/common/test_define.h b/common/test_define.h
index 50197e8e..062e5a25 100644
--- a/common/test_define.h
+++ b/common/test_define.h
@@ -1,4 +1,4 @@
 // This file should be included by any file that refers to TESTING_ENABLED
 // It should be included before any other non-stdlib includes
-
+/* @TODO NOT CLEAN */
 #define TESTING_ENABLED 1
\ No newline at end of file
diff --git a/common/test_helpers.c b/common/test_helpers.c
index d28a6cb1..f944e831 100644
--- a/common/test_helpers.c
+++ b/common/test_helpers.c
@@ -80,6 +80,17 @@ int inttest_force_handle_n_packets_avail_to_zero = 0;
 // (Do NOT start with underscore)
 // **************************************************************************************
 
+/**
+ * @brief Assert a test predicate and log failure with location.
+ *
+ * Fails the test if the predicate is false, prints the provided message,
+ * and marks the global `tests_failed` flag.
+ *
+ * @param predicate Condition to assert.
+ * @param msg Description of the check.
+ * @param file Source filename (usually __FILE__).
+ * @param line Source line number (usually __LINE__).
+ */
 void test_helper_check(int predicate, char *msg, char *file, int line) {
     if (! predicate) {
         printf("\e[31mFAIL\e[m '%s' @%s:%d\n", msg, file, line);
@@ -87,6 +98,17 @@ void test_helper_check(int predicate, char *msg, char *file, int line) {
     }
 }
 
+/**
+ * @brief Assert that two strings are equal.
+ *
+ * Compares expected and actual strings, logs failure if they differ or are NULL,
+ * and sets the `tests_failed` flag accordingly.
+ *
+ * @param got The actual string.
+ * @param expected The expected string.
+ * @param file Source file where check is made.
+ * @param line Line number of check site.
+ */
 void test_helper_check_str_equal(char *got, char *expected, char *file, int line) {
     if (! got) {
         printf("\e[31mFAIL\e[m check_str_equal 'got' is NULL @%s:%d\n", file, line);
@@ -105,6 +127,15 @@ void test_helper_check_str_equal(char *got, char *expected, char *file, int line
     }
 }
 
+/**
+ * @brief Countdown helper for triggering events after N calls.
+ *
+ * Decrements the value pointed to by counter. When it reaches 1,
+ * returns 1 and resets the counter to 0. Otherwise returns 0.
+ *
+ * @param counter Pointer to an integer counter variable.
+ * @return 1 if this is the trigger call, 0 otherwise.
+ */
 int test_integration_variable(int *counter) {
     // >1: Number of calls before the event should happen
     // =1: The call should happen now
@@ -120,6 +151,12 @@ int test_integration_variable(int *counter) {
 }
 #endif
 
+/**
+ * @brief Reset selected integration test variables to defaults.
+ *
+ * Clears global integration test hooks and flags. Only enabled if
+ * TESTING_ENABLED == 1. Used to prepare for clean test runs.
+ */
 void test_integration_clear_all() {
     #if TESTING_ENABLED == 1
         // inttest_inject_sdcard_write_error = 0;
diff --git a/common/test_helpers.h b/common/test_helpers.h
index a7d9b4da..8fbdd7d0 100644
--- a/common/test_helpers.h
+++ b/common/test_helpers.h
@@ -89,9 +89,47 @@ extern int try_scope_error_handler_was_run_line;
 // (Should NOT start with underscore)
 // **************************************************************************************
 
+
+/**
+ * @brief Assert that a condition is true during testing.
+ *
+ * Logs a failure message with file and line number if the condition is false.
+ *
+ * @param predicate Boolean condition to check.
+ * @param msg String representation of the condition.
+ * @param file Source file name (__FILE__).
+ * @param line Source line number (__LINE__).
+ */
 void test_helper_check(int predicate, char *msg, char *file, int line);
+
+/**
+ * @brief Assert that two strings are equal in test validation.
+ *
+ * If the strings differ or are NULL, logs the mismatch and triggers test failure.
+ *
+ * @param a Actual string.
+ * @param b Expected string.
+ * @param file Source file name (__FILE__).
+ * @param line Source line number (__LINE__).
+ */
 void test_helper_check_str_equal(char *a, char *b, char *file, int line);
+
+/**
+ * @brief Countdown trigger used for integration test events.
+ *
+ * Decrements a counter and returns 1 when it hits 1. Returns 0 otherwise.
+ * Used to delay or trigger test events after a set number of calls.
+ *
+ * @param counter Pointer to countdown variable.
+ * @return 1 when counter reaches 1, 0 otherwise.
+ */
 int test_integration_variable(int *counter);
+
+/**
+ * @brief Clear all integration test hook variables.
+ *
+ * Resets counters and global state used to inject test conditions.
+ */
 void test_integration_clear_all();
 
 #endif
diff --git a/common/track_stats.c b/common/track_stats.c
index cb4ad5c9..b358807b 100644
--- a/common/track_stats.c
+++ b/common/track_stats.c
@@ -5,6 +5,13 @@
 
 const int print_time_ms = 10000;
 
+/**
+ * @brief Track and periodically print handle sample acquisition stats.
+ *
+ * Accumulates total sample count and prints stats every 10 seconds.
+ *
+ * @param n_samples_avail Number of new handle samples acquired.
+ */
 void track_han_stats(int n_samples_avail) {
     static TimeMS last_stats_ms = 0;
     static int n_samples = 0;
@@ -20,6 +27,15 @@ void track_han_stats(int n_samples_avail) {
     }
 }
 
+/**
+ * @brief Track and print CMS packet statistics per packet type.
+ *
+ * Accumulates counts and byte totals for each packet type and prints
+ * summary stats every 10 seconds. Resets counters after printing.
+ *
+ * @param type_id Packet type identifier (0–15).
+ * @param n_bytes Number of bytes in this packet.
+ */
 void track_cms_packet_stats(int type_id, int n_bytes) {
     static TimeMS last_stats_ms = 0;
     static int n_packets_by_type[16] = {0,};
@@ -53,6 +69,13 @@ void track_cms_packet_stats(int type_id, int n_bytes) {
     }
 }
 
+/**
+ * @brief Track and report CMS impedance sample throughput.
+ *
+ * Tracks total samples received and prints rate every 10 seconds.
+ *
+ * @param n_samples Number of new impedance samples.
+ */
 void track_cms_imp_stats(int n_samples) {
     static TimeMS last_stats_ms = 0;
     static int n_samples_total = 0;
@@ -68,6 +91,15 @@ void track_cms_imp_stats(int n_samples) {
     }
 }
 
+/**
+ * @brief Track and print CMS log record throughput.
+ *
+ * Aggregates number of log records and bytes received, printing
+ * rate stats every 10 seconds.
+ *
+ * @param n_log_recs Number of log records received.
+ * @param n_bytes Total bytes received across all records.
+ */
 void track_cms_log_stats(int n_log_recs, int n_bytes) {
     static TimeMS last_stats_ms = 0;
     static int n_log_recs_total = 0;
diff --git a/common/track_stats.h b/common/track_stats.h
index 8463f026..695cc6f8 100644
--- a/common/track_stats.h
+++ b/common/track_stats.h
@@ -1,9 +1,42 @@
 #ifndef TRACK_STATS_H
 #define TRACK_STATS_H
 
+/**
+ * @brief Track handle sample acquisition rate.
+ *
+ * Periodically prints stats on number of handle samples received.
+ *
+ * @param n_samples_avail Number of new samples received.
+ */
 void track_han_stats(int n_samples_avail);
+
+/**
+ * @brief Track CMS packet count and byte throughput.
+ *
+ * Aggregates and periodically prints CMS packet type statistics.
+ *
+ * @param type_id CMS packet type identifier.
+ * @param n_bytes Size of the packet in bytes.
+ */
 void track_cms_packet_stats(int type_id, int n_bytes);
+
+/**
+ * @brief Track number of CMS impedance samples received.
+ *
+ * Aggregates sample rate statistics and prints periodically.
+ *
+ * @param n_samples Number of samples received.
+ */
 void track_cms_imp_stats(int n_samples);
+
+/**
+ * @brief Track CMS log record throughput.
+ *
+ * Collects and prints statistics on binary log records.
+ *
+ * @param n_log_recs Number of log records received.
+ * @param n_bytes Total size of log data in bytes.
+ */
 void track_cms_log_stats(int n_log_recs, int n_bytes);
 
 #endif
\ No newline at end of file
diff --git a/env_lab.sh b/env_lab.sh
index 56683aaa..aff6ad5b 100644
--- a/env_lab.sh
+++ b/env_lab.sh
@@ -1,2 +1,3 @@
 export PATH="$PATH:/Applications/STM32CubeIDE.app/Contents/Eclipse/plugins/com.st.stm32cube.ide.mcu.externaltools.gnu-tools-for-stm32.13.3.rel1.macos64_1.0.0.202411102158/tools/bin"
 export PATH="$PATH:/Applications/STMicroelectronics/STM32Cube/STM32CubeProgrammer/STM32CubeProgrammer.app/Contents/MacOs/bin"
+# REMARKS: HARDCODED PATHS NOT SUSTAINABLE, MOVE TO CONTAINER
\ No newline at end of file
diff --git a/format.sh b/format.sh
index 3835f03b..436f62d5 100644
--- a/format.sh
+++ b/format.sh
@@ -1,5 +1,5 @@
 #!/usr/bin/env bash
-
+# CALLS LINTER ON SOURCE DIRECTORIES
 directories=(
     "./handle/inquis"
     "./handle/inquis/unit_tests"
@@ -21,4 +21,5 @@ for dir in "${directories[@]}"; do
     if compgen -G "$dir/*.h" > /dev/null; then
         clang-format -i "$dir"/*.h
     fi
-done
\ No newline at end of file
+done
+# REMARKS: ROOT LEVEL JSON FILE(S) DEFINING SERIAL NUMBERS, ENV VARS, ERROR CODES, & STORING FILEPATHS BY ROLE MAPS REPOSITORY WITH VC, ENABLES SEPARATION OF PATH DECLARATIONS FROM PACKAGING/BUILDTIME SCRIPTS
\ No newline at end of file
diff --git a/package.sh b/package.sh
index 4c9c62d2..313c1936 100755
--- a/package.sh
+++ b/package.sh
@@ -3,6 +3,10 @@
 # Functions
 # ----------------------------------------------------------------------------
 
+# Function: check_env
+# Description: Checks root according to existence of cms and handle directories, different than check for buildfile as in update.sh. Checks for gcc in PATH
+# Arguments: None
+# Returns: None or exit 1 on err
 check_env() {
     # Check in root
     if [ ! -d "./cms" ] || [ ! -d "./handle" ]; then
@@ -17,6 +21,10 @@ check_env() {
     fi
 }
 
+# Function: error
+# Description: Locally declares colors, outputs error MSG in BOLD RED to TERM
+# Arguments: {("MSG", "FIRST ARG, STORES ERROR MESSAGE PASSED BY PARENT FUNCTION")}
+# Returns: None
 error() {
     local RED='\033[1;31m'  # Bold Red
     local RESET='\033[0m'   # Reset to default terminal color
@@ -27,6 +35,10 @@ error() {
     echo -e "****************************************${RESET}"
 }
 
+# Function: add_or_create_zip_file
+# Description: Calls 'zip -qj' to zip specified file to specified output.
+# Arguments: {("INPUT","FIRST ARG, INPUT FILEPATH"),("OUTPUT","SECOND ARG, OUTPUT FILEPATH")}
+# Returns: None or exit 1 on err
 add_or_create_zip_file() {
     local input="$1"
     local output="$2"
@@ -44,6 +56,10 @@ add_or_create_zip_file() {
     zip -q -j "$output" "$input"
 }
 
+# Function: copy_with_verification
+# Description: Implements copy operation with paranoid level of checks to ensure correct file copied without error.
+# Arguments: {("SRC","FIRST ARG, SOURCE FILE"),("DST","SECOND ARG, DESTINATION FILE")}
+# Returns: None or exit 1 on err
 copy_with_verification() {
     # There is a mysterious bug on my Windows config where I would
     # copy a file and about 1/3 of the time the file would not copy correctly
@@ -92,6 +108,10 @@ copy_with_verification() {
     return 1
 }
 
+# Function: build_and_zip  
+# Description: Build from source and zip output to appropriate directory.
+# Arguments: {("TIP_SIZE","FIRST ARG, SIZE OF TIP"),("DFST_ZIP_FILENAME","SECOND ARG, SETS DESTINATION ZIP FILENAME")}
+# Returns: None or exit 1 on err - side-effect: creates zipped compiled code
 build_and_zip() {
     local tip_size=$1
     local dst_zip_filename=$2
@@ -134,12 +154,12 @@ EOF
 # main
 # =============================================================================
 
-clear
+clear # Why? Redundant
 
 # Env check
 # ----------------------------------------------------------------------------
 
-check_env
+check_env # REMARK: IMPROVE SPECIFICITY OF ENV CHECK FOR FUTURE
 
 ORIGINAL_DIR=$(pwd)
 
@@ -152,7 +172,7 @@ fi
 
 # Args handling
 # ----------------------------------------------------------------------------
-
+# HELPSTRING IMPLEMENTATION
 emc=0
 for arg in "$@"; do
   case $arg in
@@ -180,7 +200,8 @@ fi
 
 # Error handling
 # ----------------------------------------------------------------------------
-
+# TODO: DOCUMENT REASON FOR ONLY BACKING THESE TWO UP
+# REMARK: CAN WE DEFINE AN INPUT JSON FOR ALL PACKAGING/BUILDTIME SCRIPTS FOR DEFINING PATHS AND VARIABLES IN A READABLE, VERSION CONTROLLED FORMAT THAT IS SEPARATE FROM CODE?
 BACKUP_FILES=(
     "./common/defines.h"
     "./common/version.h"
@@ -193,6 +214,11 @@ for file in "${BACKUP_FILES[@]}"; do
     fi
 done
 
+
+# Function: restore_backup_files
+# Description: Restore backup files.
+# Arguments: {("*", "BACKUP FILES TO RENAME BY CUTTING .bak SUFFIX")}
+# Returns: None - side-effect: renames target file(s) to base name without .bak suffix
 restore_backup_files() {
     echo "Restoring original files..."
     cd "${ORIGINAL_DIR}"
@@ -206,7 +232,7 @@ restore_backup_files() {
 }
 
 # Ensure cleanup on exit, even on errors or termination
-trap restore_backup_files EXIT ERR SIGINT
+trap restore_backup_files EXIT ERR SIGINT # SYNTAX: Bind 'restore_backup_files' on any exit condition/signal; function defferal in bash
 
 
 # git checks
diff --git a/term_to_front.sh b/term_to_front.sh
index 81bfce2b..985396ab 100644
--- a/term_to_front.sh
+++ b/term_to_front.sh
@@ -1,5 +1,5 @@
 #!/usr/bin/env bash
-
+# SCRIPT DESCRIPTION: WINDOWS POWERSHELL COMMAND TO FOCUS TERMINAL - UI ONLY SCRIPT
 powershell.exe -Command '
 Add-Type @"
 using System;
@@ -20,3 +20,7 @@ if ($window) {
     [Win32]::ShowWindowAsync($hwnd, 9)  # Restore
 }
 ' > /dev/null
+
+
+# REMARKS:
+# REDUNDANT TO FOCUS TERMINAL WINDOW. FOR FUTURE DEVELOPMENT, DEDICATED NETWORK ONLY MACHINE RUNNING DEV ENV DOCKER IMAGE LOGGING ALL TERMINAL OUTPUT AND IMPLEMENTING GIT HOOKS CAN BE USED AS A 'FLASH STATION'. REPLICABLE FOR SEVERAL INDEPENDENT FLASHING MACHINES TO INCREASE COMPANY FLASH BANDWITH. TURNKEY 'PRESS TO FLASH' POSSIBLE IF IMPLEMENTED ACCORDINGLY.
diff --git a/update.sh b/update.sh
index 72cd3465..1af7c738 100755
--- a/update.sh
+++ b/update.sh
@@ -2,6 +2,10 @@
 
 # Build and flash hex
 
+# Function: check_in_root 
+# Description: Check program entry from project root by verifying './cms/gen_3_0_cms.ioc' exists.
+# Arguments: None
+# Returns: None or exit 1 on err
 check_in_root() {
     if [ ! -f "./cms/gen_3_0_cms.ioc" ]; then
         echo "Should be in the inquis_gen_3_0 root folder. Exiting."
@@ -9,17 +13,25 @@ check_in_root() {
     fi
 }
 
+# Funciton: flash_handle   
+# Description: Flashes handle. Moves to pre-prod code dir for handle, evaluates flasher system serial number, executes STM32 flash
+# Arguments: None
+# Returns: None or exit 1 on err
 flash_handle() {
-    pushd ./handle/Debug > /dev/null
+    pushd ./handle/Debug > /dev/null # Push wd to stack, cd to arg, popd later to return to curr wd
 
+    # $USERDOMAIN - WINDOWS ENV VAR - STORES WINDOWS DOMAIN :: SYSTEM ID
     if [[ "$USERDOMAIN" == "EYALLAPTOP" ]]; then
-        echo "EXPECTED TO BE ON ZACK WIN LAPTOP"
+        echo "EXPECTED TO BE ON ZACK WIN LAPTOP" # Why? Ad hoc
         SN="003400343233510739363634"
     else
-        echo "EXPECTED TO BE ON LAB MAC"
+        echo "EXPECTED TO BE ON LAB MAC" # Why? Ad hoc
         SN="003D00463233510739363634"
     fi
 
+    # Suggestion: Bundle dev env to Docker Image, portable and standard, version controlled dev env
+
+    # Up to this point, we have verified correct dev env, captured serial number, and changed to debug dir for flashing pre-prod code
     STM32_Programmer_CLI -c port=SWD "sn=${SN}" -w gen_3_0_handle.hex -rst
     if [ $? -ne 0 ]; then
         echo "flash failed. Exiting."
@@ -27,9 +39,14 @@ flash_handle() {
         exit 1
     fi
 
+    # return to root dir / most recent directory on stack
     popd > /dev/null
 }
 
+# Funciton: flash_cms   
+# Description: Flashes cms. Moves to pre-prod code dir for cms, evaluates flasher system serial number, executes STM32 flash
+# Arguments: None
+# Returns: None or exit 1 on err
 flash_cms() {
     pushd ./cms/Debug > /dev/null
 
@@ -53,12 +70,16 @@ flash_cms() {
 
 # ----------------------------------------------------------
 
-clear
+clear # Why? Redundant
+
+check_in_root 
 
-check_in_root
 
 # Parse command line argument
-TARGET=${1:-both}
+TARGET=${1:-both} # Set TARGET to arg[1]
+
+
+## Why is below commented? Clean !
 
 # case $TARGET in
 #     cms)
@@ -96,4 +117,9 @@ case $TARGET in
         flash_cms
         ;;
 esac
-echo "Flash completed successfully"
\ No newline at end of file
+echo "Flash completed successfully"
+
+
+# REMARKS:
+# ROOT DIRECTORY CHECK IS UNRELIABLE IF FILES MOVE, COULD BE IMPROVED BY PIVOTING START CRITERIA FOR SCRIPT TO EXISTENCE OF .GIT FILE IN WD AND APPROPRIATE BUILDFILES AT APPROPRIATE REL PATHS INSTEAD OF SOFT ASSERTION OF 'ROOT DIR'.
+# HARDCODED SERIAL NUMBERS UNRELIABLE AND NOT PORTABLE. SUGGEST PROGRAMMATIC SERIAL NUMBER LOOKUP, USAGE OF DOCKER IMAGE FOR PORTABILITY.
